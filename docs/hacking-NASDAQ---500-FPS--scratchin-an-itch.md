<!--yml

类别：未分类

日期：2024-05-13 00:08:17

-->

# 在 500 FPS 下黑客 NASDAQ：挠痒

> 来源：[`hackingnasdaq.blogspot.com/2009/12/scratchin-itch.html#0001-01-01`](http://hackingnasdaq.blogspot.com/2009/12/scratchin-itch.html#0001-01-01)

接下来是转换为 ITCH4 以摆脱所有那些讨厌的 ascii -> int 转换，结果令人惊讶。书籍更新从 98 周期 -> 大约 60-61 个周期！所以 MSFT 的完整书籍更新现在在 15ns @ 4.1GHz 左右。事情开始变得有趣起来了！

接下来就是使用糟糕的 SSE ISA 来加速搜索 8 个条目集。首次试图在订单添加时导致实现更*慢*，超过 15ns 标记。为何会这样呢？因为 99%的订单添加是在条目 0 处。例如标量代码只需要执行 1 次循环迭代。这实际上也不算是迭代 - GCC 完全展开了它，因此我们触及的内存要少得多（2B vs 16B），而英特尔的标量整数代码运行速度非常快，比 9 个 SSE 指令快得多。因此标量获胜。

然而……我们已经知道集合是空还是非空，通过 20 位位阵列。如果为 0，则为空，1 表示非空（有 1-8 个条目）。因此我们可以使用这个值通过一个简单的接受条目甚至无需读取 8x16 位的 WayID - 只需写入，太棒了！再加上 SSE 的免费插槽搜索，我们将平均处理时间削减了约 6 个周期。考虑到订单添加只占消息量的 1%，这是一个显著的加速，我们已经降到了大约 56 个周期，这是 13.7ns @ 4.1Ghz 更新记录簿的时间。

接下来是订单删除 / 订单搜索，执行订单删除代码。非常不幸的是并没有对整体性能有太大改善。最佳结果是 53.2 个周期，所以大约 12.9ns @ 4.1Ghz..然而在这个水平上，操作系统抖动是一个重大问题，使得一致的时间值变得困难 - Linux 在即时、实时问题上非常糟糕.... 还有许多方法可以将这个数字降下来，主要是在外部处理循环中，但是现在已经足够快了，下一个有趣的任务将是审查从交换、经过操作系统堆栈、黑盒的完整延迟。应该会很有趣！
