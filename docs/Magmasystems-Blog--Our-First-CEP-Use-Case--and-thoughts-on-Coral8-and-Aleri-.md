<!--yml

类别：未分类

日期：2024-05-18 05:06:33

-->

# Magmasystems 博客：我们的第一个 CEP 用例（以及关于 Coral8 和 Aleri 的思考）

> 来源：[`magmasystems.blogspot.com/2007/11/our-first-cep-use-case-and-thoughts-on.html#0001-01-01`](http://magmasystems.blogspot.com/2007/11/our-first-cep-use-case-and-thoughts-on.html#0001-01-01)

对于复杂事件处理（CEP）引擎评估，我们选择了一个非常简单的用例。这个用例是：

***告诉我们一个行业的订单显示出异常高水平的时候。***

尽管这个用例看起来非常简单，而且可能不是一个理想的用例来测试 CEP 引擎，但它是我们环境的理想用例。为什么？它迫使我们获取之前对大多数人不可访问的各种数据流，并迫使这些数据流的拥有者清理他们的数据。

（注：这个用例是一个非常通用的 CEP 测试用例。我没有透露任何会给我的公司带来竞争优势的特殊用例，也不会在这个博客上这样做。）

去年九月，Gartner CEP 峰会上，Gartner 的 Mary Knox 提到，大型组织成功进行 CEP 项目的一个障碍是解放所有需要的数据源的过程，以及让各个孤岛式系统相互对话。我们在我们的组织中也发现了这种情况。我们认为如果我们能让这个简单的用例工作，那么我们就赢得了这场战斗的 50%。

我们需要什么数据来实现这个用例？

+   我们需要接入实时订单流。订单流通过 FIX 消息传递给我们，对于旧系统，通过即将过时的专有消息传递。幸运的是，我们找到了一个为我们提供这些信息的系统。虽然这个系统是一个监控 GUI，但我们已经认识到它对我们公司的的重要性，并且我们正在与产品所有者合作，将他的应用程序拆分为一个可订阅的订单服务和一个更薄的 GUI。

    +   我们需要历史订单数据，以便确定一个行业的“正常活动”是什么。幸运的是，我们有这些数据，我们正在获取访问权限的过程中。我们还需要理解“异常活动”是什么意思？这意味着“一个行业 30 天移动平均线以上的 2 个标准差”吗？

    +   我们需要能够获取一个行业列表，并且对于每个订单，我们需要将每个股票代码映射到其行业。行业由所谓的 GIC 代码表示，共有 4 级 GIC。我们需要确保所有公司行动都能渗透到这些映射表中。所以，如果一家公司更改其股票代码（如 SUNW 到 JAVA），那么新的股票代码需要自动添加到这些映射表中。

假设我们能够获取所有需要的数据，而且数据流是纯净的。我们必须将其导入 CEP 引擎进行分析。

如果你认为编写一个正常的、程序化的程序（即：一个 C#应用）来完成这项分析，步骤很简单。

1) 读取所有参考数据。这包括股票到部门的映射以及每个部门每个时间片正常活动的列表。我们将认为时间片是一个一分钟的间隔。在 6.5 小时的交易日内，有 390 分钟。还有 11 个“GIC0”部门。所以，时间片将是一个从 0 到 389 的整数。

2) 订阅 FIX 订单的流。

3) 每当一个订单进来时，提取股票并将其映射到部门。我们还关心订单中的股票数量和下单时间。对于每个订单，为该部门和该时间片增加一个运行总计。

4) 忽略已经超过当前时间片的任何订单。还忽略在正常交易时间之外的任何订单。这样，我们就不考虑可能通过我们的系统延迟的任何订单。

5) 如果我们检测到一个新的且较晚的时间片，那么检查前一个时间片的所有部门。如果任何一个部门显示出活动增强，那么通知用户。然后，清除所有部门的总计，并开始为所有部门积累新的总计。

这看起来很简单。我会把这个任务分配给一个好的 C#开发者，希望能在一到两天内得到一个完整的程序。

现在，任务是将此映射到 CEP 引擎。

大多数 CEP 引擎都有一种基于 SQL 的语言。所以，你可以想象上述所有处理步骤都在 CEP 引擎中通过多个流进行传递。对于上述步骤 1)，在 CEP 引擎中我们将有两个输入流，一个用于股票到部门映射数据，另一个用于“正常部门活动”数据。你可以想象 SQL 中的两个简单的 SELECT 语句，它们从某个外部数据库中读取这些数据，并在 CEP 引擎中构建两个内存表。

对于步骤 2，你需要编写一个专门的输入适配器，它订阅一个通信通道（套接字或 JMS）并读取和解析 FIX 订单。大多数订单作为 NewOrderSingle 消息传来（FIX 消息类型='D'）。FIX 有各种版本，但让我们假设一切都是以 FIX 4.2 消息的形式传入的。

大多数 CEP 供应商都支持进程内和进程外适配器。进程内适配器比进程外适配器快，但进程外适配器通常更容易编写。进程外适配器将从某种通信总线（甚至从数据库表或平面文件）中读取数据，并将数据流写入 CEP 引擎。理想情况下，CEP 供应商应该支持 FIX 的进程内输入和输出适配器。

步骤 4)很简单。我们为订单计算 0 based 时间片，如果它低于 0 或高于 389，那么我们在流中忽略这个订单。这可以通过 SQL 语句中的一个简单的 WHERE 子句来实现。

我们还需要记录“当前时间片”，并忽略任何在当前时间片之前的订单。因此，我们需要一个“全局变量”的概念，当我们看到一个后来时间片的订单时，我们需要更新这个变量。这在过程语言中很容易实现，但在 SQL 中最好的实现方式是什么？

步骤 3)和 5)很有趣。我们需要为每个部门保留一个一分钟的窗口。这个窗口应只保留当前时间片的运行总计。当新的时间片进来时，我们需要分析当前时间片的部门活动，进行任何警报，然后清除所有部门的总计。同样，这在 C#应用程序中是非常容易实现的，但将其翻译成 SQL 则是一个挑战。

在步骤 3)中，将股票代码映射到部门很简单。它只是将订单中的股票代码与映射表中的股票代码进行连接。有趣的是，为流选择窗口类型。我们是累积所有部门的所有订单，以供一分钟的时间片使用，然后，当我们看到一个新的时间片时，我们只需对每个部门的订单数量进行 COUNT()？还是我们简单地为每个部门保留一个窗口，每个部门作为一个订单进来时保留运行总计？

Coral8 支持滑动和跳过窗口的概念。Aleri 目前只支持滑动窗口。使用 Coral8，我们可以设置一个保留一分钟数据的窗口，我们还可以告诉流，它在一分钟后的输出应该被清空。然而，我们不想将 FIX 订单消息中的 TransactTime 与计算机上的实际时钟绑定。我们需要一个流，在列的特定值上产生输出，而 Coral8 和 Aleri 似乎还没有这个功能。

以下是一些 Coral8 代码，展示了窗口和流：

CREATE WINDOW TickerAndSector

SCHEMA (Ticker STRING, Sector STRING, SectorId INTEGER, Shares INTEGER,

TransactTimeBucket INTEGER)

KEEP EVERY 60 SECONDS;

INSERT INTO TickerAndSector

选择

FlattenNewOrder.Ticker,

TickerToSectorMap.SectorName,

TickerToSectorMap.SectorId,

TO_INTEGER(FlattenNewOrder.Qty),

TimeToTimeBucket(FlattenNewOrder.TransactTime, 'HH:MI:SS AM')

FROM

FlattenNewOrder,

TickerToSectorMap

WHERE

TickerToSectorMap.Ticker = FlattenNewOrder.Ticker

OUTPUT EVERY 60 SECONDS;

第一个语句定义了一个窗口，该窗口保留一分钟的订单数据。一分钟过后，窗口将清空其内容。

第二个语句在我们收到新订单时，会向窗口插入新行。一分钟过后，窗口将其输出发送到管道下游的另一条流中。（我们希望数据在窗口清空之前发送到下一条流。否则，我们将丢失所有数据。）

到目前为止，在我的简要评估中，我发现 Coral8 中的第 5 步难以实施。Aleri 通过使用 FlexStream 实现了这一点。FlexStream 是一个附带有程序逻辑的流。Aleri 有一种自定义的 C 语言，你可以用它来实现 FlexStream 中的程序逻辑。但是，如果你编写太多使用 FlexStream 的逻辑，那么你不如直接写一个优美的 C#应用程序呢？

为了验证一些 CEP 引擎，我最终花了一天时间编写了一个实现此用例的 C#应用程序。出于娱乐，我添加了一个标签，展示了使用非常出色的 ChartFX 包的一些动画图表。交易部门的负责人对我的这款简单应用程序如此兴奋，以至于他开始带来各种交易员来看我的应用程序。因此，除了这款小应用程序能给交易员提供他们之前所没有的信息外，它还提供了一种炫酷的方式，让他们可以看到各个部门的实时动态。

除了掌握 SQL 技能外，优秀的 CEP 开发者还需要调整自己的思维方式，以考虑流水线式的 SQL 处理流。在雅虎 CEP 论坛上，关于 SQL 是否是 CEP 处理合适的语言的争论正在进行中。到目前为止，就这个用例而言，我认为 SQL 是合适的，但我还需要走出 SQL 的思维方式，应用一些程序逻辑。

我仍需说服自己的一件事是，CEP 引擎能比自定义代码做得更好。我洗耳恭听。任何 CEP 供应商（即使是 Streambase）都欢迎在本文档下留言，告诉我如何使用他们的系统实现这一用例。

©2007 Marc Adler - 版权所有
