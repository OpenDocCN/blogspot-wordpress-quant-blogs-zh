<!--yml

类别：未分类

日期：2024 年 05 月 13 日 00:08:22

-->

# hacking NASDAQ @ 500 FPS：trivial reject

> 来源：[`hackingnasdaq.blogspot.com/2009/12/trivial-reject.html#0001-01-01`](http://hackingnasdaq.blogspot.com/2009/12/trivial-reject.html#0001-01-01)

好了，言归正传，问题是我们需要测试一个 64 位的唯一索引（OrderID），所以直接的数组不够用。下一个选择是使用 std::map<>，使用 orderID 作为键，存储指向 order 结构的指针。请注意，我们在 MSFT 符号上测试了 7 亿条消息，因此拒绝率是所有消息的 99.7%。此外，请注意，这是 ITCH3.1，因此我们需要对 orderid 进行 ascii->u64 转换，这也反映在性能数字中。

首先是 std::map<>，它……无法运行。需要分配大量内存，基本上无法超过一两个小时的交易时间，假设内存足够……在 4.1ghz 下表现为 553cycles/消息或 135ns。

接下来是一个无序 map，因为我们不需要它排序，……情况一样。需要大量内存，并且无法完成。假设你有足够的内存，它的速度是 285cycles/消息或者 69ns@4.1ghz。

如果你有 64GB 内存且是你的许多程序员，这个速度还不错，但我们可以做得更好。诀窍在于我们拥有无法表达给 STL 的信息，那就是 orderID 只使用了 34 位数据，工作集大约有 18k 个订单，因此让我们利用位图数组 + 16 通道集来利用它，类似于硬件组相联高速缓存。

这样做的原理是，将 20 位的 LSB 用作 1bit 数组的索引，从而得到 128KB 数组（2²⁰ / 8 / 1024）。如果位已设置，则集合中有有效条目，否则就没有 - 简单的拒绝。如果存在条目，那么就是一个简单的 16 个条目搜索空间，很容易并行化。

因此从 OrderID -> Order_t* 转换速度快，O(1) 或 O(16)，具体取决于你的看法，并且有一个不错的固定内存占用空间。如果集合溢出和数据丢失，问题就会出现，但 MSFT 的最大占用空间为 3 个条目，实际上我们会在集合中降到 8 个条目。

总占用空间 = (2²⁰ / 8) + (2²⁰ * 16 * 8)  约等于 128MB。然而，正如优化 101 中所述，保持占用空间最低是至关重要的，我们可以进一步减少这个值。对于每个集合条目，我们知道它的低 20 位是唯一的，并且对所有的设置条目都是相同的。OrderID 有 34 个有效位，因此降到了 14 位有效位，我们可以在设置搜索空间中使用 16 位值，而不是全 64 位，太好了。

占用空间 = (2²⁰ / 8) + (2²⁰ * 16 * 2) 约等于 32MB

由于数据表明最大的占用是 3 个条目，所以可以将集合减少到每个集合 8 个条目。

占用空间 = (2²⁰ / 8) + (2²⁰ * 8 * 2) 约等于 16.125MB

这几乎完全适应 L3 缓存！数字达到，平均每个消息 108 个周期，这意味着在一个符号上以 4.1GHz 的速度进行全书更新，每个消息需要 26ns。请记住，这主要只是拒绝代码在起作用，它是直接的 C 语言（没有汇编/内部函数）, 我们处理的是 ITCH3.1，而且书籍更新代码非常糟糕且影响了平均值。所以...还有很多余地来降低这个数字！
