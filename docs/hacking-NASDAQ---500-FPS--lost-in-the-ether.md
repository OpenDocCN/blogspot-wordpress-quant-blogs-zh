<!--yml

类别：未分类

日期：2024-05-13 00:07:45

--> 

# 在纳斯达克进行黑客攻击 @ 500 FPS：迷失在以太网中

> 来源：[`hackingnasdaq.blogspot.com/2010/01/lost-in-ether.html#0001-01-01`](http://hackingnasdaq.blogspot.com/2010/01/lost-in-ether.html#0001-01-01)

好... 那 37,500 纳秒去哪了? 我有些怀疑，但让我们深入了解一下并得到一些数字。首先要尝试的是驱动程序中的任何其他拨号和旋钮，即：

- 禁用 NAPI

- 分离的 Rx 和 Tx 中断

从上一篇文章的基线开始，除了使用英特尔网站上的最新驱动程序而不是 2.6.30 内核中的驱动程序之外，我们得到以下情节（下图）。 意料之外的是.. 它看起来非常相似。

英特尔 1.1.2 NAPI 驱动

接下来要做的是禁用 NAPI。导致 CPU 负载增加，但潜在减少延迟。情节看起来有点不同，但大致相同，有一些相当明显的变化，延迟增加了.. 糟糕。

禁用 NAPI

另一个内置的旋钮是，分离 Rx 和 Tx 中断，因此它使用每个队列的唯一中断，而不是共享的。有趣的是，直方图的形状变得更加清晰，假设可能是由于中断延迟减少。

禁用 NAPI，分离 Rx 和 Tx 中断（+64bx8 标头）

这一切都很好，但对总延迟毫无帮助，实际上使情况变得更糟，所以现在是时候戴上橡胶手套并修改驱动程序了。

当我们做准备时，让我们回过头来查看实际发生了什么。图表（左侧）显示了我们需要测试的主要组件的高层视图。即，

- 机器 A 应用程序

- 机器 A 内核 + 驱动程序

- 织物 / 以太网 / 硬件

- 机器 B 内核 + 驱动程序

- 机器 B 应用程序

... 然后又回来了。

NIC 驱动中有 2 个有趣的要点，即：

- Rx 中断分派

- Tx 描述符写

这些事件是软件和硬件之间的第一次和最后一次接触点。 Rx 中断分派在整个软件/操作系统栈首次感知到存在新的 UDP 数据包时给出时间戳。

另一方面，英特尔网络卡使用内存中的硬件结构，称为*描述符*，其中包含有关原始以太网帧的位置、大小和其他一些属性。为了将数据发送到网络上，驱动程序在环形缓冲区中构建此结构，然后推进硬件环形缓冲区的位置。这种推进告诉硬件有待处理的新描述符，因此它可以获取描述符和相关内存，最终将其推送到物理层/电线上。基本上，硬件/软件接触点是驱动程序将数据包交给硬件处理的时候。

使用这两个事件+sendto()和 recvfrom()的时间戳，我们可以重构时间配置文件，并查看 HW <-> App 延迟 时间戳以一种有点粗鲁又有趣的方式存储。我们在每个 ITCH4 消息中添加了一个 64b x 8 的头部，这几乎增加了消息大小的一倍，但使事情变得容易。在驱动程序中，我们只需检查 UDP 头部的魔术端口号，如果匹配，则在唯一的 64b 头部插槽中写入时间戳。是的，相当讨厌.. 但这是一个假日的黑客项目 - 唉..

好了，所有的准备工作都做好了，那看起来如何？让我们按时间顺序跟踪一个数据包。首先，我们在机器 A 的用户空间发送原始的 ITCH4 数据包 + 头部。

从用户空间到 NIC 的延迟（机器 A）

这里（上面）我们看到了从用户空间 sendto()到驱动程序更新 Tx 描述符环的时间 - sendto()的完整软件延迟。在这一点之后，数据包穿越网络织物从 NIC HW + Switch + NIC HW 到达 Machine B 的 NIC。

NIC Rx 中断延迟 -> 用户空间（机器 B）

数据包被 NIC 解码后，在机器 B 上生成一个 Rx 中断，告诉它，有一些数据准备好了。上图显示了 Rx 中断到达 CPU 的时间，再到 recvfrom()在用户空间返回的时间 - 完整的 recvfrom()软件延迟。为什么有两个峰值？目前还不清楚。一个可能的原因是数据包大小阈值导致分割代码路径，因此将配置文件拆分为两个垃圾桶。

Machine B 的用户空间代码是微不足道的。它设置一个头部时间戳，然后对确切的相同数据包执行 sendto()，从而得到从 sendto()到 NIC 的完整软件延迟。

sendto() -> Tx 描述符更新（机器 B）

再次看到这两个峰值，嗯... 需要调查。还有一件事要注意的是，MachineB 上的 sendto()延迟比 MachineA 要慢得多。

数据包在 Machine B 的 NIC 上之后，返回交换机，到达 MachineA 的 NIC 并生成一个 Rx 中断 - 机器 A 上 recvfrom()的完整软件延迟（下面）

Rx ISR -> recvfrom()（机器 A）

这非常快，也是一个单独的配置文件 - 嗯... 可疑。无论如何，我们现在有了填补空白的一切。令人困扰的是，我们离总延迟 40,000ns 还有很长的路要走！这是好事，但也是坏事。所以，通过几行代码，我们得到了顶级 MachineA/B 全软件延迟图。

总软件延迟（机器 A）

![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhpVnMicYLqiy6dTQG9hovaeWaXvq_CDtFiMVOZoOdiFhcwSx1NyQLInRHFFcm28kzNnJWJfUjyNTb0DhYWTr9IhyK0XyOTilg9kN0Q8OWscY4_M-UbS9EaY-L71FdL6iKQVmgJj3FrQw/s1600-h/b_latency_stock.png)

总软件延迟（机器 B）

这是单个数据包的 Rx+Tx 延迟时间，并将该数字绘制在直方图上。真的很奇怪的是，机器 B 比机器 A*慢*，这有点令人惊讶。一个可能的延迟来源是，机器 A 有 2 个硬件线程，而机器 B 有 8 个硬件线程。我对 Linux 调度算法的了解不够深，无法确定这是否会改变配置文件，但值得进一步检查。

…… 然后进行数学计算，你会得到一个时延时间的图表（下方）。

时延时间（NIC->交换机->NIC）

这是一个巨大的…… 巨大的…… 时间块，比如说 30,000 纳秒！好消息是，SW 的延迟时间大约是 10,000ns，接近我们的吞吐量数值 3,500ns（x3），所以我们的吞吐量/延迟时间是 1/3。第二个好消息是，这个 GigE 交换机是我花$100 买的便宜老旧的二手货 - 24 口、机架式 GigE，考虑到价格还不错，但不是思科的。它是日本的 Corega 品牌，在亚洲等同于 Netgear，性能还可以，价格便宜，一般的局域网不需要低于 10,000ns 的延迟，所以交换机是我们的主要怀疑对象…… 感兴趣的设备。
