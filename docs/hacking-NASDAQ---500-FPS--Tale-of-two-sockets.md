<!--yml

分类：未分类

日期：2024-05-13 00:01:16

-->

# 以 500 FPS 攻击纳斯达克：两个插座的故事

> 来源：[`hackingnasdaq.blogspot.com/2013/03/tale-of-two-sockets.html#0001-01-01`](http://hackingnasdaq.blogspot.com/2013/03/tale-of-two-sockets.html#0001-01-01)

从前，有一个远离的地方有一个插座...

术语“套接字”有不同的解释，对于网络世界中的左侧人员，它通常指的是

[Berkely sockets](http://en.wikipedia.org/wiki/Berkely_sockets)

即 socket(AF_INET, _...) 发送/接收。

对于右侧的人来说

[LSI](http://en.wikipedia.org/wiki/Large_Scale_Integration#LSI)

路上的意思是插入一个地方

[ASIC](http://en.wikipedia.org/wiki/Application-specific_integrated_circuit)

. 如今，我们要谈的是后者，即 CPU 通常插入的空间。

最近面临了一个不寻常的时间问题——某些代码已经消耗了 1 到 10 微秒。在其他情况下，代码运行的如此之快本应让人高兴，但自然的顽固保证了

[SOB](http://en.wikipedia.org/wiki/Son_of_a_bitch#Son_of_a_bitch)

那就是，禁止这样的事情...至少在物理系之外。

它让我思考，质疑代码和硬件的每个方面，一个令人不安的问题突然浮现。

### 两个插座之间的周期计数器是否同步？

![](http://www.pcper.com/files/imagecache/article_max_width/review/2011-12-14/die.jpg)

众所周知并记录，在尼哈拉姆时代后，英特尔周期计数器非常可靠，对于功率状态、核心之间的变化也是稳定的，而且还能抵抗着奔腾，如果你确实想计数的话，后者是件让人烦恼的事情。为什么它总是以盒子上标示的频率频率率率（列表那个？）而全部趋于零？尼哈拉姆英特尔设计者决定 rdtsc 及其姐妹产品应该基于“UnCore”中的一个时钟，这个时钟位于 IO 逻辑附近，因此是中央集中式的，对所有核心来说是一样的。

在单个 CPU 插座机器上，rdtsc 自从好旧的奔腾 90 时代以来就一直是一个值得信赖的朋友，但从未测试过它在 CPU 插座之间的行为。然而，它在两个 CPU 插座之间同步吗？简短的答案是，根据各地的说法，它在 CPU 插座之间非常良好地同步。然而...作为我所说的一个怀疑论者——不要相信互联网上的文字（比如本博客！），所以...  一个测试。

测试很简单，运行 2 个不同插座上的硬件线程（HWT）。每个 HWT 都会更新内存中的共享周期计数器。预期结果是，本地 HWT 的周期计数器应该*始终*大于内存值。

为什么？例如案例 1

周期 |         HWT 0     |  HWT 1

0  |  样本           |

1  |  写入内存  |

2  |                   |    样本

3  |                   | 写入内存

或者反常的极端案例

周期 |         HWT 0     |  HWT 1

0  |  样本           |      样本

1  |  写入内存  |   写入内存

2  | |

**1 - 以最小的字体希望没有人会读到...当 64 位周期计数器溢出时，测试失败。

**2 - 是的，我完全错觉，认为上面的东西与真正的英特尔 cpu 内部发生的巫术魔法有一些接近

假设周期计数器是同步的，那么每次我们对周期计数器进行采样时，计数器都将高于写入内存中的值 - 因为内存中的值是过去的周期计数，根据定义，比当前计数小。

在代码中（g_tsc 是共享内存值）

u64 memory_tsc = g_tsc;

u64 tsc = rdtsc();

s64 dtsc = tsc -  memory_tsc;

assert(dtsc >= 0);

如果两个周期计数器（一个用于 HWT 0，一个用于 HWT 1）是同步的，则此操作将起作用，否则会失败。然而这儿有一个问题...如果我们按照此方式运行程序，将会失败。

有 3（可能更多？）个原因

1) 周期计数器不是完全同步的

2) x86 微架构正在重新排序内存操作

3) 编译器重新排序了加载。

检查了汇编代码和 3)不成立，所以怀疑 2)因为 x86 以其非常松散的内存排序而臭名昭著，所以稍微修改了上面的内容，添加了一个 lfence 指令。这样做的作用是将所有内存加载（但不是存储）串行化，与当前指令提取流相关 - 形成某种障碍。

添加了这个后程序运行得非常完美，因此得出结论，套接字之间的周期计数器是完全同步的，或者非常接近同步。

![](http://msptelemarketing.com/wp-content/uploads/2011/05/istock_000010672195xsmall-300x199.jpg)

现在我们知道它们非常接近同步，问题是有多接近，它是否能解释我的负 10 微秒。为了解决这个问题，我们对周期计数器和内存值之间的差值运行直方图，显示出 100-200 个周期的范围，在 3ghz 时最多为 66.66ns，可能是套接字之间的 QPI 成本。总的来说这非常紧凑。

不利的一面是，这是典型的目光狭窄，并不是负的延迟数字的原因。真正的原因是堆栈上方的某个地方，很尴尬，不好在这里写出来。
