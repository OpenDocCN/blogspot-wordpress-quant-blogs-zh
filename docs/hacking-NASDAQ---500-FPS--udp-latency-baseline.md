<!--yml

category: 未分类

日期：2024-05-13 00:07:49

-->

# 在 NASDAQ 的 500 FPS：udp 延迟基线中进行黑客攻击

> 来源：[`hackingnasdaq.blogspot.com/2010/01/space-time-continum.html#0001-01-01`](http://hackingnasdaq.blogspot.com/2010/01/space-time-continum.html#0001-01-01)

现在 NIC 已经整理好了，我们可以看一下往返延迟数字。基于上一篇文章的估计约为 3450ns，或 3.5 微秒，可能...呃.."稍微"有点偏差..

首先，我们将全力以赴，所以 A 发送尽可能多的数据包到 B，而 B 尽可能将它们传递回 A。当 A 收到数据包时，它有一个发送时间戳，因此我们可以将时间差记录到直方图（下面）

以全速发送

是的，这有 200

**微秒**

最后，比 3500ns 多一点点。真是一团糟..将其简化为串行往返延迟直方图，转换为：

1）A 发送

2）B 接收

3）B 返回到 A

4）A 接收

5）A 下一条消息

因此，系统正处于最低工作负载，因此应该是最小的往返延迟。我们得到了下面的图表（下面），这样会干净得多，即使非常令人不安。

串行往返

正如您所看到的，它的时钟速度大约为 100,000ns！比预期的时间长了 96550ns，而且波动非常小。

发生了什么？首先，一个几乎准确集中在 100,000ns 的薄剃刀锋线非常可疑，表明有一个计时器正在工作。通过一点挖掘，原来是有的，被称为中断协同 - 在英特尔网络卡驱动程序中一般为 NAPI 的一部分。它的目的是通过将中断分批到组中来减少 CPU 负载，因此每 32 个数据包只有 1 个中断，因此所有 32 个数据包*可能*在该单个中断处理程序中被处理。这很好，提高了网络吞吐量，是一个很好的通用解决方案，但正在耗尽我们的低延迟系统。

在英特尔的"使用 GbE 控制器的中断调节"手册的第 19 页上，有一个很好的图表。

如果您检查了圈着的区域，那是英特尔驱动程序的默认参数设置，看起来...大约是 50,000ns，方便的（来回）加起来是我们直方图中看到的 100,000ns。因此，让我们尝试修改参数。首先更改机器 B 为 InterruptThrottleRate=8000（英特尔的旧默认值）

机器 B 中断节流速率=8000

太好了，我们的延迟数字变了（方向是错误的），但还是非常直接的相关性。因此，让我们在机器 B 上停用所有节流。

机器 B 中断节流速率 = 关

砰，我们只需减少一半的延迟！一句话做得不错。尖峰仍然非常高而薄，这表明里面仍然有一个计时器元素。接下来，也要为机器 A 禁用节流。

机器 A 和 B 中断节流速率 = 关

最后，我们有了一个相当小的扩散，但并不是看起来像计时器的这么薄，必须接近我们的基线往返数字。应用程序->库->内核->网络接口卡->电线->交换机->电线->网络接口卡->内核->库->应用程序 B 然后返回。

机器 A 和 B，中断节流速率=关闭

而且，我们得到了一种延迟的近距离测试，来回传输时间为 40,000ns，这...太多了。然而根据之前的实验，其中有 3500ns 是在吞吐量中的，所剩下的时间去哪了呢？
