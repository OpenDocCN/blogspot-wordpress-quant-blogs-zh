<!--yml

分类：未分类

日期：2024 年 5 月 18 日 15:30:57

-->

# 再次讨论语言 | Tr8dr

> 来源：[`tr8dr.wordpress.com/2010/10/03/languages-again/#0001-01-01`](https://tr8dr.wordpress.com/2010/10/03/languages-again/#0001-01-01)

2010 年 10 月 3 日 · 11:35 am

我大量的工作/性能相关的东西都是用 Java 写的（不管好坏），因为它非常便携，如果你知道你在做什么，它的性能非常接近 C++。我更愿意使用 F# / C#，因为在我看来，它们是远远优越的语言（尽管 C#的遗产比任何其他语言都要多）。

问题是，我需要在 Linux（以及事实上，我最喜欢的开发平台是 osx）上部署。下面是在一个 core i7 920 linux 盒子上进行 5 亿次 nbody 问题迭代的性能#数据：

![](https://tr8dr.wordpress.com/wp-content/uploads/2010/10/screen-shot-2010-10-03-at-12-20-32-pm.png)

nbody 问题在计算物体之间的欧几里得距离时使用了 sqrt。我开始想知道差异是否在于库数学函数的实现上。所以我做了一个使用（慢速）数值算法来计算 sqrt 的实现，这个算法在各种语言中都是通用的。这样我们就有了一个苹果对苹果的比较。C++与 Java 的数字现在是：

![](https://tr8dr.wordpress.com/wp-content/uploads/2010/10/screen-shot-2010-10-03-at-12-20-48-pm.png)

现在差异是 1.9%。实际上，额外的 10 秒差异可能是 Java 启动加上 JIT 编译。这与我过去所做的其他比较相呼应。

我用 Java 写的代码在性能上超过了等效的 C++代码。例如，JIT 编译在可以避免/在运行时可以确定的情况下，足够聪明地避免虚拟函数调用。用静态编译通常不能如此有效地做到。在英特尔架构上，虚拟函数调用的成本是非虚拟的 3 倍。

JVM 是目前最好的虚拟机（甚至比 MS .NET vm 还要快）。我多么希望看到 JVM 中的 JIT 编译技术应用到一个跨平台的.NET VM，比如 Mono。或者，如果 JVM 扩展到包括值类型、一个正确实现的泛型类型系统和一些函数式特性，可以想象针对 JVM 的 IL 进行目标。

我的理想是可以将 C#和 F#交叉编译到 JVM 字节码（就像 ikvm 可以将 Java 字节码映射到 CLR 一样）。考虑到 Mono 实现已经存在，.NET 库将是一个更大的问题。Mono 的开发者们手头的事情很多，似乎更专注于广度而不是超高性能。

我猜测.NET 和 Java 社区大体上是分开的，所以可能很少有人希望看到 F#针对 JVM 进行优化。只能希望 mono VM 继续提高性能和垃圾回收效率，或者一个新的包容性虚拟机填补 JVM 曾经统治过的空白。
