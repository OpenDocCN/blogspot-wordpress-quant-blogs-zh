<!--yml

类别：未分类

日期：2024-05-18 05:15:29

-->

# Magmasystems Blog: 对象缓存考虑因素（第一部分）

> 来源：[`magmasystems.blogspot.com/2006/11/considerations-for-object-cache-part-1.html#0001-01-01`](http://magmasystems.blogspot.com/2006/11/considerations-for-object-cache-part-1.html#0001-01-01)

假设我们想要编写一个多平台、分布式、基于订阅的对象缓存。要编写终极对象缓存，我们需要做些什么？

让我们考虑编写缓存中间件时需要考虑的各种问题。我相信像 Gemstone 这样的供应商已经过这个过程了，但为什么不再次进行呢！

**多平台支持**

大多数投资银行都有 C++（包括 Win32 和 Unix）、C#/.Net 和 Java（包括 Win32 和 Unix）应用程序的组合。常见的是.Net 前端与 Java 服务器通信，进而与基于 C++的定价引擎进行通信。我们需要以某种形式表示对象数据，以便所有这些不同平台上的应用程序都能轻松访问。

最普遍的表示方式是将对象表示为纯文本，并作为文本发送。我们会使用哪种文本表示？

**XML**

– 准通用型。我们必须确保一个系统生成的 XML 能被其他系统读取。XML 序列化在 Java 和 C#应用程序中广为人知，但古老的 C++应用程序呢？对于 C++，我们会使用 Xerces 吗？此外，还有序列化和反序列化的成本，更不用说通过网络发送的数据量了。

**名称/值对**

– 易于生成和解析。与 XML 相同的成本。我们必须为每个系统编写自己的序列化和反序列化方案。复杂、层次化的数据怎么办？简单的名称/值对能有效表示复杂数据吗？或者我们最终要重写 XML 规范？

我们可以将对象以真正的二进制对象形式存储，而不是文本。我们存储哪种类型的二进制对象？原生对象或系统无关对象？如果您有多种平台向对象缓存写入，我们是以创建对象的系统的二进制格式存储对象，还是选择一个平台作为主系统？

**主格式**

– 我们选择一种格式，比如 C++、C#或 Java 二进制对象。我们需要一系列适配器来转换二进制格式。我们还需要一个指示，表明是哪个平台在进行读取或写入操作。假设我们选择将所有对象以二进制 Java 对象的形式存储。如果一个 Java 应用程序读取一个对象，那么与对象转换相关的成本就不存在了，因此我们只需要沿着链路发送一个二进制 Java 对象（尽管我们可能需要担心 Java 各个版本之间的差异……一个具有 Java 1.5 特定类型或类的 Java 1.5 对象能被一个 Java 1.4 应用程序读取吗？）。如果一个 C#应用程序想要读取 Java 对象，那么我们必须进行一些翻译。（我们应该使用类似

[CodeMesh](http://www.codemesh.com/)

的东西来做到这一点吗？）我们还需要确保适配器能够支持各种语言的所有特性。例如，假设 Java 提出了一种 C#不支持的新数据类型……我们会尝试在 C#中找到该类型的某种表示，还是根本不翻译这种特定的数据类型？

**原生格式**

– 我们存储纯二进制对象，不考虑读取或写入对象的系统。没有转换层。应用程序需要自己负责进行转换。这是存储对象最快、最高效的方法。然而，不同的团队可能会编写他们自己的转换层版本。

选择原生对象格式时我们还要考虑哪些其他因素？

订阅中的增量更新怎么样？如果我们存储的是大对象，那么我们可能只想广播对象的变化，而不是重新发送整个对象。增量传输有利于以文本形式发送变化，如果我们只是将对象以文本形式存储，我们就可以节省将二进制转换为文本的成本。在这种情况下，名称/值对是被优先考虑的。

如果需要，大量的名称/值对可以被压缩，但我们必须考虑压缩和解压缩所需的时间。

我们的对象缓存能同时存储文本和二进制吗？当然，为什么不呢。我们可以将缓存区域标记为支持二进制或文本，并为每种操作提供适当的插件。

如往常一样，欢迎发表评论。

©2006 Marc Adler - 版权所有
