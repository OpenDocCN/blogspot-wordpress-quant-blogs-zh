<!--yml

分类：未分类

日期：2024 年 05 月 13 日 00:04:17

-->

# 以 500 FPS 黑客纳斯达克：愚蠢的技巧

> 来源：[`hackingnasdaq.blogspot.com/2011/10/silly-tricks.html#0001-01-01`](http://hackingnasdaq.blogspot.com/2011/10/silly-tricks.html#0001-01-01)

…并且缓慢但稳步地前进。这个星期我在交易所发现了一些奇怪的事情，以及在使用以日为结束点的滴水不实时交易数据时我策略出现的问题。使用了稍微过时的 3-4 个月前的数据，觉得应该足够接近了，但是……几个月内变化了多少啊。在我有时间的时候会写篇关于这个的博文。

我非常喜欢自主计算，这意味着硬件和软件系统进行完整性检查并自动恢复，显而易见的例子是硬盘的 RAID 和内存的 ECC。曾经我在（插入所有都知道的大公司）和他们的一位硬件工程师进行了一次迷人的讨论。

HW 伙计：嗯，那是一个奇怪的问题，0xbeefbabe 偏移量处的寄存器值是多少？

黑客纳斯达克：注册编号 0xbeefbabe 实际上是……0x01234567。

（沉默）

HW 伙计：你确定那是正确的吗？

黑客纳斯达克：…是的

HW 伙计：那是不可能的，你疯了吧？

.

.

.

他指的是该寄存器的最高有效位是其他 30 位的逻辑或。这使得 0x01234567 的值不可能出现，唯一正确的值是 0x**8**1234567。故事的道理是把自我完整性检查编码到一切中，可以轻而易举地捕捉到并且不浪费时间处理愚蠢的错误 - “哦哦，糟了，电缆没接上，抱歉”的那种

…这导致了 OUCH 和长度为 14 字节的标识符 token。我所做的是将最后一个字节作为完整性检查，使得前面 13 个字节的 32 位和模 26 的值成为它的值。

例如

u32 Sum = 0;

for (int i=0; i < 13; i++) Sum += P->Msg.OrderAdd.Token[i];

P->Msg.OrderAdd.Token[13] = 'A' + Sum % 26;

这样很容易检查你目前查看的 OrderToken 是真实的还是损坏的，完全不费力。到目前为止，我已经发现了几次，通常是当一些代码出了问题并在内存中乱跑的时候。

…是的，这只是在开发阶段，生产中没有错误……至少目前还没有 :)
