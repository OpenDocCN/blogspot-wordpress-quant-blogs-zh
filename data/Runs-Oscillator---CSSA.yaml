- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-12 18:20:47'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-12 18:20:47
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Runs Oscillator | CSSA
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行振荡器 | CSSA
- en: 来源：[https://cssanalytics.wordpress.com/2010/07/26/runs-oscillator/#0001-01-01](https://cssanalytics.wordpress.com/2010/07/26/runs-oscillator/#0001-01-01)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://cssanalytics.wordpress.com/2010/07/26/runs-oscillator/#0001-01-01](https://cssanalytics.wordpress.com/2010/07/26/runs-oscillator/#0001-01-01)
- en: Here is the “runs oscillator” mentioned in the adaptive time machine sequel.
    This is something we will be looking at towards creating an improved time machine
    algorithm. The “runs oscillator” is constructed by ranking a down run (if that
    is the current run) versus all down runs in the prior 252 days. The same is done
    for up runs. This leaves two oscillators ranging from 0 to 1 for both up and down
    runs. The runs oscillator is fused together by multiplying the down run oscillator
    by -100 and the up run oscillator by 100 and summing them together. The final
    oscillator ranges between -100 and 100, with 100 representing maximum overbought
    conditions, and -100 being maximum oversold conditions.  In the example below
    we use median overbought and oversold conditions for countertrend entries (long<-50
    and short>50) with an exit on a cross of zero. Essentially we are waiting for
    a median down run for longs, and a median up run for shorts while looking to exit
    on an up day for longs and a down day for shorts. We compare this to reverse daily
    follow through (long 1 down day, short 1 up day). As you will notice, the runs
    oscillator is far more consistent across time and has higher risk-adjusted returns.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到了适应性时间机器续集中的“运行振荡器”。这是我们将在创建改进的时间机器算法时关注的内容。“运行振荡器”是通过比较当前的下跌运行（如果那是当前的运行）与前252天内的所有下跌运行来构建的。对于上涨运行也是同样的操作。这留下了两个范围从0到1的振荡器，分别对应上涨和下跌运行。运行振荡器通过将下跌运行振荡器乘以-100，上涨运行振荡器乘以100，然后将它们相加融合在一起。最终的振荡器范围在-100到100之间，其中100表示最严重的超买情况，而-100则表示最严重的超卖情况。在下面的示例中，我们使用中值超买和超卖情况来进行逆趋势入场（long<-50
    和 short>50），并在零交叉时退出。本质上，我们正在等待一个中值下跌运行来进行多头操作，和一个中值上涨运行来进行空头操作，同时寻找多头在上涨日退出，空头在下跌日退出的机会。我们将此与反向每日跟随策略（long
    1 下跌日，short 1 上涨日）进行比较。正如你所注意到的，运行振荡器在时间上要一致得多，并且具有更高的风险调整回报。
- en: '[![](img/a690ec5202c3fe392a7728aef14c7a51.png "RunsOscillator")](https://cssanalytics.files.wordpress.com/2010/07/runsoscillator.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/a690ec5202c3fe392a7728aef14c7a51.png "RunsOscillator")](https://cssanalytics.files.wordpress.com/2010/07/runsoscillator.png)'
