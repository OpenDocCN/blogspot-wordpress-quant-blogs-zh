["```\n #include <iostream> \n#include <cstdlib>\n#define BOOST_AUTO_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n#include <boost/detail/lightweight_test.hpp>\n#include <ql/quantlib.hpp>\n#include <boost/format.hpp>\n#include <functional>\n#include <numeric>\n#include <fstream>\n\nnamespace {\n\nusing namespace QuantLib;\n\n//aggregates all constraint expressions into a single constraint\nclass PortfolioAllocationConstraints : public Constraint {\n\npublic:\n\nPortfolioAllocationConstraints(const std::vector& expressions)  : Constraint(boost::shared_ptr(new\n    PortfolioAllocationConstraints::Impl(expressions))) {}\n\nprivate:\n// constraint implementation\nclass Impl : public Constraint::Impl {\npublic:\n\nImpl(const std::vector& expressions) :\n    expressions_(expressions) {}\n\nbool test(const Array& x) const {\n    for (auto iter = expressions_.begin(); \n    iter < expressions_.end(); ++iter) {\n        if (!(*iter)(x)) {\n            return false;\n        }\n    }\n    //will only get here if all constraints satisfied\n    return true;\n}\n\nprivate:\n\nconst std::vector expressions_;        \n};\n}; \n\nclass ThetaCostFunction: public CostFunction {\n\n    public:\n\tThetaCostFunction(const Matrix& covarianceMatrix, \n\t    const Matrix& returnMatrix) : covarianceMatrix_(covarianceMatrix),\n\t    returnMatrix_(returnMatrix) {\n\t}\n\n    \tReal value(const Array& proportions) const {\n    \t    QL_REQUIRE(proportions.size()==3, \"Four assets in portfolio!\");\n            Array allProportions(4);\n            allProportions[0] = proportions[0];\n            allProportions[1] = proportions[1];\n            allProportions[2] = proportions[2];\n            allProportions[3] = 1 - (proportions[0] + proportions[1] + proportions[2]);\n\t    return -1 * ((portfolioMean(allProportions) - c_)/portfolioStdDeviation(allProportions));\t\n       \t}\n\n\tDisposable values(const Array& proportions) const {\n            QL_REQUIRE(proportions.size()==3, \"Four assets in portfolio!\");\n            Array values(1);\n            values[0] = value(proportions);\n            return values;\n       \t}\n\n       \tvoid setC(Real c) { c_ = c; }\n       \tReal getC() const { return c_;}\n        Real portfolioMean(const Array& proportions) const {\n\t    Real portfolioMean = (proportions * returnMatrix_)[0];\n            //std::cout << boost::format(\"Portfolio mean: %.4f\") % portfolioMean << std::endl;\n            return portfolioMean;\n\t}\n\n\tReal portfolioStdDeviation(const Array& proportions) const {\n            Matrix matrixProportions(4,1);\n\t    for (size_t row = 0; row < 4; ++row) {\n\t        matrixProportions[row][0] = proportions[row];\n\t    }\n\n\t    const Matrix& portfolioVarianceMatrix = transpose(matrixProportions) * covarianceMatrix_ * matrixProportions;\n\t    Real portfolioVariance = portfolioVarianceMatrix[0][0];\n\t    Real stdDeviation = std::sqrt(portfolioVariance);\n            //std::cout << boost::format(\"Portfolio standard deviation: %.4f\") % stdDeviation << std::endl;\n            return stdDeviation;\n\t}\n\n\tprivate:\t\n        const Matrix& covarianceMatrix_;\n\tconst Matrix& returnMatrix_;\n\tReal c_;\n    };\n\n    BOOST_AUTO_TEST_CASE(testNoShortSales) {\n\n        Matrix covarianceMatrix(4,4);\n\n        //row 1\n        covarianceMatrix[0][0] = .1; //AAPL-AAPL\n        covarianceMatrix[0][1] = .03; //AAPL-IBM\n        covarianceMatrix[0][2] = -.08; //AAPL-ORCL\n        covarianceMatrix[0][3] = .05; //AAPL-GOOG\n        //row 2\n        covarianceMatrix[1][0] = .03; //IBM-AAPL\n        covarianceMatrix[1][1] = .20; //IBM-IBM \n        covarianceMatrix[1][2] = .02; //IBM-ORCL\n        covarianceMatrix[1][3] = .03; //IBM-GOOG\n\t//row 3\n        covarianceMatrix[2][0] = -.08; //ORCL-AAPL \n        covarianceMatrix[2][1] = .02; //ORCL-IBM\n        covarianceMatrix[2][2] = .30; //ORCL-ORCL\n        covarianceMatrix[2][3] = .2; //ORCL-GOOG\n       \t//row 4\n        covarianceMatrix[3][0] = .05; //GOOG-AAPL\n        covarianceMatrix[3][1] = .03; //GOOG-IBM\n        covarianceMatrix[3][2] = .2; //GOOG-ORCL\n        covarianceMatrix[3][3] = .9; //GOOG-GOOG\n\n        std::cout << \"Covariance matrix of returns: \" << std::endl;\n        std::cout << covarianceMatrix << std::endl;\n\n       \t//portfolio return vector         \n\tMatrix portfolioReturnVector(4,1);\n        portfolioReturnVector[0][0] = .08; //AAPL\n        portfolioReturnVector[1][0] = .09; //IBM\n        portfolioReturnVector[2][0] = .10; //ORCL\n        portfolioReturnVector[3][0] = .11; //GOOG\n\n        std::cout << \"Portfolio return vector\" << std::endl;\n        std::cout << portfolioReturnVector << std::endl;\n\n        //constraints\n\tstd::vector<std::function >  noShortSalesConstraints(2);\n\n        //constraints implemented as C++ 11 lambda expressions\n        noShortSalesConstraints[0] = [] (const Array& x) {Real x4 = 1.0 - ( x[0] + x[1] + x[2]);  return (x[0] >= 0.0 && x[1] >= 0.0 && x[2] >= 0.0 && x4 >= 0.0);}; \n        noShortSalesConstraints[1] = [] (const Array& x) { Real x4 = 1.0 - ( x[0] + x[1] + x[2]); return 1.0 - (x[0] + x[1] + x[2] + x4) < 1e-9;};\n\n\t//instantiate constraints\n\tPortfolioAllocationConstraints noShortSalesPortfolioConstraints(noShortSalesConstraints);\n\n\tSize maxIterations = 100000;\n\tSize minStatIterations = 100;\n\tReal rootEpsilon = 1e-9;\n\tReal functionEpsilon = 1e-9;\n\tReal gradientNormEpsilon = 1e-9;\n\tEndCriteria endCriteria (maxIterations, minStatIterations, \n\t\trootEpsilon, functionEpsilon, gradientNormEpsilon);\t\n\n        std::map<Rate, std::pair > mapOfStdDeviationToMeanNoShortSales;\n\n\tRate startingC = -.035;\n\tReal increment = .005;\n\n        for (int i = 0; i < 40; ++i) {\n            Rate c = startingC + (i * increment);  \n            ThetaCostFunction thetaCostFunction(covarianceMatrix, portfolioReturnVector);\n\t    thetaCostFunction.setC(c);\n            Problem efficientFrontierNoShortSalesProblem(thetaCostFunction, noShortSalesPortfolioConstraints, Array(3, .2500));\n\t    Simplex solver(.01);\n            EndCriteria::Type noShortSalesSolution = solver.minimize(efficientFrontierNoShortSalesProblem, endCriteria);\n            std::cout << boost::format(\"Solution type: %s\") % noShortSalesSolution << std::endl;\n\n    \t    const Array& results = efficientFrontierNoShortSalesProblem.currentValue();\n            Array proportions(4);\n            proportions[0] = results[0];\n            proportions[1] = results[1];\n            proportions[2] = results[2];\n            proportions[3] = 1.0 - (results[0] + results[1] + results[2]);\n            std::cout << boost::format(\"Constant (c): %.4f\") % thetaCostFunction.getC() << std::endl;\n\t    std::cout << boost::format(\"AAPL weighting: %.4f\") % proportions[0] << std::endl;  \n\t    std::cout << boost::format(\"IBM weighting: %.4f\") % proportions[1] << std::endl;  \n\t    std::cout << boost::format(\"ORCL weighting: %.4f\") % proportions[2] << std::endl;  \n\t    std::cout << boost::format(\"GOOG weighting: %.4f\") % proportions[3] << std::endl;\n\t    std::cout << boost::format(\"Theta: %.4f\") % (-1 * efficientFrontierNoShortSalesProblem.functionValue()) << std::endl;\n            Real portfolioMean = thetaCostFunction.portfolioMean(proportions); \n            std::cout << boost::format(\"Portfolio mean: %.4f\") % portfolioMean << std::endl;\n            Volatility portfolioStdDeviation = thetaCostFunction.portfolioStdDeviation(proportions); \n            std::cout << boost::format(\"Portfolio standard deviation: %.4f\") % portfolioStdDeviation << std::endl;\n            mapOfStdDeviationToMeanNoShortSales[c] = std::make_pair(portfolioStdDeviation, portfolioMean); \n            std::cout << \"------------------------------------\" << std::endl;\n        }\n\n        //write efficient frontier with no short sales to file\n\tstd::ofstream noShortSalesFile;\n\tnoShortSalesFile.open(\"/tmp/noshortsales.dat\", std::ios::out);\n\tfor (std::map<Rate, std::pair >::const_iterator i=mapOfStdDeviationToMeanNoShortSales.begin(); i != mapOfStdDeviationToMeanNoShortSales.end(); ++i) {\n\t    noShortSalesFile <first % i->second.first % i->second.second << std::endl;\n\t}\n\tnoShortSalesFile.close();\n\n\t//plot with gnuplot using commands below Run 'gnuplot' then type in: \n\t/*\n         set terminal png\n         set output \"/tmp/noshortsales.png\"\n         set key top left\n\t set key box\n\t set xlabel \"Volatility\"\n\t set ylabel \"Expected Return\"\n\t plot '/tmp/noshortsales.dat' using 2:3 w linespoints title \"No Short Sales\"\n\t*/\n    }\n} \n```"]