["```\n #include <iostream> \n#include <cstdlib&gt\n#define BOOST_AUTO_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n#include <boost/detail/lightweight_test.hpp>\n#include <ql/quantlib.hpp>\n#include <boost/format.hpp>\n#include <functional>\n#include <numeric>\n#include <fstream>\n\nnamespace {\nusing namespace QuantLib;\ndouble calculatePortfolioReturn(double proportionA, double expectedReturnA, double expectedReturnB) {\n\treturn proportionA * expectedReturnA + (1-proportionA) * expectedReturnB;\n}\n\nVolatility calculatePortfolioRisk(double proportionA, Volatility volatilityA, Volatility volatilityB, double covarianceAB) {\n\treturn std::sqrt(std::pow(proportionA,2) * std::pow(volatilityA,2) + std::pow(1-proportionA,2) * \n\tstd::pow(volatilityB,2) + (2 * proportionA * (1-proportionA) * covarianceAB)); \t\n}\n\nBOOST_AUTO_TEST_CASE(testEfficientFrontier) {\n\nMatrix covarianceMatrix(4,4);\n\n//row 1\ncovarianceMatrix[0][0] = .40; //AAPL-AAPL\ncovarianceMatrix[0][1] = .05; //AAPL-IBM\ncovarianceMatrix[0][2] = .02; //AAPL-ORCL\ncovarianceMatrix[0][3] = .04; //AAPL-GOOG\n//row 2\ncovarianceMatrix[1][0] = .05; //IBM-AAPL\ncovarianceMatrix[1][1] = .20; //IBM-IBM \ncovarianceMatrix[1][2] = .01; //IBM-ORCL\ncovarianceMatrix[1][3] = -.06; //IBM-GOOG\n//row 3\ncovarianceMatrix[2][0] = .02; //ORCL-AAPL \ncovarianceMatrix[2][1] = .01; //ORCL-IBM\ncovarianceMatrix[2][2] = .30; //ORCL-ORCL\ncovarianceMatrix[2][3] = .03; //ORCL-GOOG\n//row 4\ncovarianceMatrix[3][0] = .04; //GOOG-AAPL\ncovarianceMatrix[3][1] = -.06; //GOOG-IBM\ncovarianceMatrix[3][2] = .03; //GOOG-ORCL\ncovarianceMatrix[3][3] = .15; //GOOG-GOOG\n\nstd::cout << \"Covariance matrix of returns: \" << std::endl;\nstd::cout << covarianceMatrix << std::endl;\n\n//portfolio return vector         \nMatrix portfolioReturnVector(4,1);\nportfolioReturnVector[0][0] = .10; //AAPL\nportfolioReturnVector[1][0] = .03; //IBM\nportfolioReturnVector[2][0] = .07; //ORCL\nportfolioReturnVector[3][0] = .08; //GOOG\n\nstd::cout << \"Portfolio return vector\" << std::endl;\nstd::cout << portfolioReturnVector << std::endl;\n\n//constant \nRate c = .05;\n\n//portfolio return vector minus constant rate\nMatrix portfolioReturnVectorMinusC(4,1);\nfor (int i=0; i<4; ++i) {\n    \tportfolioReturnVectorMinusC[i][0] = portfolioReturnVector[i][0] - c;\n}\n\nstd::cout << boost::format(\"Portfolio return vector minus constantrate (c = %f)\") % c << std::endl;\nstd::cout << portfolioReturnVectorMinusC << std::endl;\n\n//inverse of covariance matrix\nconst Matrix& inverseOfCovarMatrix = inverse(covarianceMatrix);\n\n//z vectors\nconst Matrix& portfolioAz = inverseOfCovarMatrix * portfolioReturnVector;\nstd::cout << \"Portfolio A z vector\" << std::endl;\nstd::cout << portfolioAz << std::endl;\ndouble sumOfPortfolioAz = 0.0;\nstd::for_each(portfolioAz.begin(), portfolioAz.end(), [&](Real n) {\n\tsumOfPortfolioAz += n;\t\n});\n\nconst Matrix& portfolioBz = inverseOfCovarMatrix * portfolioReturnVectorMinusC;\nstd::cout << \"Portfolio B z vector\" << std::endl;\nstd::cout << portfolioBz << std::endl;\ndouble sumOfPortfolioBz = 0.0;\nstd::for_each(portfolioBz.begin(), portfolioBz.end(), [&](Real n) {\n\tsumOfPortfolioBz += n;\t\n});\n\n//portfolio weights\nMatrix weightsPortfolioA(4,1);\nfor (int i=0; i<4; ++i) {\n\tweightsPortfolioA[i][0] = portfolioAz[i][0]/sumOfPortfolioAz;\n}\t\t\n\nstd::cout << \"Portfolio A weights\" << std::endl;\nstd::cout << weightsPortfolioA << std::endl;\n\nMatrix weightsPortfolioB(4,1);\nfor (int i=0; i<4; ++i) {\n\tweightsPortfolioB[i][0] = portfolioBz[i][0]/sumOfPortfolioBz;\n}\t\t\n\nstd::cout << \"Portfolio B weights\" << std::endl;\nstd::cout << weightsPortfolioB << std::endl;\n\n//portfolio risk and return\nconst Matrix& expectedReturnPortfolioAMatrix = transpose(weightsPortfolioA) * portfolioReturnVector;\t\ndouble expectedReturnPortfolioA = expectedReturnPortfolioAMatrix[0][0];\nconst Matrix& variancePortfolioAMatrix =  transpose(weightsPortfolioA) * covarianceMatrix * weightsPortfolioA;\ndouble variancePortfolioA = variancePortfolioAMatrix[0][0];\ndouble stdDeviationPortfolioA = std::sqrt(variancePortfolioA);\nstd::cout << boost::format(\"Portfolio A expected return: %f\") % expectedReturnPortfolioA << std::endl;\nstd::cout << boost::format(\"Portfolio A variance: %f\") % variancePortfolioA << std::endl;\nstd::cout << boost::format(\"Portfolio A standard deviation: %f\") % stdDeviationPortfolioA << std::endl;\n\nconst Matrix& expectedReturnPortfolioBMatrix = transpose(weightsPortfolioB) * portfolioReturnVector;\t\ndouble expectedReturnPortfolioB = expectedReturnPortfolioBMatrix[0][0];\nconst Matrix& variancePortfolioBMatrix =  transpose(weightsPortfolioB) * covarianceMatrix * weightsPortfolioB;\ndouble variancePortfolioB = variancePortfolioBMatrix[0][0];\ndouble stdDeviationPortfolioB = std::sqrt(variancePortfolioB);\nstd::cout << boost::format(\"Portfolio B expected return: %f\") % expectedReturnPortfolioB << std::endl;\nstd::cout << boost::format(\"Portfolio B variance: %f\") % variancePortfolioB << std::endl;\nstd::cout << boost::format(\"Portfolio B standard deviation: %f\") % stdDeviationPortfolioB << std::endl;\n\n//covariance and correlation of returns\nconst Matrix& covarianceABMatrix = transpose(weightsPortfolioA) * covarianceMatrix * weightsPortfolioB;\ndouble covarianceAB = covarianceABMatrix[0][0];\ndouble correlationAB = covarianceAB/(stdDeviationPortfolioA * stdDeviationPortfolioB);\nstd::cout << boost::format(\"Covariance of portfolio A and B: %f\") % covarianceAB << std::endl;\nstd::cout << boost::format(\"Correlation of portfolio A and B: %f\") % correlationAB << std::endl;\n\n//generate envelope set of portfolios\ndouble startingProportion = -.40;\ndouble increment = .10;\nstd::map<double, std::pair<Volatility,double> > mapOfProportionToRiskAndReturn;\nstd::map<Volatility, double> mapOfVolatilityToReturn;\nfor (int i=0; i<21; ++i) {\n\tdouble proportionA = startingProportion + i*increment;\n\tVolatility riskEF = calculatePortfolioRisk(proportionA, stdDeviationPortfolioA, stdDeviationPortfolioB, covarianceAB);\n\tdouble returnEF = calculatePortfolioReturn(proportionA, expectedReturnPortfolioA, expectedReturnPortfolioB);\n\tmapOfProportionToRiskAndReturn[proportionA] = std::make_pair(riskEF, returnEF);\n\tmapOfVolatilityToReturn[riskEF] = returnEF;\n}\n\n//write data to a file\nstd::ofstream envelopeSetFile;\nenvelopeSetFile.open(\"/tmp/envelope.dat\",std::ios::out);\nfor (std::map<double, std::pair<Volatility,double> >::const_iterator i=mapOfProportionToRiskAndReturn.begin(); i != mapOfProportionToRiskAndReturn.end(); ++i) {\n\tenvelopeSetFile << boost::format(\"%f %f %f\") % i->first % i->second.first % i->second.second << std::endl;\n}\nenvelopeSetFile.close();\n\n//find minimum risk portfolio on efficient frontier\nstd::pair<Volatility,double> minimumVariancePortolioRiskAndReturn = *mapOfVolatilityToReturn.begin(); \nVolatility minimumRisk = minimumVariancePortolioRiskAndReturn.first; \ndouble maximumReturn = minimumVariancePortolioRiskAndReturn.second;\nstd::cout << boost::format(\"Maximum portfolio return for risk of %f is %f\") % minimumRisk % maximumReturn << std::endl;\n\n//generate efficient frontier\nstd::map<Volatility, double> efficientFrontier;\nfor (std::map<double, std::pair<Volatility,double> >::const_iterator i=mapOfProportionToRiskAndReturn.begin(); i != mapOfProportionToRiskAndReturn.end(); ++i) {\n\tefficientFrontier[i->second.first] = i->second.second;\n\tif (i->second.first == minimumRisk) break;\n}\n\n//write efficient frontier to file\nstd::ofstream efFile;\nefFile.open(\"/tmp/ef.dat\", std::ios::out);\nfor (std::map<Volatility, double>::const_iterator i=efficientFrontier.begin(); i != efficientFrontier.end(); ++i) {\n\tefFile << boost::format(\"%f %f\") % i->first % i->second << std::endl;\n}\nefFile.close();\n\n//plot with gnuplot using commands below. Run 'gnuplot' then type in: \n/*\nset key top left\nset key box\nset xlabel \"Volatility\"\nset ylabel \"Expected Return\"\nplot '/tmp/envelope.dat' using 2:3 with linespoints title \"Envelope\", '/tmp/ef.dat' using 1:2  w points pointtype 5 t \"Efficient Frontier\"\n*/\n\n}\n\n}\n```"]