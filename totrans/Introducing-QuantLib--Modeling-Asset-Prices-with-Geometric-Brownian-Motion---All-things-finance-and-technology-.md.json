["```\n #include <ql/quantlib.hpp>\n\nusing namespace QuantLib;\n\nBOOST_AUTO_TEST_CASE(testGeometricBrownianMotion) {\n\n    Real startingPrice = 20.16; //closing price for INTC on 12/7/2012\n    Real mu = .2312; //INTC one year historical annual return\n    Volatility sigma = 0.2116; //INTC one year historical volatility\n    Size timeSteps = 255; //trading days in a year (U.S.)\n    Time length = 1; //one year\n\n    //instantiate Geometric Brownian Motion (GBM) stochastic process\n    const boost::shared_ptr<StochasticProcess>& gbm =\n        boost::shared_ptr<StochasticProcess> (new GeometricBrownianMotionProcess(startingPrice, \n        mu, sigma));\n\n    //generate a sequence of normally distributed random numbers from a\n    //uniform distribution using Box-Muller transformation\n    BigInteger seed = SeedGenerator::instance().get();\n    typedef BoxMullerGaussianRng MersenneBoxMuller;\n    MersenneTwisterUniformRng mersenneRng(seed);\n    MersenneBoxMuller boxMullerRng(mersenneRng);\n    RandomSequenceGenerator<MersenneBoxMuller> gsg(timeSteps, boxMullerRng);\n\n    //generate simulated path of stock price using GBM stochastic process\n    PathGenerator<RandomSequenceGenerator<MersenneBoxMuller> > gbmPathGenerator(gbm, length, \n        timeSteps, gsg, false);\n    const Path& samplePath = gbmPathGenerator.next().value;\n\n    //calculate simulated sample returns using C++11 lambda expression\n    boost::function<Real, (Real, Real)> calcLogReturns = [](Real x, Real y) {return std::log(y/x);};\n    std::vector<Real> logReturns;\n    Path::iterator samplePathBegin = samplePath.begin();\n    Path::iterator samplePathEnd = samplePath.end();\n    Path::iterator endMinusOne = std::prev(samplePathEnd);\n    Path::iterator beginPlusOne = std::next(samplePathBegin);\n\n    std::transform(samplePathBegin, endMinusOne, beginPlusOne,\n         std::back_inserter(logReturns), calcLogReturns);\t\t\n\n    //calculate some general statistics\n    GeneralStatistics statistics;\n\n    //returns statistics\n    statistics.addSequence(logReturns.begin(), logReturns.end());\n    std::cout << boost::format(\"Standard deviation of simulated returns (Normal): \n         %.4f\") % (statistics.standardDeviation() * std::sqrt(255)) << std::endl;\n\n    //price statistics\n    statistics.reset();\n    statistics.addSequence(samplePath.begin(), samplePath.end());\n    std::cout << boost::format(\"Price statistics: mean=%.2f, min=%.2f, max=%.2f\") %\n         statistics.mean() % statistics.min() % statistics.max() << std::endl;  \n\n    //write simulated path to a file for charting with gnuplot\n    std::ofstream gbmFile;\n    gbmFile.open(\"/tmp/gbm.dat\", \n        std::ios::out);\n    for (Size i = 0; i < timeSteps; ++i) {\n        gbmFile << boost::format(\"%d %.4f\") % i % samplePath.at(i) << std::endl;\n    }\n\n    gbmFile.close();\n\n    /* gnuplot script to chart stock price path\n    set key bottom center\n    set key bottom box\n    set xlabel \"Time Step (Days)\"\n    set ylabel \"Stock Price\"\n    plot \"/tmp/gbm.dat\" using 1:2 w lines t \"INTC simulated stock price\"\n    */\n}\n} \n```", "```\n #include <ql/quantlib.hpp>\n#include <boost/math/distributions/students_t.hpp>\n\nReal studentTInverse(boost::math::students_t_distribution d, const Real& p) {\n    return quantile(d,p)\n}\n\nusing namespace QuantLib;\n\nBOOST_AUTO_TEST_CASE(testGeometricBrownianMotionStudentT) {\n\n    Real startingPrice = 20.16; //closing price for INTC on 12/7/2012\n    Real mu = .2312; //INTC one year historical annual return\n    Volatility sigma = 0.2116; //INTC one year historical volatility\n    Volatility scaledSigma = std::sqrt(sigma * sigma * 3/5); //scaled by reciprocal of Student T variance (v/(v-2))\n    Size timeSteps = 255; //trading days in a year (U.S.)\n    Time length = 1; //one year\n\n    //instantiate Geometric Brownian Motion (GBM) stochastic process\n    const boost::shared_ptr<StochasticProcess>& gbm =\n        boost::shared_ptr<StochasticProcess> (new GeometricBrownianMotionProcess(startingPrice, \n        mu, scaledSigma));\n\n    //random sequence generator uses Mersenne Twiseter to generate uniformly distributed\n    //pseudo-random numbers\n    BigInteger seed = SeedGenerator::instance().get();\n    MersenneTwisterUniformRng mersenneRng(seed);\n    RandomSequenceGenerator<MersenneTwisterUniformRng> rsg(timeSteps, mersenneRng);\n\n    //instantiate Student T distribution from Boost math library\n    boost::math::students_t_distribution<> studentT(5); //5 degrees of freedom - want fat tails!\n    boost::function<Real (Real)> icd = boost::bind(studentTInverse, studentT, _1); \n\n    //sample random numbers from the Student T distribution\t\t\n    InverseCumulativeRsg<RandomSequenceGenerator<MersenneTwisterUniformRng>, \n        boost::function<Real (Real)> > invCumRsg(rsg, icd);\n\n    //generates a single path\n    PathGenerator<InverseCumulativeRsg<RandomSequenceGenerator<MersenneTwisterUniformRng>, \n        boost::function<Real (Real)> > > gbmPathGenerator(gbm, length, timeSteps, invCumRsg, false);\n    const Path& samplePath = gbmPathGenerator.next().value;\n\n    //calculate simulated sample returns using C++11 lambda expression\n    boost::function<Real, (Real, Real)> calcLogReturns = [](Real x, Real y) {return std::log(y/x);};\n    std::vector<Real> logReturns;\n    Path::iterator samplePathBegin = samplePath.begin();\n    Path::iterator samplePathEnd = samplePath.end();\n    Path::iterator endMinusOne = std::prev(samplePathEnd);\n    Path::iterator beginPlusOne = std::next(samplePathBegin);\n\n    std::transform(samplePathBegin, endMinusOne, beginPlusOne,\n         std::back_inserter(logReturns), calcLogReturns);\t\t\n\n    //calculate some general statistics\n    GeneralStatistics statistics;\n\n    //returns statistics\n    statistics.addSequence(logReturns.begin(), logReturns.end());\n    std::cout << boost::format(\"Standard deviation of simulated returns (Student-T): \n         %.4f\") % (statistics.standardDeviation() * std::sqrt(255)) << std::endl;\n\n    //price statistics\n    statistics.reset();\n    statistics.addSequence(samplePath.begin(), samplePath.end());\n    std::cout << boost::format(\"Price statistics: mean=%.2f, min=%.2f, max=%.2f\") %\n         statistics.mean() % statistics.min() % statistics.max() << std::endl;  \n\n    //write simulated path to a file for charting with gnuplot\n    std::ofstream gbmFile;\n    gbmFile.open(\"/tmp/gbm-student.dat\", \n        std::ios::out);\n    for (Size i = 0; i < timeSteps; ++i) {\n        gbmFile << boost::format(\"%d %.4f\") % i % samplePath.at(i) << std::endl;\n    }\n\n    gbmFile.close();\n\n    /* gnuplot script to chart stock price path\n   set key bottom center\n   set key bottom box\n   set xlabel \"Time Step (Days)\"\n   set ylabel \"Stock Price\"\n   plot \"/tmp/gbm.dat\" using 1:2 w lines \n   t \"INTC Normal\", \"/tmp/gbm-student.dat\" using 1:2 w lines t \"INTC Student-T\"\n   */\n}\n} \n```"]