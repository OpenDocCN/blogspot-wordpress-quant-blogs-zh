- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-18 06:45:20'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Introducing QuantLib: Internal Rate of Return | All things finance and technology…'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://mhittesdorf.wordpress.com/2013/03/03/introducing-quantlib-internal-rate-of-return/#0001-01-01](https://mhittesdorf.wordpress.com/2013/03/03/introducing-quantlib-internal-rate-of-return/#0001-01-01)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Welcome back!  In my previous post, we learned about the term structure of interest
    rates in the context of bond pricing. Given the term structure, we saw how to
    calculate the price of a fixed-rate bond by calculating the net present value
    (NPV) of the bond’s future cash flows,  consisting of its annual coupon payments
    plus the final premium repayment.  The bond’s price, if you recall, was calculated
    using a constant interest rate, which, as stated in my previous post, is equivalent
    to a flat interest rate term structure.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s assume that we know the price of a bond or, more generally, the present
    value of a sequence of future cash flows and we would like to know what interest
    rate was used to arrive at the NPV. This rate of return is commonly referred to
    as the investment’s ‘internal rate of return’ (IRR) or, when applied to a bond,
    the bond’s ‘yield to maturity’ (YTM).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the cash flows from the bond example we’ve been considering thus
    far. The bond has a face value of 100, pays annual coupons of 5% and has a price
    (NPV) of 105.66\. The bond’s cash flows, in order are, 5.0, 5.0 and 105.0\. Therefore,
    to compute the yield to maturity of the bond, we need to solve for the interest
    rate, r, in the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**105.66 = 5/(1+r) + 5/(1+r)^2 + 105/(1+r)^3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that there is no analytical, algebraic method to determine the
    value of r.  As such, the equation must be solved numerically, using a solver
    method.   In the example code that follows, I use the [Bisection](http://quantlib.org/reference/class_quant_lib_1_1_bisection.html)
    class, one of several solver classes supported by QuantLib to back out the  bond’s
    yield to maturity.  Other solvers available in QuantLib include: [Brent](http://quantlib.org/reference/class_quant_lib_1_1_bisection.html),
    [Secant](http://quantlib.org/reference/class_quant_lib_1_1_secant.html), [Ridder](http://quantlib.org/reference/class_quant_lib_1_1_ridder.html),
    [Newton](http://quantlib.org/reference/class_quant_lib_1_1_ridder.html) and [FalsePosition](http://quantlib.org/reference/class_quant_lib_1_1_false_position.html).
     Each one of these solver classes will find the zero, or root, of a function by
    varying a single input to the function.  The solver will terminate its search
    when the return value of the function is less than or equal to the *accuracy*
    parameter, which is defined to be .000001 in the code below.'
  prefs: []
  type: TYPE_NORMAL
- en: The function passed to the Bisection solver in this example takes two forms.
    The first is a *functor* class, which is a class with operator() overridden. The
    second is a lambda expression, which is a type of [closure](http://en.wikipedia.org/wiki/Closure_(computer_science)) introduced
    in the latest C++ standard, [C++ 11](http://en.wikipedia.org/wiki/C%2B%2B11).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to calculate the bond’s yield to maturity is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <cstdlib>'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: '#define BOOST_AUTO_TEST_MAIN'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <boost/test/unit_test.hpp>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <boost/detail/lightweight_test.hpp>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <ql/quantlib.hpp>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <vector>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <ql/instruments/bonds/fixedratebond.hpp>'
  prefs: []
  type: TYPE_NORMAL
- en: namespace {
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: using namespace QuantLib;class IRRSolver {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: 'explicit IRRSolver(const Leg& cashFlows, Real npv): _cashFlows(cashFlows),_npv(npv){};'
  prefs: []
  type: TYPE_NORMAL
- en: Real operator() (const Rate& rate) const {
  prefs: []
  type: TYPE_NORMAL
- en: InterestRate interestRate(rate, ActualActual(ActualActual::Bond), Compounded,
    Annual);
  prefs: []
  type: TYPE_NORMAL
- en: return CashFlows::npv(_cashFlows, interestRate, false) – _npv;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'private:'
  prefs: []
  type: TYPE_NORMAL
- en: const Real _npv;
  prefs: []
  type: TYPE_NORMAL
- en: const Leg& _cashFlows;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: BOOST_AUTO_TEST_CASE(testCalculateBondYieldToMaturity) {
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Calendar calendar = UnitedStates(UnitedStates::GovernmentBond);
  prefs: []
  type: TYPE_NORMAL
- en: const Natural settlementDays = 3;
  prefs: []
  type: TYPE_NORMAL
- en: Date today = Date::todaysDate();
  prefs: []
  type: TYPE_NORMAL
- en: Date issueDate = today;
  prefs: []
  type: TYPE_NORMAL
- en: Date terminationDate = issueDate + Period(3, Years);
  prefs: []
  type: TYPE_NORMAL
- en: Rate rate = .03;
  prefs: []
  type: TYPE_NORMAL
- en: InterestRate couponRate(.05, ActualActual(ActualActual::Bond), Compounded, Annual);
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Real faceValue = 100.0;
  prefs: []
  type: TYPE_NORMAL
- en: std::vector<Rate> coupons(3, couponRate);
  prefs: []
  type: TYPE_NORMAL
- en: Schedule schedule(issueDate, terminationDate, Period(Annual), calendar,
  prefs: []
  type: TYPE_NORMAL
- en: Unadjusted, Unadjusted, DateGeneration::Backward, false);
  prefs: []
  type: TYPE_NORMAL
- en: FixedRateBond fixedRateBond(settlementDays, faceValue, schedule, coupons);
  prefs: []
  type: TYPE_NORMAL
- en: boost::shared_ptr<YieldTermStructure> flatForwardRates(new FlatForward(issueDate,
    rate, ActualActual(ActualActual::Bond), Compounded, Annual));
  prefs: []
  type: TYPE_NORMAL
- en: Handle<YieldTermStructure> flatTermStructure(flatForwardRates);
  prefs: []
  type: TYPE_NORMAL
- en: boost::shared_ptr<PricingEngine> bondEngine(new DiscountingBondEngine(flatTermStructure));
  prefs: []
  type: TYPE_NORMAL
- en: fixedRateBond.setPricingEngine(bondEngine);
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Real npv = fixedRateBond.NPV();
  prefs: []
  type: TYPE_NORMAL
- en: 'std::cout << “NPV of bond is: ” << npv << std::endl;'
  prefs: []
  type: TYPE_NORMAL
- en: //solve for yield to maturity using bisection solver
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bisection bisection;
  prefs: []
  type: TYPE_NORMAL
- en: Real accuracy=0.000001, guess=.10;
  prefs: []
  type: TYPE_NORMAL
- en: Real min=.0025, max=.15;
  prefs: []
  type: TYPE_NORMAL
- en: //invoke bisection solver with IRRSolver functor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Real irr = bisection.solve(IRRSolver(fixedRateBond.cashflows(), npv),
  prefs: []
  type: TYPE_NORMAL
- en: accuracy, guess, min, max);
  prefs: []
  type: TYPE_NORMAL
- en: 'std::cout << “Bond yield to maturity (IRR) is: ” << irr << std::endl;'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: //invoke bisection solver with C++ 11 lambda expression
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: irr = bisection.solve([&] (const Rate& rate){ return CashFlows::npv(fixedRateBond.cashflows(),
    InterestRate(rate, ActualActual(ActualActual::Bond), Compounded, Annual), false)
    – npv;},
  prefs: []
  type: TYPE_NORMAL
- en: accuracy, guess, min, max);
  prefs: []
  type: TYPE_NORMAL
- en: 'std::cout << “Bond yield to maturity (IRR) is: ” << irr << std::endl;'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this code when run is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NPV of bond is: 105.657'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bond yield to maturity (IRR) is: 0.0300004'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bond yield to maturity (IRR) is: 0.0300004`'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see both IRR solver methods produce the same result, 3%, which is
    indeed the interest rate of the bond.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this post. Please feel free to leave comments or questions
    that you might have. In the next installment of this series, I’ll examine how
    to calculate the sensitivity of a bond’s price to a change in the level of interest
    rates. Until then, have fun with QuantLib!
  prefs: []
  type: TYPE_NORMAL
- en: About Mick Hittesdorf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I'm a versatile technical leader with a passion for data analytics, data science
    and Big Data technology. I have experience working for both large and small organizations,
    in a variety of roles. I've been responsible for the management and operations
    of a global data science and analytics platform, developed low latency, proprietary
    trading systems, managed software development teams, defined enterprise architecture
    strategies, written white papers and blogs, published articles in industry journals
    and delivered innovative solutions to clients, both in a consulting and technical
    sales capacity. My current areas of focus include Big Data, data engineering,
    data science, R, and Cloud computing
  prefs: []
  type: TYPE_NORMAL
