- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-18 06:47:11'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Introducing QuantLib: Interest Rate Conversions | All things finance and technology…'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://mhittesdorf.wordpress.com/2013/02/24/introducing-quantlib-interest-rate-conversions/#0001-01-01](https://mhittesdorf.wordpress.com/2013/02/24/introducing-quantlib-interest-rate-conversions/#0001-01-01)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For those of you who read the last installment of my series on QuantLib, you
    are now familiar with QuantLib’s [InterestRate](http://quantlib.org/reference/class_quant_lib_1_1_interest_rate.html)
    class. In this post, I’ll provide an example of  how to compare interest rates
    that have different compounding periods and/or payment frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: BOOST_AUTO_TEST_CASE(testInterestRateConversions) {
  prefs: []
  type: TYPE_NORMAL
- en: //annual/effective rate
  prefs: []
  type: TYPE_NORMAL
- en: Rate annualRate = .05;
  prefs: []
  type: TYPE_NORMAL
- en: //5% rate compounded annually
  prefs: []
  type: TYPE_NORMAL
- en: InterestRate effectiveRate(annualRate, ActualActual(), Compounded, Annual);
  prefs: []
  type: TYPE_NORMAL
- en: 'std::cout << “Rate with annual compounding is: ” << effectiveRate.rate() <<
    std::endl;'
  prefs: []
  type: TYPE_NORMAL
- en: //what is the equivalent semi-annual one year rate?
  prefs: []
  type: TYPE_NORMAL
- en: InterestRate semiAnnualCompoundingOneYearRate = effectiveRate.equivalentRate(Compounded,
    Semiannual, 1);
  prefs: []
  type: TYPE_NORMAL
- en: 'std::cout << “Equivalent one year semi-annually compounded rate is: ” << semiAnnualCompoundingOneYearRate.rate()
    << std::endl;'
  prefs: []
  type: TYPE_NORMAL
- en: //what is the equivalent 1 year rate if compounded continuously?
  prefs: []
  type: TYPE_NORMAL
- en: InterestRate continuousOneYearRate = effectiveRate.equivalentRate(Continuous,
    Annual, 1);
  prefs: []
  type: TYPE_NORMAL
- en: 'std::cout << “Equivalent one year continuously compounded rate is: ” << continuousOneYearRate.rate()
    << std::endl;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this code when run is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Rate with annual compounding is: 0.05'
  prefs: []
  type: TYPE_NORMAL
- en: 'Equivalent one year semi-annually compounded rate is: 0.0493902'
  prefs: []
  type: TYPE_NORMAL
- en: 'Equivalent one year continuously compounded rate is: 0.0487902`'
  prefs: []
  type: TYPE_NORMAL
- en: Let me take you through the example. It calculates the the equivalent rates
    required to match the interest generated by a 5% annual rate, compounded annually,
    first with semi-annual compounding then with continuous compounding.  Semi-annual
    compounding means the interest paid in the first 6 month period is rolled over,
    with the principal, into the next 6 month period. Since there are two compounding
    periods, the equivalent rate is lower. That is, a 4.93% annual rate, compounded
    semi-annually pays the same amount of interest as a 5% rate, compounded annually.
    Similarly, if interest is paid on a continuous compounding basis, then the interest
    rate need only be 4.87% to generate the same amount of interest as the 5% annual
    rate, compounded annually. Generally speaking, then, the more compounding periods,
    the lower the equivalent interest relative to the effective rate, typically expressed
    as an annual rate, compounded annually.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the nuances of comparing interest rates with the same
    duration and different compounding periods, you’re ready to dive into my next
    topic- the term structure of interest rates. An interest rate term structure,
    or yield curve, depicts the difference in the market rate of interest on short
    term loans versus the market rate for longer term loans or cash flows. Typically,
    long term rates are higher than short-term rates. There are many theories which
    attempt to explain this phenomenon, but that is beyond the scope of this post.
  prefs: []
  type: TYPE_NORMAL
- en: Suffice it to say that QuantLib provides excellent support for constructing
    and manipulating yield curves through the [YieldTermStructure](http://quantlib.org/reference/class_quant_lib_1_1_yield_term_structure.html)
    class. In my next post, I’ll demonstrate how to construct a YieldTermStructure
    instance and use it to price a fixed-rate bond.  As I stated in my previous post,
    this is a more realistic and flexible way of pricing bonds than the more academic
    bond pricing example that you’ve seen already.
  prefs: []
  type: TYPE_NORMAL
- en: As always, thanks for reading my blog and be sure to check back soon!
  prefs: []
  type: TYPE_NORMAL
- en: About Mick Hittesdorf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I'm a versatile technical leader with a passion for data analytics, data science
    and Big Data technology. I have experience working for both large and small organizations,
    in a variety of roles. I've been responsible for the management and operations
    of a global data science and analytics platform, developed low latency, proprietary
    trading systems, managed software development teams, defined enterprise architecture
    strategies, written white papers and blogs, published articles in industry journals
    and delivered innovative solutions to clients, both in a consulting and technical
    sales capacity. My current areas of focus include Big Data, data engineering,
    data science, R, and Cloud computing
  prefs: []
  type: TYPE_NORMAL
