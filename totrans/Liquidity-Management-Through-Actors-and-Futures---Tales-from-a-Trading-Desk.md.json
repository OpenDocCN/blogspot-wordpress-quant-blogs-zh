["```\n\nimport akka.actor.{ ActorSystem, Props, Actor, Inbox }\nimport scala.collection.mutable._\nimport scala.concurrent.ExecutionContext\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Future\nimport akka.pattern.{ ask, pipe }\nimport ExecutionContext.Implicits.global\n\ncase class CorePrice(instrument : String, price : Double)\ncase class TieredPrice(instrument : String, price : Double)\ncase class MarketData(instrument : String, price : Double)\ncase class FIXRFQRequest(instrument : String)\ncase class RFQ(instrument : String)\n\nclass LiquidityConnector(venue : String) extends Actor {\n  override def preStart(): Unit = {\n    println(s\"LiquidityConnector preStart for $venue on $self.path\")\n  }\n\n  def receive: Actor.Receive = {\n    case MarketData(instrument, price) => {\n      println(s\"Received MarketData from $venue $instrument $price\")\n\n      val actor = context.actorSelection(\"../Aggregator\")\n      println(s\"Sent MarketData to $actor\")\n      actor ! MarketData(instrument, price)\n    }\n  }\n}\n\nclass Aggregator extends Actor {\n  override def preStart(): Unit = {\n    println(\"Aggregator preStart \" + self.path)\n  }\n\n  def receive: Actor.Receive = {\n    case MarketData(instrument, price) => {\n      println(s\"Received MarketData message, sending to CorePricer $instrument $price\")\n      val actor = context.actorSelection(\"../CorePricer\")\n      actor ! MarketData(instrument, price)\n    }\n  }\n}\n\nclass CorePricer extends Actor {\n  val prices = new HashMap[String, Double]\n\n  def receive: Actor.Receive = {\n    case MarketData(instrument, price) => {\n      println(s\"Received MarketData sending to TieredPricer $instrument $price\")\n      val currentPrice = if (prices.contains(instrument)) prices(instrument) else 0\n      if (currentPrice > 0)\n        prices += (instrument -> ((price + currentPrice)/2))\n      else\n        prices += (instrument -> price)\n\n      val actor = context.actorSelection(\"../TieredPricer\")\n      println(s\"Received MarketData sending to TieredPricer $instrument $prices(instrument)\")\n      actor ! CorePrice(instrument, prices(instrument))\n    }\n  }\n}\n\nclass TieredPricer extends Actor {\n  val prices = new HashMap[String, Double]\n\n  def receive: Actor.Receive = {\n    case CorePrice(instrument, price) => {\n      prices += (instrument -> price)\n    }\n    case RFQ(instrument) => {\n      val price = prices(instrument)\n      println(s\"TieredPricer - Sending TieredPrice for RFQ $instrument $price to $sender\")\n      sender ! TieredPrice(instrument, price)\n    }\n  }\n}\n\nclass LiquidityDistributor extends Actor {\n  def receive: Actor.Receive = {\n    case RFQ(instrument) => {\n      val actor = context.actorSelection(\"../TieredPricer\")\n      println(s\"Sent RFQ to $actor\")\n\n      implicit val timeout = Timeout(5 seconds)\n      val future : Future[TieredPrice] = ask(actor, RFQ(instrument)).mapTo[TieredPrice]\n      pipe(future) to sender\n    }\n  }\n}\n\nclass VenueConnectivity(venue : String) extends Actor {\n  override def preStart(): Unit = {\n    println(s\"VenueConnectivity preStart for $venue on $self.path\")\n  }\n\n  def receive: Actor.Receive = {\n    case RFQ(instrument) => {\n      println(s\"Received RFQ from $venue $instrument\")\n      val actor = context.actorSelection(\"../LiquidityDistributor\")\n      println(s\"Sent RFQ to $actor\")\n\n      implicit val timeout = Timeout(5 seconds)\n      val future : Future[TieredPrice] = ask(actor, RFQ(instrument)).mapTo[TieredPrice]\n      pipe(future) to sender\n    }\n  }\n}\n\nobject LiquidityManagement extends App {\n\n  val system = ActorSystem(\"LiquidityManagement\")\n\n  val bloombergActor = system.actorOf(Props(classOf[LiquidityConnector], \"Bloomberg\"), name=\"Bloomberg\")\n  val fxAllActor = system.actorOf(Props(classOf[LiquidityConnector], \"FxAll\"), name=\"FxAll\")\n  val aggregator = system.actorOf(Props[Aggregator], \"Aggregator\")\n  val core = system.actorOf(Props[CorePricer], \"CorePricer\")\n  val tiered = system.actorOf(Props[TieredPricer], \"TieredPricer\")\n  val distributor = system.actorOf(Props[LiquidityDistributor], \"LiquidityDistributor\")\n  val hotSpotActor = system.actorOf(Props(classOf[VenueConnectivity], \"HotSpot\"), name=\"HotSpot\")\n\n  bloombergActor ! MarketData(\"USD\", 12.23)\n  fxAllActor ! MarketData(\"USD\", 12.235)\n\n  val inbox = Inbox.create(system)\n  inbox.send(hotSpotActor, RFQ(\"USD\"))\n  val TieredPrice(instrument, price) = inbox.receive(5.seconds)\n  println(s\"RFQ Response: $instrument $price\")\n\n  system.shutdown();\n}\n\n```"]