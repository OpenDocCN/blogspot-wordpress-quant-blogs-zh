- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: Êú™ÂàÜÁ±ª'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-18 06:37:01'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Financial Messaging: ZeroMQ Random Reading | Tales from a Trading Desk'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Êù•Ê∫êÔºö[https://mdavey.wordpress.com/2012/08/01/financial-messaging-zeromq-random-reading/#0001-01-01](https://mdavey.wordpress.com/2012/08/01/financial-messaging-zeromq-random-reading/#0001-01-01)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Bit of a¬†spaghetti posting, but possibly relevant at a future date üòâ
  prefs: []
  type: TYPE_NORMAL
- en: Although old, [Design and Evaluation of Benchmarks for Financial Applications
    using Advanced Message Queuing Protocol (AMQP) over InÔ¨ÅniBand](ftp://ftp.cse.ohio-state.edu/pub/tech-report/2008/TR51.pdf)
    is worth a read in the context of Martin‚Äôs [comments](https://groups.google.com/forum/?fromgroups#!topic/lmax-disruptor/CFXHbAYqmIs)
    around the disruptor, Ultra Messaging and ZeroMQ (√òMQ)
  prefs: []
  type: TYPE_NORMAL
- en: 0MQ did not exist when we evaluated message providers. ¬†This was about
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3 years ago. ¬†It does look interesting for some usecases.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When going for ultra low-latency you need to pick a transport that
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: uses IP multicast or InfiniBand. ¬†TCP has significant overhead, and
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: buffering, which does not lend itself to low-latency. ¬†It is also
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: important to pick a transport that does not use daemons/brokers.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: These ‚Äúmen in the middle‚Äù add latency and can be single points of
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure. ¬†State of the art is single digit microseconds for a hop
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: between two nodes. ¬†Have you measured 0MQ?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Which leads to Mr Fowler‚Äôs overview of the [LMAX](http://martinfowler.com/articles/lmax.html)
    architecture, and specifically the details on replication and master/slave:'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier on I mentioned that LMAX runs multiple copies of its system in a cluster
    to support rapid failover. The replicator keeps these nodes in sync. All communication
    in LMAX uses IP multicasting, so clients don‚Äôt need to know which IP address is
    the master node. Only the master node listens directly to input events and runs
    a replicator. The replicator broadcasts the input events to the slave nodes. Should
    the master node go down, it‚Äôs lack of heartbeat will be noticed, another node
    becomes master, starts processing input events, and starts its replicator. Each
    node has its own input disruptor and thus has its own journal and does its own
    unmarshaling.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Even with IP multicasting replication is still needed because IP messages can
    arrive in a different order on different nodes. The master node provides a deterministic
    sequence for the rest of the processing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Which leads to a few relevant articles over on the ZeroMQ site (assuming you
    happened to want to look at ZeroMQ in this context, and didn‚Äôt want to pay for
    Ultra Messaging):'
  prefs: []
  type: TYPE_NORMAL
- en: ~ by mdavey on August 1, 2012.
  prefs: []
  type: TYPE_NORMAL
- en: Posted in [Uncategorized](https://mdavey.wordpress.com/category/uncategorized/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Tags: [Disruptor](https://mdavey.wordpress.com/tag/disruptor/), [Messaging](https://mdavey.wordpress.com/tag/messaging/)'
  prefs: []
  type: TYPE_NORMAL
