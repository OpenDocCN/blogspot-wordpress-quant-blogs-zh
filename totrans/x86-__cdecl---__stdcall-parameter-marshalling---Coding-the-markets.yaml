- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-12 19:32:37'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: x86 __cdecl & __stdcall parameter marshalling | Coding the markets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://etrading.wordpress.com/2014/07/23/x86-__cdecl-__stdcall-parameter-marshalling/#0001-01-01](https://etrading.wordpress.com/2014/07/23/x86-__cdecl-__stdcall-parameter-marshalling/#0001-01-01)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: x86 __cdecl & __stdcall parameter marshalling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: July 23, 2014
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose you have a third party Win32 DLL, but don’t have access to the source
    code. The DLL exports a well known init function that makes callbacks into your
    code to register more functions. So you can call Win32’s [LoadLibrary](http://msdn.microsoft.com/en-gb/library/windows/desktop/ms684175%28v=vs.85%29.aspx)
    to load up the DLL, and you can use [GetProcAddress](http://msdn.microsoft.com/en-gb/library/windows/desktop/ms683212%28v=vs.85%29.aspx)
    to get hold of a pointer to the init func. You can invoke the init function from
    your code because you know the function prototype – the number and type of parameters.
    Then you get callbacks into a Register function you supply, which gives your code
    the names of other functions exported by the third party DLLs, as well as the
    number and type of parameters. Excel developers will recognise the description
    of the XLL function registration mechanism. So, given the names of those functions
    you can use GetProcAddress to get function pointers for them. But how do you invoke
    them? You don’t have function declarations available at compile time in your code.
    The functions don’t use varargs, so you can’t use va_start and va_end to figure
    out the params at run time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only way to resolve this dilemma is to kick down to assembler, and hand
    code some x86 that follows the Win32 calling conventions, which are well explained
    [here](http://unixwiz.net/techtips/win32-callconv.html) and [here](http://en.wikipedia.org/wiki/X86_calling_conventions).
    So here’s the code I wrote to invoke arbitray functions exported from a DLL. I
    used a couple of great resources to refresh my ASM chops, which have become very
    rusty after years of neglect: this [primer](http://www.cs.virginia.edu/~evans/cs216/guides/x86.html)
    and this [x86 instruction set reference](http://x86.renejeschke.de/). It’s in
    inline assembler, together with the C++ preamble that sets up parameters to simplify
    the assembler.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
