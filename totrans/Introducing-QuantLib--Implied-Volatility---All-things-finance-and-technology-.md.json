["```\n #include <cstdlib>\n#include <iostream>>\n#define BOOST_AUTO_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n#include <ql/quantlib.hpp>\n#include <boost/detail/lightweight_test.hpp>\n#include <vector>\n#include <boost/function.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <fstream>\n#include <utility>\n\nnamespace {\n\nusing namespace QuantLib;\n\nclass StrikeInfo {\n\n    public:\n        typedef std::pair<SimpleQuote,SimpleQuote> BidAsk;\n        StrikeInfo(Option::Type optionType, Real strike, const BidAsk& bidAsk) : \n            _payoff(PlainVanillaPayoff(optionType, strike)), _bidAsk(bidAsk),\n            _impliedVol(0.0) {}\n\n        //copy constructor\n        StrikeInfo(const StrikeInfo& that) \n           : _payoff(new PlainVanillaPayoff(that.getPayoff().optionType(), that.getPayoff().strike())),\n            _bidAsk(that.getBidAsk()), _impliedVol(that.getImpliedVol()) {\n        }\n\n        //assignment operator - [implements copy-and-swap idiom](http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom)\n        StrikeInfo& operator=(StrikeInfo that) {\n            swap(*this, that);\n        }\n\n        //swap\n        friend void swap(StrikeInfo& first, StrikeInfo& second) {\n            using std::swap;\n            first._payoff.swap(second._payoff);\n            std::swap(first._impliedVol, second._impliedVol);\n            std::swap(first._bidAsk, second._bidAsk);\n        }\n\n        const StrikedTypePayoff& getPayoff() const { return *_payoff;}\n        const BidAsk& getBidAsk() const { return _bidAsk; }\n        const Volatility& getImpliedVol() const { return _impliedVol; }\n        void setImpliedVol(Volatility impliedVol) { _impliedVol = impliedVol;}\n        Real getStrike() { return _payoff->strike(); }\n\n    private:\n\n        boost::scoped_ptr<StrikedTypePayoff> _payoff;\n        Volatility _impliedVol;\n        BidAsk _bidAsk;\n\n};\n\nBOOST_AUTO_TEST_CASE(testESFuturesImpliedVolatility) {\n\n    using namespace boost::posix_time;\n    using namespace boost::gregorian;\n\n    ActualActual actualActual;\n    Settings::instance().evaluationDate() = Date(26, Month::August, 2013);\n    Date expiration(20, Month::September, 2013);\n\n    Time timeToMaturity = actualActual.yearFraction(Settings::instance().evaluationDate(), expiration);\n    ptime quoteTime(from_iso_string(\"20130826T143000\"));\n    time_duration timeOfDayDuration = quoteTime.time_of_day();\n    timeToMaturity += (timeOfDayDuration.hours() + timeOfDayDuration.minutes()/60.0)/(24.0 * 365.0);\n    std::cout << boost::format(\"Time to maturity: %.6f\") % timeToMaturity << std::endl;\n    Real forwardBid = 1656.00; \n    Real forwardAsk = 1656.25;\n    Rate riskFree = .00273;  //interpolated LIBOR rate (between EDU3 and EDV3)\n    DiscountFactor discount = std::exp(-riskFree * timeToMaturity);\n\n    //calculate implied volatilities for OTM put options\n\n    std::vector<StrikeInfo> putOptions;\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(7.75, 8.00), 1600));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(8.50, 9.00), 1605));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(9.25, 9.75), 1610));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(10.25, 10.75), 1615));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(11.25, 11.75), 1620));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(12.50, 12.75), 1625));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(13.75, 14.00), 1630));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(15.00, 15.50), 1635));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(16.50, 17.00), 1640));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(18.00, 18.50), 1645));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(20.00, 20.25), 1650));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(21.75, 22.25), 1655));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(24.00, 24.25), 1660));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(26.25, 26.75), 1665));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(28.75, 29.25), 1670));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(31.25, 32.25), 1675));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(34.25, 35.25), 1680));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(37.25, 38.25), 1685));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(40.75, 41.75), 1690));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(44.25, 45.25), 1695));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(47.50, 49.75), 1700));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(51.50, 53.75), 1705));\n    putOptions.push_back(StrikeInfo(Option::Type::Put, std::make_pair(55.75, 58.00), 1710));\n\n   for (StrikeInfo& putOption: putOptions) {\n\tStrikeInfo::BidAsk bidAsk = putOption.getBidAsk();\n\tReal price = (bidAsk.first.value() + bidAsk.second.value())/2.0;\n\tconst StrikedTypePayoff& payoff = putOption.getPayoff();\n\tif (payoff(forwardAsk) > 0) continue; //skip ITM options\n        Bisection bisection;\n        Real accuracy = 0.000001, guess = .20;\n        Real min = .05, max = .40;\n        Volatility sigma = bisection.solve([&](const Volatility & sigma) {\n        Real stdDev = sigma * std::sqrt(timeToMaturity);\n        BlackCalculator blackCalculator(payoff.optionType(), payoff.strike(), forwardAsk, stdDev, discount);\n            \treturn blackCalculator.value() - price;\n        \t}, accuracy, guess, min, max);\n\n\tputOption.setImpliedVol(sigma);\n        std::cout << boost::format(\"IV of %f put is %f\") % putOption.getStrike() % sigma << std::endl;\n\n    }\n\n   //calculate implied volatilities for OTM call options\n\n   std::vector<StrikeInfo> callOptions;\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(63.00, 65.25), 1600));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(59.25, 60.25), 1605));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(55.25, 56.25), 1610));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(51.00, 52.00), 1615));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(47.00, 48.00), 1620));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(43.25, 44.25), 1625));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(39.50, 40.50), 1630));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(35.75, 36.75), 1635));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(32.25, 33.25), 1640));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(29.25, 29.75), 1645));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(26.00, 26.25), 1650));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(23.00, 23.50), 1655));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(20.00, 20.50), 1660));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(17.25, 17.75), 1665));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(14.75, 15.25), 1670));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(12.50, 13.00), 1675));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(10.50, 11.00), 1680));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(8.75, 9.25), 1685));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(7.00, 7.50), 1690));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(5.75, 6.00), 1695));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(4.70, 4.80), 1700));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(3.70, 3.85), 1705));\n   callOptions.push_back(StrikeInfo(Option::Type::Call, std::make_pair(2.90, 3.05), 1710));\n\n    for (StrikeInfo& callOption: callOptions) {\n        StrikeInfo::BidAsk bidAsk = callOption.getBidAsk();\n\tReal price = (bidAsk.first.value() + bidAsk.second.value())/2.0;\n\tconst StrikedTypePayoff& payoff = callOption.getPayoff();\n\tif (payoff(forwardBid) > 0) continue; //skip ITM options\n        Bisection bisection;\n        Real accuracy = 0.000001, guess = .20;\n        Real min = .05, max = .40;\n        Volatility sigma = bisection.solve([&](const Volatility & sigma) {\n            Real stdDev = sigma * std::sqrt(timeToMaturity);\n            BlackCalculator blackCalculator(payoff.optionType(), payoff.strike(), forwardBid, stdDev, discount);\n            \treturn blackCalculator.value() - price;\n            }, accuracy, guess, min, max);\n\n\tcallOption->setImpliedVol(sigma);\n\n        std::cout << boost::format(\"IV of %f call is %f\") % callOption.getStrike() % sigma << std::endl;\n    }\n\n    //write strike and IV to file for each option\n    std::ofstream ivFile;\n    ivFile.open(\"/tmp/iv.dat\", std::ios::out);\n\n    //write OTM put IVs\n    for (StrikeInfo& putOption: putOptions) {\n\tif (putOption.getImpliedVol() > 0.0) {\n\t    ivFile << boost::format(\"%f %f\") % putOption.getStrike() % putOption.getImpliedVol() << std::endl; \n\t}\n    }\n\n    //write OTM call IVs\t\t\n    for (StrikeInfo& callOption: callOptions) {\n\tif (callOption.getImpliedVol() > 0.0) {\n\t    ivFile << boost::format(\"%f %f\") % callOption.getStrike() % callOption.getImpliedVol() << std::endl; \n\t}\n    }\n    ivFile.close();\n\n    //plot with gnuplot using commands below. Run 'gnuplot' then type in: \n    /*\n    set terminal png\n    set output \"/tmp/volsmile.png\"\n    set key top center\n    set key box\n    set xlabel \"Strike\"\n    set ylabel \"Volatility\"\n    plot '/tmp/iv.dat' using 1:2 w linespoints title \"ES Volatility Smile\"\n    */\n}} \n```"]