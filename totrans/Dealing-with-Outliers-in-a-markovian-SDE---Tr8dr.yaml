- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-18 15:38:26'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Outliers in a markovian SDE | Tr8dr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://tr8dr.wordpress.com/2009/10/31/dealing-with-outliers-in-sde-parameter-estimation/#0001-01-01](https://tr8dr.wordpress.com/2009/10/31/dealing-with-outliers-in-sde-parameter-estimation/#0001-01-01)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I was developing a state model similar to the ADS (*Arouba*–*Diebold*–*Scotti*
    index) to provide a daily indication of economic cycle for the Canadian market.  
    Economic data sourced from news can be particularly noisy (ie dataentry errors,
    etc).   I had encountered this in the state system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 3](img/8bbbc70739768af9b535c0b990c879ae.png "Picture 3")'
  prefs: []
  type: TYPE_IMG
- en: The instability was due to bad data points in the series.  Cleaning the bad
    data solved the problem.  However, detecting unintended outliers at runtime is
    especially important for real-time strategies.
  prefs: []
  type: TYPE_NORMAL
- en: 'A markovian state system, where each state depends on the previous, is particularly
    sensitive to data issues.   Such a system is typically set up as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 1](img/dd8deb6663c7bf290d90bca584639f2c.png "Picture 1")'
  prefs: []
  type: TYPE_IMG
- en: 'In particle filtering or kalman filtering one is estimating hidden state based
    on observations and using the hidden state to make statements about the market.  
    An outlier is such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 4](img/1897ab6668b091bfeffa9b1d960f90c5.png "Picture 4")'
  prefs: []
  type: TYPE_IMG
- en: 'In such a situation a kalman filtered state system will collapse and one will
    get a huge spike in the state system as an oscillating function as it attempts
    to minimize the disturbance in subsequent iterations.   Assuming the “outlier”
    is in fact correct data, our state system suffers from one of a number of possible
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Distribution does not have proper tails
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Covariance of innovation is too small, causing system to be numerically unstable
    in the presence of near zero probability observation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are approaches for dealing with this such as adopting a weighted least
    squares approach or bayesian weighting of observations (see [Learning an Outlier
    -Robust Kalman Filter](http://www.google.com/url?sa=t&source=web&ct=res&cd=1&ved=0CA0QFjAA&url=http%3A%2F%2Fwww-clmc.usc.edu%2Fpublications%2F%2FT%2FTR-CLMC-2007-1.pdf&ei=rF7sSqvuI4eslAf7rdX_BA&usg=AFQjCNEVtP3NqiOxmV4FbciooUsMFR8UnQ&sig2=heofR9OhJFqzTDVtOgj-Jg
    "Learning an Outlier-Robust Kalman Filter ")).
  prefs: []
  type: TYPE_NORMAL
- en: In our case, however, the outliers are data errors.   For non-realtime systems,
    the data can be cleaned.  In the case of a real-time strategy we don’t have the
    option of manually cleaning data, so we may need to resort to a heuristic to determine
    whether the data is an “outlier” or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'One heuristic approach is to determine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 5](img/85b409f6107c0c17b2ddb9c383ddd413.png "Picture 5")'
  prefs: []
  type: TYPE_IMG
- en: 'and then evaluate the probability of this observation Yt given Xt.   This can
    be accomplished by evaluating the pdf on the residual of the projected versus
    observed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 6](img/cb9c8ba11d6742954b7ecd8774df5a1a.png "Picture 6")'
  prefs: []
  type: TYPE_IMG
- en: If the probability is 0 or near 0 then the data is clearly an outlier.  The
    estimation of the expected value of Xt can be determined by estimating the distribution
    of state.
  prefs: []
  type: TYPE_NORMAL
- en: How does one evaluate E(X[t] | X[t-1])?   A simple (though expensive) way to
    evaluate this is to draw noise samples from the innovation (error) distribution,
    evaluate Fx(X[t-1],) + Ex, and use the robust mean of those samples weighted by
    the probability of the draw.   The number of samples needed can be reduced by
    using a kernel estimator when determining the expectation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally if a outlier is detected, we can treat it as a missing value.  Information
    has been lost, but at least we have preserved the stability of our state system.  
    This is a reasonable approach, I think, for the occassional outlier.
  prefs: []
  type: TYPE_NORMAL
