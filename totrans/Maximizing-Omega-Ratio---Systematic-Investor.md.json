["```\n\nmax.omega.portfolio <- function\n(\n\tia,\t\t# input assumptions\n\tconstraints\t# constraints\n)\n{\n\tn = ia$n\n\tnt = nrow(ia$hist.returns)\n\n\tconstraints0 = constraints\n\n\tomega = ia$parameters.omega\t\n\n\t#--------------------------------------------------------------------------\n\t# Linear Programming, Omega > 1, Case\n\t#--------------------------------------------------------------------------\n\n\t# objective : Omega\n\t# [ SUM <over j> 1/T * u.j ]\n\tf.obj = c(rep(0, n), (1/nt) * rep(1, nt), rep(0, nt), 0)\n\n\t# adjust constraints, add u.j, d.j, t\n\tconstraints = add.variables(2*nt + 1, constraints, lb = c(rep(0,2*nt),-Inf))\n\n\t# Transformation for inequalities\n\t# Aw < b => Aw1 - bt < 0\n\tconstraints$A[n + 2*nt + 1, ] = -constraints$b\n\tconstraints$b[] = 0\t\n\n\t# Transformation for Lower/Upper bounds, use same transformation\n\tindex = which( constraints$ub[1:n] < +Inf )\t\n\tif( len(index) > 0 ) {\t\t\t\n\t\ta = rbind( diag(n), matrix(0, 2*nt, n), -constraints$ub[1:n])\t\t\n\t\tconstraints = add.constraints(a[, index], rep(0, len(index)), '<=', constraints)\t\t\t\n\t}\n\n\tindex = which( constraints$lb[1:n] > -Inf )\t\n\tif( len(index) > 0 ) {\t\n\t\ta = rbind( diag(n), matrix(0, 2*nt, n), -constraints$lb[1:n])\t\t\n\t\tconstraints = add.constraints(a[, index], rep(0, len(index)), '>=', constraints)\t\t\t\t\t\n\t}\n\n\tconstraints$lb[1:n] = -Inf\n\tconstraints$ub[1:n] = Inf\n\n\t# [ SUM <over i> r.ij * x.i ] - u.j + d.j - L * t = 0, for each j = 1,...,T \t\n\ta = rbind( matrix(0, n, nt), -diag(nt), diag(nt), -omega)\n\t\ta[1 : n, ] = t(ia$hist.returns)\n\tconstraints = add.constraints(a, rep(0, nt), '=', constraints)\t\t\t\n\n\t# [ SUM <over j> 1/T * d.j ] = 1\t\n\tconstraints = add.constraints(c( rep(0,n), rep(0,nt), (1/nt) * rep(1,nt), 0), 1, '=', constraints)\t\t\t\t\n\n\t# setup linear programming\n\tf.con = constraints$A\n\tf.dir = c(rep('=', constraints$meq), rep('>=', len(constraints$b) - constraints$meq))\n\tf.rhs = constraints$b\n\n\t# find optimal solution\n\tx = NA\n\tsol = try(solve.LP.bounds('max', f.obj, t(f.con), f.dir, f.rhs,\n\t\t\t\t\tlb = constraints$lb, ub = constraints$ub), TRUE)\n\n\tif(!inherits(sol, 'try-error')) {\n\t\tx0 = sol$solution[1:n]\n\t\tu = sol$solution[(1+n):(n+nt)]\n\t\td = sol$solution[(n+nt+1):(n+2*nt)] \n\t\tt = sol$solution[(n+2*nt+1):(n+2*nt+1)] \n\n\t\t# Reverse Transformation\t\n\t\tx = x0/t\n\t}\n\n\t#--------------------------------------------------------------------------\n\t# NonLinear Programming, Omega > 1, Case\n\t#--------------------------------------------------------------------------\n\t# Check if any u.j * d.j != 0 or LP solver encounter an error\n\tif( any( u*d != 0 ) || sol$status !=0 ) {\n\t\trequire(Rdonlp2)\n\n\t\tconstraints = constraints0\n\n\t\t# compute omega ratio\n\t\tfn <- function(x){\n\t\t\tportfolio.returns = x %*% t(ia$hist.returns)\t\n\t\t\tmean(pmax(portfolio.returns - omega,0)) / mean(pmax(omega - portfolio.returns,0))\n\t\t}\n\n\t\t# control structure, fnscale - set -1 for maximization\n\t\tcntl <- donlp2.control(silent = T, fnscale = -1, iterma =10000, nstep = 100, epsx = 1e-10)\t\n\n\t\t# lower/upper bounds\n\t\tpar.l = constraints$lb\n\t\tpar.u = constraints$ub\n\n\t\t# intial guess\n\t\tif(!is.null(constraints$x0)) p = constraints$x0\n\n\t\t# linear constraints\n\t\tA = t(constraints$A)\n\t\tlin.l = constraints$b\n\t\tlin.u = constraints$b\n\t\tlin.u[ -c(1:constraints$meq) ] = +Inf\n\n\t\t# find solution\n\t\tsol = donlp2(p, fn, par.lower=par.l, par.upper=par.u, \n\t\t\tA=A, lin.u=lin.u, lin.l=lin.l, control=cntl)\n\t\tx = sol$par\n\t}\n\n\treturn( x )\n}\n\n```", "```\n\n# load Systematic Investor Toolbox\nsetInternet2(TRUE)\nsource(gzcon(url('https://github.com/systematicinvestor/SIT/raw/master/sit.gz', 'rb')))\n\n#--------------------------------------------------------------------------\n# Create Efficient Frontier\n#--------------------------------------------------------------------------\n\tia = aa.test.create.ia()\n\tn = ia$n\t\t\n\n\t# 0 <= x.i <= 0.8 \n\tconstraints = new.constraints(n, lb = 0, ub = 0.8)\n\n\t# SUM x.i = 1\n\tconstraints = add.constraints(rep(1, n), 1, type = '=', constraints)\t\t\n\n\t# Omega - http://en.wikipedia.org/wiki/Omega_ratio\n\tia$parameters.omega = 13/100 \n\t\tia$parameters.omega = 12/100 \n\t\t# convert annual to monthly\n\t\tia$parameters.omega = ia$parameters.omega / 12\n\n\t# create efficient frontier(s)\n\tef.risk = portopt(ia, constraints, 50, 'Risk')\n\n\t# Plot Omega Efficient Frontiers and Transition Maps\n\tlayout( matrix(1:4, nrow = 2, byrow=T) )\n\n\t# weights\n\trownames(ef.risk$weight) = paste('Risk','weight',1:50,sep='_')\n\tplot.omega(ef.risk$weight[c(1,10,40,50), ], ia)\n\n\t# assets\n\ttemp = diag(n)\n\trownames(temp) = ia$symbols\n\tplot.omega(temp, ia)\n\n\t# mean-variance efficient frontier in the Omega Ratio framework\n\tplot.ef(ia, list(ef.risk), portfolio.omega, T, T)\t\t\t\n\n```", "```\n\n#--------------------------------------------------------------------------\n# Create Efficient Frontier in Omega Ratio framework\n#--------------------------------------------------------------------------\n\t# Create maximum Omega Efficient Frontier\n\tef.omega = portopt.omega(ia, constraints, 50, 'Omega')\n\n\t# Plot Omega Efficient Frontiers and Transition Maps\n\tlayout( matrix(1:4, nrow = 2, byrow=T) )\n\n\t# weights\n\tplot.omega(ef.risk$weight[c(1,10,40,50), ], ia)\n\n\t# weights\n\trownames(ef.omega$weight) = paste('Omega','weight',1:50,sep='_')\t\n\tplot.omega(ef.omega$weight[c(1,10,40,50), ], ia)\n\n\t# portfolio\n\tplot.ef(ia, list(ef.omega, ef.risk), portfolio.omega, T, T)\t\t\t\n\n```"]