["```\n #include <cstdlib>\n#include <iostream>\n#include <ql/quantlib.hpp>\n\nusing namespace QuantLib;\n\nboost::shared_ptr<BlackVolTermStructure> bootstrapVolatilityCurve(const Date& \nevaluationDate, const std::vector<Real>& strikes, \nconst std::vector<Volatility>& vols, const Date& expiration) {\n\n    Calendar calendar = UnitedStates(UnitedStates::NYSE);\n\n    std::vector<Date> expirations;\n    expirations.push_back(expiration);\n\n    Matrix volMatrix(strikes.size(), 1);\n\n    //implied volatilities from Interactive Brokers\n    for (int i=0; i< vols.size(); ++i) {\n        volMatrix[i][0] = vols[i];\n    }\n\n    return boost::shared_ptr<BlackVolTermStructure>(new BlackVarianceSurface(evaluationDate, calendar,\nexpirations, strikes, volMatrix, Actual365Fixed()));\t\t\n} \n```", "```\n #include <cstdlib>\n#include <iostream>\n#include <ql/quantlib.hpp>\n#include <boost/assign/std/vector.hpp>\n\nusing namespace QuantLib;\n\nboost::shared_ptr<YieldTermStructure> bootstrapLiborZeroCurve(const Date& evaluationDate) {\n\n    using namespace boost::assign;\n\n    //bootstrap from USD LIBOR rates;\n    IborIndex libor = USDLiborON();  \n    const Calendar& calendar = libor.fixingCalendar();\n    const Date& settlement = calendar.advance(evaluationDate, 2, Days);\n    const DayCounter& dayCounter = libor.dayCounter();       \n    Settings::instance().evaluationDate() = settlement;\n\n    //rates obtained from http://www.global-rates.com/interest-rates/libor/libor.aspx \n    Rate overnight = .10490/100.0;\n    Rate oneWeek = .12925/100.0;\n    Rate oneMonth = .16750/100.0;\n    Rate twoMonths = .20700/100.0;\n    Rate threeMonths = .23810/100.0;\n    Rate sixMonths = .35140/100.0;\n    Rate twelveMonths = .58410/100.0;\n\n    std::vector<boost::shared_ptr<RateHelper>> liborRates;\n    liborRates += boost::shared_ptrRateHelper>(new DepositRateHelper(overnight,\n        boost::shared_ptr<IborIndex>(new USDLiborON()))); \n    liborRates += boost::shared_ptr<RateHelper>(new DepositRateHelper(oneWeek,\n        boost::shared_ptr<IborIndex>(new USDLibor(Period(1, Weeks)))));\n    liborRates += boost::shared_ptr<RateHelper>(new DepositRateHelper(oneMonth,\n        boost::shared_ptr<IborIndex>(new USDLibor(Period(1, Months)))));\n    liborRates += boost::shared_ptr<RateHelper>(new DepositRateHelper(twoMonths,\n\tboost::shared_ptr<IborIndex>(new USDLibor(Period(2, Months)))));\n    liborRates += boost::shared_ptr<RateHelper>(new DepositRateHelper(threeMonths,\n\tboost::shared_ptr<IborIndex>(new USDLibor(Period(3, Months)))));\n    liborRates += boost::shared_ptr<RateHelper>(new DepositRateHelper(sixMonths,\n\tboost::shared_ptr<IborIndex>(new USDLibor(Period(6, Months)))));\n    liborRates += boost::shared_ptr<RateHelper>(new DepositRateHelper(twelveMonths,\n\tboost::shared_ptr<IborIndex>(new USDLibor(Period(12, Months)))));\n\n    //use cubic interpolation\n    boost::shared_ptr<YieldTermStructure> yieldCurve = \n    boost::shared_ptr<YieldTermStructure>(new [PiecewiseYieldCurve](http://quantlib.org/reference/class_quant_lib_1_1_piecewise_yield_curve.html)<ZeroYield, \nCubic>(settlement, liborRates, dayCounter));\n\n    return yieldCurve;\t\n} \n```", "```\n #include <cstdlib>\n#include <iostream>\n#include <ql/quantlib.hpp>\n#include <boost/format.hpp>\n\nusing namespace QuantLib;\n\nboost::shared_ptr<ZeroCurve> bootstrapDividendCurve(const Date& evaluationDate, \nconst Date& expiration, const Date& exDivDate, Real underlyingPrice, Real annualDividend) {\n\n    UnitedStates calendar(UnitedStates::NYSE);\n    Settings::instance().evaluationDate() = evaluationDate;\n    Real settlementDays = 2.0;\n\n    Real dividendDiscountDays = (expiration - evaluationDate) + settlementDays;\n    std::cout << boost::format(\"Dividend discounting days: %d\") %\n dividendDiscountDays << std::endl;\n    Rate dividendYield = (annualDividend/underlyingPrice) * dividendDiscountDays/365;\n\n    // ex div dates and yields\n    std::vector<Date> exDivDates;\n    std::vector<Rate&gt dividendYields;\n\n    //last ex div date and yield\n    exDivDates.push_back(calendar.advance(exDivDate, Period(-3, Months), \nModifiedPreceding, true));\n    dividendYields.push_back(dividendYield);\n\n    //currently announced ex div date and yield\n    exDivDates.push_back(exDivDate);\n    dividendYields.push_back(dividendYield);\n\n    //next ex div date (projected) and yield\n    Date projectedNextExDivDate = calendar.advance(exDivDate, Period(3, Months), \nModifiedPreceding, true); \n    std::cout << boost::format(\"Next projected ex div date for INTC: %s\") % \nprojectedNextExDivDate << std::endl;\n    exDivDates.push_back(projectedNextExDivDate);\n    dividendYields.push_back(dividendYield);\n\n    return boost::shared_ptr<ZeroCurve>(new ZeroCurve(exDivDates, dividendYields, \nActualActual(), calendar));\n\n} \n```", "```\n #include <cstdlib>\n#include <iostream>\n#include <ql/quantlib.hpp>\n#define BOOST_AUTO_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n#include <boost/detail/lightweight_test.hpp>\n#include <boost/format.hpp>\n#include <boost/assign/std/vector.hpp>\n\nusing namespace QuantLib;\n\nBOOST_AUTO_TEST_CASE(testAmericanOptionPricingWithDividends) {\n\n    using namespace boost::assign;\n\n    //set up calendar/dates\n    Calendar calendar = UnitedStates(UnitedStates::NYSE);\n    Date today(15, Nov, 2013);\n    Real settlementDays = 2;\n    Date settlement = calendar.advance(today, settlementDays, Days);\n    Settings::instance().evaluationDate() = today;\n\n    //define options to price\n    Option::Type type(Option::Call);\n    Real underlying = 24.52;\n\n    // INTC Feb 21 strikes\n    std::vector strikes;\n    strikes += 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0;\n\n    // volatility for each strike above\n    std::vector vols;\n    vols += .23356, .21369, .20657, .20128, .19917, .19978, .20117;\n\n    // Feb 2014 expiration      \n    Date expiration(21, Feb, 2014);\n\n    //INTC dividend information - .90 per year paid quarterly\n    Date exDivDate(5, Feb, 2014);\n    Real annualDividend = .90;\n\n    //build yield term structure from LIBOR rates \n    Handle<YieldTermStructure> yieldTermStructure(bootstrapLiborZeroCurve(today));\n\n    //build dividend term structure\n    Handle<YieldTermStructure> dividendTermStructure(bootstrapDividendCurve(today, \nexpiration, exDivDate, underlying, annualDividend));\n\n    //build vol term structure \n    Handle<BlackVolTermStructure> volatilityTermStructure(bootstrapVolatilityCurve(today, \nstrikes, vols, expiration));\n\n    //instantiate BSM process\n    Handle<Quote> underlyingH(boost::shared_ptr(new SimpleQuote(underlying)));\n    boost::shared_ptr<BlackScholesMertonProcess> bsmProcess(new BlackScholesMertonProcess(underlyingH, \ndividendTermStructure, yieldTermStructure, volatilityTermStructure));\n\n    //instantiate pricing engine\n    boost::shared_ptr<PricingEngine> pricingEngine(new FDAmericanEngine<CrankNicolson>\n(bsmProcess, 801, 800));\n\n    //price the options\n    boost::shared_ptr<Exercise> americanExercise(new AmericanExercise(settlement, expiration));\n    for (Real strike: strikes) {\n        boost::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(type, strike));\n\tVanillaOption americanOption(payoff, americanExercise);\n\tamericanOption.setPricingEngine(pricingEngine);\n\tReal tv = americanOption.NPV();\n\tstd::cout << boost::format(\"Intel %s %.2f %s value is: %.2f\") % \nexpiration % strike % type % tv  << std::endl;\n\tstd::cout << boost::format(\"Delta: %.4f\") % americanOption.delta() << std::endl;\n\tstd::cout << boost::format(\"Gamma: %.4f\") % americanOption.gamma() << std::endl;\n     }\n} \n```"]