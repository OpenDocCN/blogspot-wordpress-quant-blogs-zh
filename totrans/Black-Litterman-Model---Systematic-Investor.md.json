["```\n\n# load Systematic Investor Toolbox\nsetInternet2(TRUE)\nsource(gzcon(url('https://github.com/systematicinvestor/SIT/raw/master/sit.gz', 'rb')))\n\n\t#--------------------------------------------------------------------------\n\t# Visualize Market Capitalization History\n\t#--------------------------------------------------------------------------\n\n\thist.caps = aa.test.hist.capitalization()\t\n\thist.caps.weight = hist.caps/rowSums(hist.caps)\n\n\t# Plot Transition of Market Cap Weights in time\n\tplot.transition.map(hist.caps.weight, index(hist.caps.weight), xlab='', name='Market Capitalization Weight History')\n\n\t# Plot History for each Country's Market Cap\n\tlayout( matrix(1:9, nrow = 3, byrow=T) )\n\tcol = plota.colors(ncol(hist.caps))\n\tfor(i in 1:ncol(hist.caps)) {\n\t\tplota(hist.caps[,i], type='l', lwd=5, col=col[i], main=colnames(hist.caps)[i])\n\t}\n\n```", "```\n\n# Use reverse optimization to compute the vector of equilibrium returns\nbl.compute.eqret <- function\n(\n\trisk.aversion, \t# Risk Aversion\n\tcov, \t\t# Covariance matrix\n\tcap.weight, \t# Market Capitalization Weights\n\trisk.free = 0\t# Rsik Free Interest Rate\n)\n{\n\treturn( risk.aversion * cov %*% cap.weight +  risk.free)\t\n}\n\n\t#--------------------------------------------------------------------------\n\t# Compute Risk Aversion, prepare Black-Litterman input assumptions\n\t#--------------------------------------------------------------------------\n\tia = aa.test.create.ia.country()\n\n\t# compute Risk Aversion\n\trisk.aversion = bl.compute.risk.aversion( ia$hist.returns$USA )\n\n\t# the latest market capitalization weights\n\tcap.weight = last(hist.caps.weight)\t\n\n\t# create Black-Litterman input assumptions\t\n\tia.bl = ia\n\tia.bl$expected.return = bl.compute.eqret( risk.aversion, ia$cov, cap.weight )\n\n\t# Plot market capitalization weights and implied equilibrium returns\n\tlayout( matrix(c(1,1,2,3), nrow=2, byrow=T) )\n\tpie(coredata(cap.weight), paste(colnames(cap.weight), round(100*cap.weight), '%'), \n\t\tmain = paste('Country Market Capitalization Weights for', format(index(cap.weight),'%b %Y'))\n\t\t, col=plota.colors(ia$n))\n\n\tplot.ia(ia.bl, T)\n\n```", "```\n\n\t#--------------------------------------------------------------------------\n\t# Create Efficient Frontier(s)\n\t#--------------------------------------------------------------------------\n\tn = ia$n\n\n\t# -1 <= x.i <= 1\n\tconstraints = new.constraints(n, lb = 0, ub = 1)\n\n\t# SUM x.i = 1\n\tconstraints = add.constraints(rep(1, n), 1, type = '=', constraints)\t\t\n\n\t# create efficient frontier(s)\n\tef.risk = portopt(ia, constraints, 50, 'Historical', equally.spaced.risk = T)\t\t\n\tef.risk.bl = portopt(ia.bl, constraints, 50, 'Black-Litterman', equally.spaced.risk = T)\t\n\n\t# Plot multiple Efficient Frontiers and Transition Maps\n\tlayout( matrix(1:4, nrow = 2) )\n\tplot.ef(ia, list(ef.risk), portfolio.risk, T, T)\t\t\t\n\tplot.ef(ia.bl, list(ef.risk.bl), portfolio.risk, T, T)\t\t\t\n\n```", "```\n\nbl.compute.posterior <- function\n(\n\tmu, \t\t# Equilibrium returns\n\tcov, \t\t# Covariance matrix\n\tpmat=NULL, \t# Views pick matrix\n\tqmat=NULL, \t# Views mean vector\n\ttau=0.025 \t# Measure of uncertainty of the prior estimate of the mean returns\n)\n{\n\tout = list()\t\n\tomega = diag(c(1,diag(tau * pmat %*% cov %*% t(pmat))))[-1,-1]\n\n\ttemp = solve(solve(tau * cov) + t(pmat) %*% solve(omega) %*% pmat)\t\n\tout$cov = cov + temp\n\n\tout$expected.return = temp %*% (solve(tau * cov) %*% mu + t(pmat) %*% solve(omega) %*% qmat)\n\treturn(out)\n}\n\n\t#--------------------------------------------------------------------------\n\t# Create Views\n\t#--------------------------------------------------------------------------\n\ttemp = matrix(rep(0, n), nrow = 1)\n\t\tcolnames(temp) = ia$symbols\n\n\t# Relative View\n\t# Japan will outperform UK by 2%\n\ttemp[,'Japan'] = 1\n\ttemp[,'UK'] = -1\n\n\tpmat = temp\n\tqmat = c(0.02)\n\n\t# Absolute View\n\t# Australia's expected return is 12%\n\ttemp[] = 0\n\ttemp[,'Australia'] = 1\n\n\tpmat = rbind(pmat, temp)\t\n\tqmat = c(qmat, 0.12)\n\n\t# compute posterior distribution parameters\n\tpost = bl.compute.posterior(ia.bl$expected.return, ia$cov, pmat, qmat, tau = 0.025 )\n\n\t# create Black-Litterman input assumptions with Views\t\n\tia.bl.view = ia.bl\n\t\tia.bl.view$expected.return = post$expected.return\n\t\tia.bl.view$cov = post$cov\n\t\tia.bl.view$risk = sqrt(diag(ia.bl.view$cov))\n\n\t# create efficient frontier(s)\n\tef.risk.bl.view = portopt(ia.bl.view, constraints, 50, 'Black-Litterman + View(s)', equally.spaced.risk = T)\t\n\n\t# Plot multiple Efficient Frontiers and Transition Maps\n\tlayout( matrix(1:4, nrow = 2) )\n\tplot.ef(ia.bl, list(ef.risk.bl), portfolio.risk, T, T)\t\t\t\n\tplot.ef(ia.bl.view, list(ef.risk.bl.view), portfolio.risk, T, T)\t\t\t\n\n```"]