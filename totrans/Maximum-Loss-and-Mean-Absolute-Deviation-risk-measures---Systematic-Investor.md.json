["```\n\nmin.maxloss.portfolio <- function\n(\n\tia,\t\t# input assumptions\n\tconstraints\t# constraints\n)\n{\n\tn = ia$n\n\tnt = nrow(ia$hist.returns)\n\n\t# objective : maximum loss, w\n\tf.obj = c( rep(0, n), 1)\n\n\t# adjust constraints, add w\n\tconstraints = add.variables(1, constraints)\n\n\t#  - [ SUM <over i> r.ij * x.i ] < w, for each j = 1,...,T \n\ta = rbind( matrix(0, n, nt), 1)\n\t\ta[1 : n, ] = t(ia$hist.returns)\n\tconstraints = add.constraints(a, rep(0, nt), '>=', constraints)\n\n\t# setup linear programming\t\n\tf.con = constraints$A\n\tf.dir = c(rep('=', constraints$meq), rep('>=', len(constraints$b) - constraints$meq))\n\tf.rhs = constraints$b\n\n\t# find optimal solution\n\tx = NA\n\tsol = try(solve.LP.bounds('min', f.obj, t(f.con), f.dir, f.rhs, \n\t\t\t\t\t\t\tlb = constraints$lb, ub = constraints$ub), TRUE)\n\n\tif(!inherits(sol, 'try-error')) {\n\t\tx = sol$solution[1:n]\n\n\t}\n\n\treturn( x )\n}\n\n```", "```\n\nmin.mad.portfolio <- function\n(\n\tia,\t\t# input assumptions\n\tconstraints\t# constraints\n)\n{\n\tn = ia$n\n\tnt = nrow(ia$hist.returns)\n\n\t# objective : Mean-Absolute Deviation (MAD)\n\t# 1/T * [ SUM  (u+.j + u-.j) ]\n\tf.obj = c( rep(0, n), (1/nt) * rep(1, 2 * nt) )\n\n\t# adjust constraints, add u+.j, u-.j\n\tconstraints = add.variables(2 * nt, constraints, lb = 0)\n\n\t# [ SUM <over i> r.ij * x.i ] - 1/T * [ SUM <over j> [ SUM <over i> r.ij * x.i ] ] = u+.j - u-.j , for each j = 1,...,T \n\ta = rbind( matrix(0, n, nt), -diag(nt), diag(nt))\n\t\ta[1 : n, ] = t(ia$hist.returns) - repmat(colMeans(ia$hist.returns), 1, nt)\n\tconstraints = add.constraints(a, rep(0, nt), '=', constraints)\t\t\t\n\n\t# setup linear programming\t\n\tf.con = constraints$A\n\tf.dir = c(rep('=', constraints$meq), rep('>=', len(constraints$b) - constraints$meq))\n\tf.rhs = constraints$b\n\n\t# find optimal solution\n\tx = NA\n\tsol = try(solve.LP.bounds('min', f.obj, t(f.con), f.dir, f.rhs, \n\t\t\t\t\t\t\tlb = constraints$lb, ub = constraints$ub), TRUE)\n\n\tif(!inherits(sol, 'try-error')) {\n\t\tx = sol$solution[1:n]\n\t}\n\n\treturn( x )\n}\n\n```", "```\n\n###############################################################################\n# Create Efficient Frontier\n###############################################################################\n\tn = ia$n\n\n\t# 0 <= x.i <= 0.8 \n\tconstraints = new.constraints(n, lb = 0, ub = 0.8)\n\n\t# SUM x.i = 1\n\tconstraints = add.constraints(rep(1, n), 1, type = '=', constraints)\n\n\t# create efficient frontier(s)\n\tef.risk = portopt(ia, constraints, 50, 'Risk')\n\tef.maxloss = portopt(ia, constraints, 50, 'Max Loss', min.maxloss.portfolio)\n\tef.mad = portopt(ia, constraints, 50, 'MAD', min.mad.portfolio)\n\n\t# Plot multiple Efficient Frontiers\n\tlayout( matrix(1:4, nrow = 2) )\n\tplot.ef(ia, list(ef.risk, ef.maxloss, ef.mad), portfolio.risk, F)\n\tplot.ef(ia, list(ef.risk, ef.maxloss, ef.mad), portfolio.maxloss, F)\n\tplot.ef(ia, list(ef.risk, ef.maxloss, ef.mad), portfolio.mad, F)\n\n\t# Plot multiple Transition Maps\n\tlayout( matrix(1:4, nrow = 2) )\n\tplot.transition.map(ef.risk)\n\tplot.transition.map(ef.maxloss)\n\tplot.transition.map(ef.mad)\n\n```"]