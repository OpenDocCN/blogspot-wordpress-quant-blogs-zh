["```\n#include<ql\\quantlib.hpp>\n#include <iostream>\n\nusing namespace QuantLib;\n\n#if defined(QL_ENABLE_SESSIONS)\nnamespace QuantLib {\n\n    Integer sessionId() { return 0; }\n}\n#endif\n\nint main(int, char* []) {\n\n    try {\n\n\t\t// Calendar set up\n\t\tCalendar calendar = TARGET();\n\t\tDate todaysDate(5, February, 2011);\n\t\tSettings::instance().evaluationDate() = todaysDate;\n\n\t\t// Option parameters\n\t\tOption::Type optionType(Option::Put);\n\t\tAverage::Type averageType = Average::Geometric;\n\t\tReal strike = 40;\n\t\tReal underlying = 38;\n\t\tRate riskFreeRate = 0.05;\n\t\tVolatility volatility = 0.20;\n\t\tSpread dividendYield = riskFreeRate-(0.5*volatility*volatility);\n\t\tDate maturity (10, December, 2011);\n\t\tDayCounter dayCounter = Actual365Fixed();\n\t\tReal runningSum = 1.0;\n\t\tSize pastFixings = 0;\n\t\tstd::vector<Date> fixingDates;\n\t\tfor (Date incrementedDate=todaysDate+7; incrementedDate<=maturity; incrementedDate += 7)\n\t\t\tfixingDates.push_back(incrementedDate);\n\n\t\t// Option exercise type\n\t\tboost::shared_ptr<Exercise> europeanExercise(\n\t\t\tnew EuropeanExercise(\n\t\t\tmaturity));\n\n\t\t// Quote handling\n\t\tHandle<Quote> underlyingH(\n\t\t\tboost::shared_ptr<Quote>(\n\t\t\tnew SimpleQuote(\n\t\t\tunderlying)));\n\n\t\t// Yield term structure handling\n\t\tHandle<YieldTermStructure> flatTermStructure(\n\t\t\tboost::shared_ptr<YieldTermStructure>(\n\t\t\tnew FlatForward(\n\t\t\ttodaysDate,\n\t\t\triskFreeRate,\n\t\t\tdayCounter)));\n\n\t\t// Dividend term structure handling\n\t\tHandle<YieldTermStructure> flatDividendTermStructure(\n\t\t\tboost::shared_ptr<YieldTermStructure>(\n\t\t\tnew FlatForward(\n\t\t\ttodaysDate,\n\t\t\tdividendYield,\n\t\t\tdayCounter)));\n\n\t\t// Volatility structure handling\n\t\tHandle<BlackVolTermStructure> flatVolTermStructure(\n\t\t\tboost::shared_ptr<BlackVolTermStructure>(\n\t\t\tnew BlackConstantVol(\n\t\t\ttodaysDate,\n\t\t\tcalendar,\n\t\t\tvolatility,\n\t\t\tdayCounter)));\n\n\t\t// the BS equation behind\n\t\tboost::shared_ptr<BlackScholesMertonProcess> bsmProcess(\n\t\t\tnew BlackScholesMertonProcess(\n\t\t\tunderlyingH,\n\t\t\tflatDividendTermStructure,\n\t\t\tflatTermStructure,\n\t\t\tflatVolTermStructure));\n\n\t\t// Payoff\n\t\tboost::shared_ptr<StrikedTypePayoff> payoffAsianOption (\n\t\t\tnew PlainVanillaPayoff(\n\t\t\tOption::Type(optionType),\n\t\t\tstrike));\n\n\t\t// Discretely-averaged Asian option\n\t\tDiscreteAveragingAsianOption discreteAsianAverageOption(\n\t\t\taverageType,\n\t\t\trunningSum,\n\t\t\tpastFixings,\n\t\t\tfixingDates,\n\t\t\tpayoffAsianOption,\n\t\t\teuropeanExercise);\n\n\t\t// Pricing engine\n\t\tdiscreteAsianAverageOption.setPricingEngine(\n\t\tboost::shared_ptr<PricingEngine>(\n\t\tnew AnalyticDiscreteGeometricAveragePriceAsianEngine(\n\t\tbsmProcess)));\n\n\t\t// Ouputting on the screen\n\t\tstd::cout << \"Option type = \" << optionType << std::endl;\n\t\tstd::cout << \"Option maturity = \" << maturity << std::endl;\n\t\tstd::cout << \"Underlying  = \" << underlying << std::endl;\n\t\tstd::cout << \"Strike = \" << strike << std::endl;\n\t\tstd::cout << \"Risk-free interest rate = \" <<  std::setprecision(2) << io::rate(riskFreeRate) << std::endl;\n\t\tstd::cout << \"Dividend yield = \" << std::setprecision(2) << io::rate(dividendYield) << std::endl;\n\t\tstd::cout << \"Volatility = \" <<  std::setprecision(2) << io::volatility(volatility) << std::endl;\n\t\tstd::cout << \"Time-length between successive fixings = weekly time step\" << std::endl;\n\t\tstd::cout << \"Previous fixings = \" << pastFixings << std::endl;\n\t\tstd::cout << std::endl;\n\t\tstd::cout << \"Option price : \" << discreteAsianAverageOption.NPV() << std::endl;\n\n\t\tsystem(\"pause\");\n\t\treturn 0;\n\n\t\t} \n\t\tcatch (std::exception& e)\n\t\t{\n\t\tstd::cerr << e.what() << std::endl;\n\t\treturn 1;\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\tstd::cerr << \"unknown error\" << std::endl;\n\t\treturn 1;\n\t\t}\n}\n```"]