["```\n\n# load Systematic Investor Toolbox\nsetInternet2(TRUE)\nsource(gzcon(url('https://github.com/systematicinvestor/SIT/raw/master/sit.gz', 'rb')))\n\nload.packages('quantmod')\n\n# load historical prices from Yahoo Finance\nsymbols = spl('SPY,QQQ,EEM,IWM,EFA,TLT,IYR,GLD')\nsymbol.names = spl('S&P 500,Nasdaq 100,Emerging Markets,Russell 2000,EAFE,20 Year\nTreasury,U.S. Real Estate,Gold')\n\ngetSymbols(symbols, from = '1980-01-01', auto.assign = TRUE)\n\n# align dates for all symbols & convert to monthly\nhist.prices = merge(SPY,QQQ,EEM,IWM,EFA,TLT,IYR,GLD)\n\tmonth.ends = endpoints(hist.prices, 'months')\n\thist.prices = Cl(hist.prices)[month.ends, ]\n\tcolnames(hist.prices) = symbols\n\n# remove any missing data\nhist.prices = na.omit(hist.prices['1995::2010'])\n\n# compute simple returns\nhist.returns = na.omit( ROC(hist.prices, type = 'discrete') )\n\n```", "```\n\n# compute historical returns, risk, and correlation\nia = list()\nia$expected.return = apply(hist.returns, 2, mean, na.rm = T)\nia$risk = apply(hist.returns, 2, sd, na.rm = T)\nia$correlation = cor(hist.returns, use = 'complete.obs', method = 'pearson')\n\nia$symbols = symbols\nia$symbol.names = symbol.names\nia$n = len(symbols)\nia$hist.returns = hist.returns\n\n# convert to annual, year = 12 months\nannual.factor = 12\nia$expected.return = annual.factor * ia$expected.return\nia$risk = sqrt(annual.factor) * ia$risk\n\n# compute covariance matrix\nia$risk = iif(ia$risk == 0, 0.000001, ia$risk)\nia$cov = ia$cor * (ia$risk %*% t(ia$risk))\n\n```", "```\n\n# visualize input assumptions\nplot.ia(ia)\n\n# display each asset in the Risk - Return plot\nlayout(1)\npar(mar = c(4,4,2,1), cex = 0.8)\nx = 100 * ia$risk\ny = 100 * ia$expected.return\n\nplot(x, y, xlim = range(c(0, x)), ylim = range(c(0, y)),\n\txlab='Risk', ylab='Return', main='Risk vs Return', col='black')\ngrid();\ntext(x, y, symbols,\tcol = 'blue', adj = c(1,1), cex = 0.8)\n\n```", "```\n\n# Create Efficient Frontier\nn = ia$n\n\n# 0 <= x.i <= 0.8 \nconstraints = new.constraints(n, lb = 0, ub = 0.8)\n\n# SUM x.i = 1 ( total portfolio weight = 100%)\nconstraints = add.constraints(rep(1, n), 1, type = '=', constraints)\n\n# create efficient frontier consisting of 50 portfolios\nef = portopt(ia, constraints, 50, 'Sample Efficient Frontier')\n\n# plot efficient frontier\nplot.ef(ia, list(ef))\n\n```", "```\n\nportopt <- function\n(\n\tia,\t\t\t\t# Input Assumptions\n\tconstraints = NULL,\t\t# Constraints\n\tnportfolios = 50,\t\t# Number of portfolios\n\tname = 'Risk',\t\t\t# Name\n\tmin.risk.fn = min.risk.portfolio\t# Risk Measure\n)\n{\n\t# set up output \n\tout = list(weight = matrix(NA, nportfolios, ia$n))\n\t\tcolnames(out$weight) = ia$symbols\t\t\n\n\t# find maximum return portfolio\t\n\tout$weight[1, ] = max.return.portfolio(ia, constraints)\n\n\t# find minimum risk portfolio\n\tout$weight[nportfolios, ] = match.fun(min.risk.fn)(ia, constraints)\t\n\n\t# find points on efficient frontier\n\tout$return = portfolio.return(out$weight, ia)\n\ttarget = seq(out$return[1], out$return[nportfolios], length.out = nportfolios)\n\n\tconstraints = add.constraints(ia$expected.return, target[1], type = '=', constraints)\n\n\tfor(i in 2:(nportfolios - 1) ) {\n\t\tconstraints$b[1] = target[i]\n\t\tout$weight[i, ] = match.fun(min.risk.fn)(ia, constraints)\n\t}\n\n\t# compute risk / return\n\tout$return = portfolio.return(out$weight, ia)\n\tout$risk = portfolio.risk(out$weight, ia)\n\tout$name = name\n\n\treturn(out)\t\t\t\n}\n\n```"]