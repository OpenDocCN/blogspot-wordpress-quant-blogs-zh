["```\n #include <iostream> \n#include <cstdlib>\n#define BOOST_AUTO_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n#include <boost/detail/lightweight_test.hpp>\n#include <ql/quantlib.hpp>\n#include <boost/format.hpp>\n#include <boost/math/distributions.hpp>\n#include <boost/function.hpp>\n\nnamespace {\n\nusing namespace QuantLib;\n\nReal expectedValueCallPayoff(Real spot, Real strike,\n        Rate r, Volatility sigma, Time t, Real x) {\n    Real mean = log(spot)+(r - 0.5 * sigma * sigma) * t;\n    Real stdDev = sigma * sqrt(t);\n    boost::math::lognormal d(mean, stdDev);\n    return [PlainVanillaPayoff](http://quantlib.org/reference/class_quant_lib_1_1_plain_vanilla_payoff.html)(Option::Type::Call, strike)(x) * boost::math::pdf(d, x);\n}\n\nBOOST_AUTO_TEST_CASE(testPriceCallOption) {\n    Real spot = 100.0; //current price of the underlying stock (S)\n    Rate r = 0.03; //risk-free rate\n    Time t = 0.5;  //half a year\n    Volatility vol = 0.20; //estimated volatility of underlying\n    Real strike = 110.0; // strike price of the call (K)\n\n    //b need not be infinity, but can just be a large number that is improbable\n    Real a = strike, b = strike * 10.0;\n\n    boost::function< Real(Real) > ptrToExpectedValueCallPayoff = \n        boost::bind(&expectedValueCallPayoff, spot, strike, r, vol, t, _1);\n\n    Real absAcc = 0.00001;\n    Size maxEval = 1000;\n    SimpsonIntegral numInt(absAcc, maxEval); \n\n    /* numerically integrate the call option payoff function from a to b and\n     * calculate the present value using the risk free rate as the discount factor\n     */ \n    Real callOptionValue = numInt(ptrToExpectedValueCallPayoff, a, b) * std::exp(-r * t); \n\n    std::cout << \"Call option value is: \" << callOptionValue << std::endl;\n}}\n```"]