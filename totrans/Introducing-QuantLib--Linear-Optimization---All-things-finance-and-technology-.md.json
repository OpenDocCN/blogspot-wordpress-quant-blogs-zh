["```\n#include <cstdlib>\n#include <iostream>\n#define BOOST_AUTO_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n#include <boost/detail/lightweight_test.hpp>\n#include <ql/quantlib.hpp>\n#include <vector>\n#include <boost/format.hpp>\n#include <functional>\n#include <function>\n\nnamespace {\n\nusing namespace QuantLib;\n\n//objective function to be maximized\nclass PortfolioAllocationCostFunction: public CostFunction {\n\npublic:\n//must override this member function\nReal value(const Array& x) const {\n    QL_REQUIRE(x.size()==2, \"Two bonds in portfolio!\");\n    return -1 * (4*x[0] + 3*x[1]); //mult by -1 to maximize \n}\n//must override this member function\nDisposable values(const Array& x) const {\n    QL_REQUIRE(x.size()==2, \"Two bonds in portfolio!\");\n    Array values(1);\n    values[0] = value(x);\n};  \n\n//aggregates all constraint expressions into a single constraint\nclass PortfolioAllocationConstraints : public Constraint {\n\npublic:\n\nPortfolioAllocationConstraints(const std::vector<std::function >& expressions)  : Constraint(boost::shared_ptr<Constraint::Impl>(new\n    PortfolioAllocationConstraints::Impl(expressions))) {}\n\nprivate:\n// constraint implementation\nclass Impl : public Constraint::Impl {\npublic:\n\nImpl(const std::vector<std::function >& expressions) :\n    expressions_(expressions) {}\n\nbool test(const Array& x) const {\n    for (auto iter = expressions_.begin(); \n    iter < expressions_.end(); ++iter) {\n        if (!(*iter)(x)) {\n            return false;\n        }\n    }\n    //will only get here if all constraints satisfied\n    return true;\n}\n\nprivate:\n\nconst std::vector<std::function > expressions_;        \n};\n}; \n\nBOOST_AUTO_TEST_CASE(testLinearOptimization) {\n    PortfolioAllocationCostFunction portfolioAllocationCostFunction;\n\n    //optimization constraints\t\n    std::vector<std::function >  constraints(3);\n\n    //constraints implemented as C++11 lambda expressions\n    constraints[0]=[](const Array& x) {return (x[0]+x[1] <= 100.0);}; \n    constraints[1]=[](const Array& x) {return ((2*x[0]+x[1])/100.0    <= 1.5);}; \n    constraints[2]=[](const Array& x) {return ((3*x[0]+4*x[1])/100.0 <= 3.6);};\n\n    //instantiate constraints\n    PositiveConstraint greaterThanZeroConstraint;\n    PortfolioAllocationConstraints portfolioAllocationConstraints(constraints);\n    //class that supports functional composition of constraints\n    CompositeConstraint allConstraints(portfolioAllocationConstraints,greaterThanZeroConstraint);\n\n    //end criteria that will terminate search \n    Size maxIterations = 1000;  //end search after 1000 iterations if no solution\n    Size minStatIterations = 10; //don't spend more than 10 iterations at a single point\n    Real rootEpsilon = 1e-8; //end search if absolute difference of current and last root value is below epsilon\n    Real functionEpsilon = 1e-9; //end search if absolute difference of current and last function value is below epsilon\n    Real gradientEpsilon = 1e-5; //end search if absolute difference of norm of current and last gradient is below epsilon\n\n    EndCriteria endCriteria(maxIterations, minStatIterations, rootEpsilon, functionEpsilon, gradientEpsilon);\n\n    Problem bondAllocationProblem(portfolioAllocationCostFunction, allConstraints, Array(2, 1));\n\n    //use the Simplex method \n    Simplex solver(.1);\n\n    //if the algorithm is able to locate an optimal solution, it will stop searching at a stationary point in\n    //the search space\n    EndCriteria::Type solution = solver.minimize(bondAllocationProblem, endCriteria);\n    std::cout << boost::format(\"Simplex solution type: %s\") % solution<< std::endl;\n\n    const Array& results = bondAllocationProblem.currentValue();\n    std::cout << boost::format(\"Allocate %.2f percent to bond 1 and %.2f percent to bond 2.\") % results[0] % results[1] << std::endl;  \n\n}\n}\n```"]