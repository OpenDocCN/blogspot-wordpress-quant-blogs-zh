["```\n #include <iostream>\n#include <cstdlib>\n#define BOOST_AUTO_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n#include <boost/detail/lightweight_test.hpp>\n#include <ql/quantlib.hpp>\n#include <boost/format.hpp>\n\nnamespace {\n\nusing namespace QuantLib;\n\nBOOST_AUTO_TEST_CASE(testBlackScholes) {\nReal strike = 110.0;\nReal timeToMaturity = .5; //years\nReal spot = 100.0;\nRate riskFree = .03;\nRate dividendYield = 0.0;\nVolatility sigma = .20;\n\n//QuantLib requires sigma * sqrt(T) rather than just sigma/volatility\nReal vol = sigma * std::sqrt(timeToMaturity);\n\n//calculate dividend discount factor assuming continuous compounding (e^-rt)\nDiscountFactor growth = std::exp(-dividendYield * timeToMaturity);\n\n//calculate payoff discount factor assuming continuous compounding \nDiscountFactor discount = std::exp(-riskFree * timeToMaturity);\n\n//instantiate payoff function for a call \nboost::shared_ptr<[PlainVanillaPayoff](http://quantlib.org/reference/class_quant_lib_1_1_plain_vanilla_payoff.html)> vanillaCallPayoff = \n    boost::shared_ptr<PlainVanillaPayoff>(new PlainVanillaPayoff(Option::Type::Call, strike));\n\nBlackScholesCalculator bsCalculator(vanillaCallPayoff, spot, growth, vol, discount);\nstd::cout << boost::format(\"Value of 110.0 call is %.4f\") % bsCalculator.value() << std::endl;\nstd::cout << boost::format(\"Delta of 110.0 call is %.4f\") % bsCalculator.delta() << std::endl;\nstd::cout << boost::format(\"Gamma of 110.0 call is %.4f\") % bsCalculator.gamma() << std::endl;\nstd::cout << boost::format(\"Vega of 110.0 call is %.4f\") % bsCalculator.vega(timeToMaturity)/100 << std::endl;\nstd::cout << boost::format(\"Theta of 110.0 call is %.4f\") % (bsCalculator.thetaPerDay(timeToMaturity)) << std::endl;\n\nReal changeInSpot = 1.0;\nBlackScholesCalculator bsCalculatorSpotUpOneDollar(Option::Type::Call, strike, spot + changeInSpot, growth, vol, discount);\nstd::cout << boost::format(\"Value of 110.0 call (spot up $%d) is %.4f\") % changeInSpot % bsCalculatorSpotUpOneDollar.value() << std::endl;\nstd::cout << boost::format(\"Value of 110.0 call (spot up $%d) estimated from delta is %.4f\") % changeInSpot % (bsCalculator.value() + bsCalculator.delta() * changeInSpot) << std::endl;\n\n//use a Taylor series expansion to estimate the new price of a call given delta and gamma\nstd::cout << boost::format(\"Value of 110.0 call (spot up $%d) estimated from delta and gamma is %.4f\") % changeInSpot % (bsCalculator.value() + (bsCalculator.delta() * changeInSpot) + (.5 * bsCalculator.gamma() * changeInSpot)) << std::endl;\n\n//calculate new price of a call given a one point change in volatility\nReal changeInSigma = .01;\nBlackScholesCalculator bsCalculatorSigmaUpOnePoint(Option::Type::Call, strike, spot, growth, (sigma + changeInSigma) * std::sqrt(timeToMaturity) , discount);\nstd::cout << boost::format(\"Value of 110.0 call (sigma up %.2f) is %.4f\") % changeInSigma % bsCalculatorSigmaUpOnePoint.value() << std::endl;\n\n//estimate new price of call given one point change in volatility using vega\nstd::cout << boost::format(\"Value of 110.0 call (sigma up %.2f) estimated from vega) is %.4f\") % changeInSigma % (bsCalculator.value() + (bsCalculator.vega(timeToMaturity)/100)) << std::endl;\n}}\n```"]