- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-18 05:11:03'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Magmasystems Blog: A Comment from Gemstone'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://magmasystems.blogspot.com/2007/03/comment-from-gemstone.html#0001-01-01](http://magmasystems.blogspot.com/2007/03/comment-from-gemstone.html#0001-01-01)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Ocassionally, someone will make an important comment to a post I made several
    months ago. Such is the case now ... Jags from Gemstone replies:'
  prefs: []
  type: TYPE_NORMAL
- en: '*You have hit the nail on the head. At GemStone, we recognized early on that
    a distributed cache that supports notifications has no choice but to ensure that
    object change notifications can reliably reach consumers. Else, it pretty much
    becomes useless.* **There are many considerations we took into account:-* **Applications
    are sharing data through a p2p cache and the cache supports dynamic membership
    - i.e members can come and go at any time. Great from a scalability perspective,
    but what happens when you have apps connected to the peer cache expecting notifications
    and a peer node generating the events suddenly departs? In GemFire, we introduced
    a declarative means to ensure that messages are received by all critical members
    - each producer or consumer can play one or more roles; A publisher only succeeds
    if the roles that are required are available. If this interest you, checkout section
    3.2 here* *[*http://developer.gemstone.com/display/gfedev/Topologies+and+Architectures+for+Middle-Tier+Caching*](http://developer.gemstone.com/display/gfedev/Topologies+and+Architectures+for+Middle-Tier+Caching)*-***In
    the scenario you mention - clients connected to a logical cache - we also support
    asynchronous reliable notifications through in-memory replication of the queues
    on the cache servers. The challenge here is to ensure in order delivery of events,
    detecting the failure conditions, automatic client failover to the server managing
    the secondary queue and avoiding duplicate notifications. And, given that there
    might be a local cache on the client, the server side can further optimize transmission
    to the client by merely propagating a object "delta".***One important reason why
    financial institutions like the whole "caching + messaging" story is because now
    you enable applications to connect to a distributed object repository that gives
    pub-sub semantics, but all the contextual data required by the application to
    make instantenous decisions is available in memory.*'
  prefs: []
  type: TYPE_NORMAL
- en: ©2007 Marc Adler - All Rights Reserved*****
  prefs: []
  type: TYPE_NORMAL
