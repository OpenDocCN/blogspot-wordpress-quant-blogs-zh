["```\n/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/*\n Copyright (C) 2015, Edouard 'tagoma' Tallent\n Copyright (C) 2006, 2007 Ferdinando Ametrano\n Copyright (C) 2006 Katiuscia Manzoni\n Copyright (C) 2006 Joseph Wang\n\n This file is part of QuantLib, a free-software/open-source library\n for financial quantitative analysts and developers - http://quantlib.org/\n\n QuantLib is free software: you can redistribute it and/or modify it\n under the terms of the QuantLib license.  You should have received a\n copy of the license along with this program; if not, please email\n <quantlib-dev@lists.sf.net>. The license is also available online at\n <http://quantlib.org/license.shtml>.\n\n This program is distributed in the hope that it will be useful, but WITHOUT\n ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n FOR A PARTICULAR PURPOSE.  See the license for more details.\n*/\n\n/*! \\file prices.hpp\n    \\brief price classes\n*/\n\n#ifndef quantlib_prices_hpp\n#define quantlib_prices_hpp\n\n#include <ql/timeseries.hpp>\n#include <ql/utilities/null.hpp>\n\nnamespace QuantLib {\n\n    //! Price types\n    enum PriceType {\n         Bid,          /*!< Bid price. */\n         Ask,          /*!< Ask price. */\n         Last,         /*!< Last price. */\n         Close,        /*!< Close price. */\n         Mid,          /*!< Mid price, calculated as the arithmetic\n                            average of bid and ask prices. */\n         MidEquivalent, /*!< Mid equivalent price, calculated as\n                            a) the arithmetic average of bid and ask prices\n                            when both are available; b) either the bid or the\n                            ask price if any of them is available;\n                            c) the last price; or d) the close price. */\n         MidSafe       /*!< Safe Mid price, returns the mid price only if\n                            both bid and ask are available. */\n    };\n\n    /*! return the MidEquivalent price, i.e. the mid if available,\n        or a suitable substitute if the proper mid is not available\n    */\n    Real midEquivalent(const Real bid,\n                       const Real ask,\n                       const Real last,\n                       const Real close);\n\n    /*! return the MidSafe price, i.e. the mid only if\n        both bid and ask prices are available\n    */\n    Real midSafe(const Real bid,\n                 const Real ask);\n\n    //! interval price\n    class IntervalPrice {\n      public:\n        enum Type { Open, High, Low, Close };\n\n        IntervalPrice();\n        IntervalPrice(Real open, Real high, Real low, Real close);\n        //! \\name Inspectors\n        //@{\n        Real open() const { return open_; }\n        Real high() const { return high_; }\n        Real low() const { return low_; }\n        Real close() const { return close_; }\n        Real value(IntervalPrice::Type) const;\n        //@}\n\n        //! \\name Modifiers\n        //@{\n        void setValue(Real value, IntervalPrice::Type);\n        void setValues(Real open, Real high, Real low, Real close);\n        //@}\n\n        //! \\name Helper functions\n        //@{\n        static TimeSeries makeSeries(\n            const std::vector& d,\n            const std::vector& open,\n            const std::vector& high,\n            const std::vector& low,\n            const std::vector& close);\n\n        static std::vector extractValues(\n                                          const TimeSeries&,\n                                          IntervalPrice::Type);\n        static TimeSeries extractComponent(\n                                          const TimeSeries&,\n                                          enum IntervalPrice::Type);\n        //@}\n      private:\n          Real open_, high_, low_, close_;\n    };\n\n    template <>\n    class Null \n    {\n      public:\n        Null() {}\n        operator IntervalPrice() const { return IntervalPrice(); }\n    };\n\n}\n\n#endif\n\n```", "```\n/*\nCopyright (C) 2015, Edouard 'tagoma' Tallent\nOHLC timeseries factory based on QuantLib \nQuantCorner @ https://quantcorner.wordpress.com\n*/\n\n#include <fstream>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <memory>\n#include <ql\\quantlib.hpp>\n#include <boost\\algorithm\\string\\split.hpp>\n#include <boost\\algorithm\\string\\classification.hpp>\n\n// Wrapper creating a QuantLib OHLC time series from *.csv file\nQuantLib::TimeSeries<QuantLib::IntervalPrice> QL_OHLC(char *filename){\n    std::ifstream file(filename);\n    std::string line;\n    std::vector<QuantLib::Real> open, close, high, low;\n    std::vector<QuantLib::Date> dates;\n    std::vector<std::string> tokens;\n    QuantLib::TimeSeries<QuantLib::IntervalPrice> ochl;\n\n    while (std::getline(file, line))\n    {\n        std::stringstream stringStream(line);\n        std::string content;\n        int item = 0;\n        while (std::getline(stringStream, content, ',')) {\n            switch (item) {\n            case 0:\n                boost::algorithm::split(tokens, content, boost::algorithm::is_any_of(\"/\"));\n                dates.push_back(QuantLib::Date(QuantLib::Day(std::stoi(tokens.at(0))),\n                    QuantLib::Month(std::stoi(tokens.at(1))),\n                    QuantLib::Year(std::stoi(tokens.at(2)))));\n                break;\n            case 1: open.push_back(std::stod(content)); break;\n            case 2: close.push_back(std::stod(content)); break;\n            case 3: high.push_back(std::stod(content)); break;\n            case 4: low.push_back(std::stod(content)); break;\n            }\n            item++;\n        }\n    }\n    return QuantLib::IntervalPrice::makeSeries(dates, open, high, low, close);\n}\n\nauto main(int argc, char *argv []) -> int\n{\n    // Function call\n    char* file = argv[1];\n    QuantLib::TimeSeries<QuantLib::IntervalPrice> ohlc = QL_OHLC(file);\n\n    // Start date of the time series\n    std::cout << \"Start date: \" << ohlc.firstDate() << std::endl;\n\n    // Is the time series empty?\n    std::cout << \"Time series empty (1:Yes; 0:No): \"\n        << ohlc.empty() << std::endl;\n\n    // Return the number of dates/time series length\n    std::cout << \"Series length (number of time steps): \"\n        << ohlc.size() << std::endl;\n\n    // Access the OHLC values\n    std::vector<QuantLib::IntervalPrice> v;\n    for (auto i : ohlc)\n        v.push_back(i.second);\n        std::cout << \"\\nOpen\\tHigh\\tLow\\tClose\" << std::endl;\n    for (auto i : v)\n        std::cout << i.open() << \"\\t\" << i.high() << \"\\t\" << i.low()\n        << \"\\t\" << i.close() << std::endl;\n    std::cout << \"\\n\";\n\n    // Etc ....\n\n    return 0;\n}\n\n/*\n/////////////////////////\n/ Demo datafile (*.csv) /\n/////////////////////////\n11/05/2015,51.18,51.99,51.06,51.21\n12/05/2015,51.64,52.12,51.24,51.95\n13/05/2015,50.61,51.80,50.47,51.64\n14/05/2015,50.61,50.67,50.00,50.27\n15/05/2015,49.55,50.91,49.54,50.91\n18/05/2015,48.68,49.50,48.51,48.95\n19/05/2015,48.42,49.04,48.01,48.68\n20/05/2015,48.83,49.19,48.00,48.52\n21/05/2015,48.54,48.96,47.69,48.45\n22/05/2015,49.31,49.40,48.19,48.64\n25/05/2015,49.34,50.22,49.03,49.63\n26/05/2015,48.28,48.79,47.84,48.33\n27/05/2015,47.97,48.86,47.31,47.66\n28/05/2015,49.12,49.19,47.55,48.06\n29/05/2015,51.21,51.37,50.57,51.16\n01/06/2015,51.52,51.58,51.03,51.20\n02/06/2015,52.30,52.39,51.52,51.52\n*/\n\n/*\n//////////////////\n/ Program output /\n//////////////////\nStart date : May 11th, 2015\nTime series empty(1:Yes; 0:No) : 0\nSeries length(number of time steps) : 17\n\nOpen    High    Low     Close\n51.18   51.99   51.06   51.21\n51.64   52.12   51.24   51.95\n50.61   51.8    50.47   51.64\n50.61   50.67   50      50.27\n49.55   50.91   49.54   50.91\n48.68   49.5    48.51   48.95\n48.42   49.04   48.01   48.68\n48.83   49.19   48      48.52\n48.54   48.96   47.69   48.45\n49.31   49.4    48.19   48.64\n49.34   50.22   49.03   49.63\n48.28   48.79   47.84   48.33\n47.97   48.86   47.31   47.66\n49.12   49.19   47.55   48.06\n51.21   51.37   50.57   51.16\n51.52   51.58   51.03   51.2\n52.3    52.39   51.52   51.52\n\nPress any key to continue . . .\n*/\n\n```"]