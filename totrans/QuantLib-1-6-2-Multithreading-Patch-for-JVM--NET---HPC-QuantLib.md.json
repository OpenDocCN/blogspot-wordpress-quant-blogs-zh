["```\nweak_ptr<T> weak_from_this() noexcept;\n\n```", "```\nclass Observer : public boost::enable_shared_from_this<Observer> {\n          friend class Observable;\n  public:\n    // public interface remains untouched\n\n    virtual ~Observer() {\n        boost::lock_guard<boost::recursive_mutex> lock(mutex_);\n        if (proxy_) {\n            proxy_->deactivate();\n\n            for (iterator i=observables_.begin(); \n                 i!=observables_.end(); ++i) \n                (*i)->unregisterObserver(proxy_);\n        }\n    }\n  private:\n    class Proxy {\n      public:\n        Proxy(Observer* const observer)\n         : active_  (true),\n           observer_(observer) {\n        }\n\n        void update() const {\n            boost::lock_guard<boost::recursive_mutex> lock(mutex_);\n            if (active_) {\n                const boost::weak_ptr<Observer> o\n                    = observer_->weak_from_this();\n                if (!o._empty()) {\n                    boost::shared_ptr<Observer> obs(o.lock());\n                    if (obs)\n                        obs->update();\n                }\n                else {\n                    observer_->update();\n                }\n            }\n        }\n\n        void deactivate() {\n            boost::lock_guard<boost::recursive_mutex> lock(mutex_);\n            active_ = false;\n        }\n\n    private:\n        bool active_;\n        mutable boost::recursive_mutex mutex_;\n        Observer* const observer_;\n    };\n\n    boost::shared_ptr<Proxy> proxy_;\n    mutable boost::recursive_mutex mutex_;\n\n    std::set<boost::shared_ptr<Observable> > observables_;\n    typedef std::set<boost::shared_ptr >::iterator \n        iterator;\n};\n```"]