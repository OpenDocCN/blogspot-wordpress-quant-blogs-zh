["```\n\nrequire(\"tseries\")\nrequire(\"vrtest\")\nrequire(\"fSeries\")\n\ncolors <- c('black', 'red', 'blue', 'green', 'orange', 'purple', 'yellow', 'brown', 'pink', 'coral', 'cyan', 'darkgreen', 'darkred' ,'darkblue', 'darkgrey');\n\nexploreProxyHedge <- function(p, doMonthlyScatter=TRUE, freq=\"daily\", doQuantilePlots=TRUE)\n{\n  # Plot various proxy hedge exploratory analysis.\n  #\n  # Args:\n  #   p: matrix of instrument price data, including valid colnames\n  #   doMonthlyScatter: flag indicating whether monthly scatter should\n  #           be plotted\n  #   freq: text string for frequency, used for graphing\n  #   doQuantilePlots: flag indicating whether quantiles should be plotted\n  #\n  # Returns: None\n\n  oldpar <- par(mfrow=c(2,2))\n\n  # discrete first differences (not logged)\n  pROC <- ROC(p, type=\"discrete\", na.pad=FALSE)\n  p1ROC <- ROC(p[,1], type=\"discrete\", na.pad=FALSE)\n  p2ROC <- ROC(p[,2], type=\"discrete\", na.pad=FALSE)\n\n  # scatter analysis\n  plot(coredata(p[,2]), coredata(p[,1]), xlab=colnames(p)[2], ylab=colnames(p)[1], main=\"Prices\")\n  plm <- lm(p[,1] ~ p[,2])\n  abline(plm, col=colors[2], lty=2)\n  mtext(text=paste(\"slope=\",plm$coefficients[2]), side=3, cex=0.75, col=colors[2])\n\n  plot(coredata(p1ROC), coredata(p2ROC), xlab=colnames(p)[2], ylab=colnames(p)[1], main=\"Returns\")\n  rlm <- lm(p1ROC ~ p2ROC)\n  abline(rlm, col=colors[2], lty=2)\n    par(xpd=TRUE)\n    d <- dataEllipse(as.vector(coredata(p1ROC)),as.vector(coredata(p2ROC)),draw=FALSE)\n    lines(d[[1]], col=colors[2], lty=3)\n    lines(d[[2]], col=colors[3], lty=3)\n    par(xpd=FALSE)\n  mtext(text=paste(\"slope=\",rlm$coefficients[2]), side=3, cex=0.75, col=colors[2])\n\n  # split positive/negative scatter analysis\n  plot(coredata(p2ROC[(coredata(p1ROC)>0)]), coredata(p1ROC[(coredata(p1ROC)>0)]), xlab=colnames(p)[2], ylab=paste(colnames(p)[1], \"(Positive Only)\"), xlim=c(min(p2ROC),max(p2ROC)), ylim=c(min(p1ROC),max(p1ROC)), main=\"Split Sign Return Scatter\")\n  prlm <- lm(coredata(p1ROC[(coredata(p1ROC)>0)]) ~ coredata(p2ROC[(coredata(p1ROC)>0)]))\n  abline(prlm, col=colors[1], lty=2)\n  points(coredata(p2ROC[(coredata(p1ROC)<0)]), coredata(p1ROC[(coredata(p1ROC)<0)]), xlab=colnames(p)[2], ylab=paste(colnames(p)[1], \"(Negative Only)\"), col='red')\n  nrlm <- lm(coredata(p1ROC[(coredata(p1ROC)<0)]) ~ coredata(p2ROC[(coredata(p1ROC)<0)]))\n  abline(nrlm, col=colors[2], lty=2)\n  abline(rlm, col=colors[3], lty=2)\n  legend(\"topleft\",legend=c(\"Positive\", \"Negative\", \"Both\"), fill=colors, cex=0.5)\n\n  # split magnitude scatter analysis\n  magBound <- sd(p1ROC) / 2\n  plot(coredata(p2ROC[(abs(coredata(p2ROC))>=magBound)]), coredata(p1ROC[(abs(coredata(p2ROC))>=magBound)]), xlab=colnames(p)[2], ylab=paste(colnames(p)[1], \"(Positive Only)\"), xlim=c(min(p2ROC),max(p2ROC)), ylim=c(min(p1ROC),max(p1ROC)), main=\"Split Magnitude Return Scatter (0.5 SD)\")\n  orlm <- lm(coredata(p1ROC[(abs(coredata(p2ROC))>=magBound)]) ~ coredata(p2ROC[(abs(coredata(p2ROC))>=magBound)]))\n  abline(orlm, lty=2)\n  points(coredata(p2ROC[(abs(coredata(p2ROC))<magBound)]), coredata(p1ROC[(abs(coredata(p2ROC))<magBound)]), xlab=colnames(p)[2], ylab=paste(colnames(p)[1], \"(Positive Only)\"), xlim=c(min(p2ROC),max(p2ROC)), ylim=c(min(p1ROC),max(p1ROC)), main=\"Split Magnitude Return Scatter\", col=colors[2])\n  irlm <- lm(coredata(p1ROC[(abs(coredata(p2ROC))<magBound)]) ~ coredata(p2ROC[(abs(coredata(p2ROC))<magBound)]))\n  abline(irlm, lty=2, col=colors[2])\n  legend(\"topleft\", legend=c(\"Outer\", \"Inner (+/- 0.5 SD)\"), fill=colors, cex=0.5)\n\n  # monthly scatter analysis\n  if (doMonthlyScatter)\n  {\n    plot(coredata(xts(p)[\"2011-05\"][,2]), coredata(xts(p)[\"2011-05\"][,1]), ylim=c(min(p[,1]),max(p[,1])), xlim=c(min(p[,2]),max(p[,2])), col=colors[1], xlab=colnames(p)[2], ylab=colnames(p)[1], main=\"Prices by Month\")\n    points(coredata(xts(p)[\"2011-06\"][,2]), coredata(xts(p)[\"2011-06\"][,1]), col=colors[2])\n    points(coredata(xts(p)[\"2011-07\"][,2]), coredata(xts(p)[\"2011-07\"][,1]), col=colors[3])\n    points(coredata(xts(p)[\"2011-08\"][,2]), coredata(xts(p)[\"2011-08\"][,1]), col=colors[4])\n    points(coredata(xts(p)[\"2011-09\"][,2]), coredata(xts(p)[\"2011-09\"][,1]), col=colors[5])\n    points(coredata(xts(p)[\"2011-10\"][,2]), coredata(xts(p)[\"2011-10\"][,1]), col=colors[6])\n    legend(\"topleft\", legend=c(\"05\", \"06\", \"07\", \"08\", \"09\", \"10\"), fill=colors, cex=0.5)\n    abline(lm(coredata(xts(p)[\"2011-05\"][,1]) ~ coredata(xts(p)[\"2011-05\"][,2])), col=colors[1], lty=2)\n    abline(lm(coredata(xts(p)[\"2011-06\"][,1]) ~ coredata(xts(p)[\"2011-06\"][,2])), col=colors[2], lty=2)\n    abline(lm(coredata(xts(p)[\"2011-07\"][,1]) ~ coredata(xts(p)[\"2011-07\"][,2])), col=colors[3], lty=2)\n    abline(lm(coredata(xts(p)[\"2011-08\"][,1]) ~ coredata(xts(p)[\"2011-08\"][,2])), col=colors[4], lty=2)\n    abline(lm(coredata(xts(p)[\"2011-09\"][,1]) ~ coredata(xts(p)[\"2011-09\"][,2])), col=colors[5], lty=2)\n  }\n\n  # quantile plots\n  if (doQuantilePlots)\n  {\n    qqplot(coredata(p2ROC), coredata(p1ROC), xlab=paste(colnames(p)[2], \"Returns Quantiles\"), ylab=paste(colnames(p)[1], \"Returns Quantiles\"), main=\"Empirical Returns QQ-Plot\")\n    abline(0,1,lty=2)\n    grid(20)\n    par(xpd=TRUE)\n    d <- dataEllipse(as.vector(coredata(p1ROC)),as.vector(coredata(p2ROC)),draw=FALSE)\n    lines(d[[1]], col=colors[2], lty=3)\n    lines(d[[2]], col=colors[3], lty=3)\n    par(xpd=FALSE)\n  }\n\n  # Price lag dependence\n  lag.plot(p1ROC, 9, do.lines=FALSE, main=paste(colnames(p)[1], \"Returns Lag Auto Dependence\"))\n\n  lag.plot(p2ROC, 9, do.lines=FALSE, main=paste(colnames(p)[2], \"Returns Lag Auto Dependence\"))\n\n  par(mfrow=c(2,2))\n\n  # return distributions\n  p1Density <- density(p1ROC)\n  p2Density <- density(p2ROC)\n\n  plot(p1Density, ylim=c(0, max(p1Density$y, p2Density$y)), main=\"Return Distribution With Median\")\n  lines(p2Density, col=colors[2])\n  abline(v=median(p1ROC), lty=2)\n  abline(v=median(p2ROC), col=colors[2], lty=2)\n  legend(\"topleft\", legend=colnames(p), fill=colors, cex=0.5)\n\n  # cross correlation\n  ccf(data.frame(abs(coredata(p1ROC))), data.frame(abs(coredata(p2ROC))), main=\"Absolute Return Cross Correlation\")\n\n  # diff ratio analysis (exclude periods with zero return QQQ)\n  p1NoZeros <- diff(p[(p[,2] != 0),])\n  p5NoZeros <- diff(p, lag=5)\n  p5NoZeros <- p5NoZeros[(p5NoZeros[,2] != 0),]\n  p22NoZeros <- diff(p, lag=22)\n  p22NoZeros <- p22NoZeros[(p22NoZeros[,2] != 0),]\n\n  diff1Ratio <- p1NoZeros[,1] / p1NoZeros[,2]\n  diff5Ratio <- p5NoZeros[,1] / p5NoZeros[,2]\n  diff22Ratio <- p22NoZeros[,1] / p22NoZeros[,2]\n\n  plot(diff22Ratio, main=\"Difference Ratios\", ylab=\"Diff Ratio\", xlab=\"\")\n  lines(diff5Ratio, col=colors[2])\n  lines(diff1Ratio, col=colors[3])            \n  legend(\"topright\", legend=c(\"lag-22\", \"lag-5\", \"lag-1\"), fill=colors, cex=0.5)\n\n  # ROC analysis\n  plot(xts(p1ROC), ylab=\"ROC\", xlab=\"\", main=\"Return Rate of Change\")\n  lines(xts(p2ROC), col=colors[2])\n  legend(\"topleft\", legend=colnames(p), fill=colors, cex=0.5)\n\n  # variance ratio analysis\n  vratio <- sd(p[,1]) / sd(p[,2])\n  cat(paste(\"variance ratio:\", round(vratio,2)),\"\\n\")\n\n  vRatio5 <- rollingVarianceRatio(p,5)\n  vRatio10 <- rollingVarianceRatio(p,10)\n\n  np <- nrow(p)\n  vRatio22 <- c()\n  vRatio60 <- c()\n  if (np > 22)\n  {\n    vRatio22 <- rollingVarianceRatio(p,22)\n    if (np > 60)\n    {\n      vRatio60 <- rollingVarianceRatio(p,60)\n    }\n  }\n\n  par(mfrow=c(2,1))\n  plot(vRatio5, type='l', xlab=\"\", ylab=\"VR\", main=\"Rolling Variance Ratio\", ylim=c(min(vRatio5, vRatio10,vRatio22,vRatio60), max(vRatio5, vRatio10,vRatio22,vRatio60)))\n  lines(vRatio10, col=colors[2])\n\n  if (np > 22)\n  {\n    lines(vRatio22, col=colors[3])\n    if(np > 60)\n    {\n      lines(vRatio60, col=colors[4])\n    }\n  }\n  legend(\"topleft\", legend=c(\"5\", \"10\", \"22\", \"60\"), fill=colors, cex=0.5)\n\n  # correlation analysis\n  vCorr5 <- rollingCorrelation(pROC, 5)\n  vCorr10 <- rollingCorrelation(pROC, 10)\n\n  vCorr22 <- c()\n  vCorr60 <- c()\n  if (np > 22)\n  {\n    vCorr22 <- rollingCorrelation(pROC, 22)\n    if (np > 60)\n    {\n      vCorr60 <- rollingCorrelation(pROC, 60)\n    }\n  }\n\n  plot(vCorr5, type='l', xlab=\"\", ylab=\"Correlation\", main=\"Rolling Correlation\", ylim=c(min(vCorr5, vCorr10,vCorr22,vCorr60), max(vCorr5, vCorr10,vCorr22,vCorr60)))\n  lines(vCorr10, col=colors[2])\n\n  if (np > 22)\n  {\n    lines(vCorr22, col=colors[3])\n    if (np > 60)\n    {\n      lines(vCorr60, col=colors[4])\n    }\n  }\n  legend(\"topleft\", legend=c(\"5\", \"10\", \"22\", \"60\"), fill=colors, cex=0.5)\n\n  # classic variance ratios (unstandardized)\n  VR.plot(p1ROC,60)\n  VR.plot(p2ROC,60)\n\n  par(oldpar)\n}\n\nrollingVarianceRatio <- function(p, winLen)\n{\n  # Calculate rolling variance ratio with a given window length\n  #\n  # Args:\n  #   p: matrix of instrument price data, including valid colnames\n  #   winLen: length of window over which to calculate variance\n  #\n  # Returns: xts of rolling variance ratio\n\n  return (xts(sapply(c(1:(nrow(p)-winLen)), function(i) { sd(p[i:(i+winLen),1]) / sd(p[i:(i+winLen),2]) }), order.by=index(p[((winLen+1):nrow(p)),])))\n}\n\nrollingCorrelation <- function(p, winLen)\n{\n  # Calculate rolling correlation with a given window length\n  #\n  # Args:\n  #   p: matrix of instrument price data, including valid colnames\n  #   winLen: length of window over which to calculate correlation\n  #\n  # Returns: xts of rolling correlation\n\n  return (xts(sapply(c(1:(nrow(p)-winLen)), function(i) { cor(p[i:(i+winLen)], method=\"kendall\")[2,1] }), order.by=index(p[((winLen+1):nrow(p)),])))\n}\n\n```"]