["```\n  // A random data set which uses stockQuote.newPrice to get each data point\n  var stockHistory: Queue[java.lang.Double] = {\n    lazy val initialPrices: Stream[java.lang.Double] = (new Random().nextDouble * 800) #:: initialPrices.map(previous => stockQuote.newPrice(previous))\n    initialPrices.take(50).to[Queue]\n  }\n\n  // Fetch the latest stock value every 75ms\n  val stockTick = context.system.scheduler.schedule(Duration.Zero, 75.millis, self, FetchLatest)\n\n```", "```\n\nclass TieredPricerSpec(_system: ActorSystem)\n  extends TestKit(_system)\n  with ImplicitSender\n  with ShouldMatchers\n  with FlatSpec\n  with BeforeAndAfterAll {\n\n  def this() = this(ActorSystem(\"LiquidityManagementSpec\"))\n\n  override def afterAll: Unit = {\n    system.shutdown()\n    system.awaitTermination(10.seconds)\n  }\n\n  \"An TieredPricer\" should \"be able to store a price\" in {\n    val actor = TestActorRef(Props[TieredPricer])\n    actor ! CorePrice(\"GBPUSD\", 1.5)\n    actor.underlyingActor.asInstanceOf[TieredPricer].prices(\"GBPUSD\") should be(1.5)\n  }\n\n  it should \"be able to store two price\" in {\n    val actor = TestActorRef(Props[TieredPricer])\n    actor ! CorePrice(\"GBPUSD\", 1.5)\n    actor ! CorePrice(\"GBPEUR\", 1.15)\n    actor.underlyingActor.asInstanceOf[TieredPricer].prices(\"GBPUSD\") should be(1.5)\n    actor.underlyingActor.asInstanceOf[TieredPricer].prices(\"GBPEUR\") should be(1.15)\n  }\n\n  it should \"be able able to provide a price given an RFQ\" in {\n    val actor = TestActorRef(Props[TieredPricer])\n    actor ! CorePrice(\"USDEUR\", 1.15)\n    actor ! RFQ(\"USDEUR\")\n    expectMsgType[TieredPrice].price should be(1.15)\n  }\n}\n\n```"]