["```\n\nhmmFit <- HMMFit(val, nStates=numOfStates)\nfb <- forwardBackward(hmmFit, val)\neu <- exp(fb$Alpha + fb$Beta - fb$LL)\n\n```", "```\n\nlibrary(\"RHmm\")\nlibrary(\"TTR\")\n\ndisplayKritzmanRegimes <- function()\n{\n  # Display regimes from Kritzman et al. (2012), printing regime\n  # statistics and plotting local decoding.\n\n  equityRegime <- getEquityTurbulenceRegime()\n  inflationRegime <- getInflationRegime()\n  growthRegime <- getGrowthRegime()\n  currencyTurbulenceRegime <- getCurrencyTurbulenceRegime()\n\n  print(equityRegime)\n  print(inflationRegime)\n  print(growthRegime)\n  print(currencyTurbulenceRegime)\n\n  plotMarkovRegimes(equityRegime, \"Equity (SPX)\", plotDensity=F)\n  plotMarkovRegimes(inflationRegime, \"Inflation (CPIAUCNS)\", plotDensity=F)\n  plotMarkovRegimes(growthRegime, \"Real GDP (GDPC1)\", plotDensity=F)\n  plotMarkovRegimes(currencyTurbulenceRegime, \"G10 Currency Turbulence\", \n                    plotDensity=F)\n\n  plotLocalDecodings(list(equityRegimeTurbulence, growthRegime, inflationRegime, \n                          currencyTurbulenceRegime),\n                     list(\"US Equity (SPX)\", \"Real GDP (GDPC1)\", \n                          \"Inflation (CPIAUCNS)\",\"G10 Currency Turbulence\"),\n                     regimeNums=c(2,2,2,2))\n}\n\ngetEquityTurbulenceRegime <- function(startDate=as.Date(\"1977-12-01\"), \n                                      endDate=Sys.Date(), numOfStates=2)\n{\n  # Estimate two-state markov (SPX-based) equity regime. In lieu of S&P 500\n  # sector indices, use SPX instead.\n  #\n  # Args:\n  #     startDate: date which to begin panel for regime estimation\n  #     endDate: end which to end panel for regime estimation\n  #     numOfStates: number of hidden states in regime\n  # \n  # Returns: hmmFit from HMMFit(), suitable for display with plotMarkovRegime()\n\n  spx <- dROC(getOhlcv(instrumentSymbol=\"^GSPC\", startDate=startDate, \n                              endDate=endDate, quote=c(\"close\")))\n  spxTurb <- rollingTurbulence(spx, avgWidth=(250 * 10), \n                                    covarWidth=(250 * 10))\n  meanTurb <- apply.monthly(spxTurb, mean)\n  estimateMarkovRegimes(meanTurb, numOfStates=numOfStates)\n}\n\ngetInflationRegime <- function(startDate=as.Date(\"1946-01-01\"), endDate=Sys.Date(),\n                               numOfStates=2)\n{\n  # Estimate two-state markov (CPI-based) inflation regime.\n  #\n  # Args:\n  #     startDate: date which to begin panel for regime estimation\n  #     endDate: end which to end panel for regime estimation\n  #     numOfStates: number of hidden states in regime\n  # \n  # Returns: hmmFit from HMMFit(), suitable for display with plotMarkovRegime()\n\n  val <- 100 *dROC(getFREDData(symbol=\"CPIAUCNS\", startDate=startDate, \n                               endDate=endDate))\n  estimateMarkovRegimes(val, numOfStates=numOfStates)\n}\n\ngetGrowthRegime <- function(startDate=as.Date(\"1946-01-01\"), \n                            endDate=as.Date(\"2012-12-31\"), numOfStates=2)\n{\n  # Estimate two-state markov (GDP-based) growth regime.\n  #\n  # Note: Growth regime appears to be bi-modal, and thus need to estimate\n  # several times to get convergence on the regime reported by Kritzman.\n  #\n  # Args:\n  #     startDate: date which to begin panel for regime estimation\n  #     endDate: end which to end panel for regime estimation\n  #     numOfStates: number of hidden states in regime\n  # \n  # Returns: hmmFit from HMMFit(), suitable for display with plotMarkovRegime()\n\n  val <- 100 * dROC(getFREDData(symbol=\"GDPC1\", startDate=startDate, \n                                endDate=endDate))\n  estimateMarkovRegimes(val, numOfStates=numOfStates)\n}\n\ngetCurrencyTurbulenceRegime <- function(startDate=as.Date(\"1971-01-01\"), \n                                        endDate=Sys.Date(), \n                                        numOfStates=2)\n{\n  # Estimate two-state markov (G10-based) currency turbulence regime.\n  #\n  # Args:\n  #     startDate: date which to begin panel for regime estimation\n  #     endDate: end which to end panel for regime estimation\n  #     numOfStates: number of hidden states in regime\n  # \n  # Returns: hmmFit from HMMFit(), suitable for display with plotMarkovRegime()\n\n  g10rates <- getG10Currencies()\n  avgg10rates <- xts(100 * rowMeans(dROC(g10rates), na.rm=T), \n                     order.by=last(index(g10rates), -1))\n  turbG10rates <- rollingTurbulence(avgg10rates, avgWidth=(250 * 3), \n                                    covarWidth=(250 * 3))\n  meanTurbG10rates <- apply.monthly(turbG10rates, mean)\n\n  estimateMarkovRegimes(meanTurbG10rates, numOfStates=numOfStates)\n}\n\nestimateMarkovRegimes <- function(val, numOfStates=2)\n{\n  # Estimate n-state hidden markov model (HMM) for val.\n  #\n  # Args:\n  #     val: series\n  #     numOfStates: number of hidden states in HMM\n  #\n  # Returns: hmmFit from HMMFit(), suitable for display with plotMarkovRegime()\n\n  hmmFit <- HMMFit(val, nStates=numOfStates)\n  return (list(val=val, hmmFit=hmmFit))\n}\n\nplotLocalDecodings <- function(regimes, symbols, plotDateRange=\"1900::2012\", \n                             regimeNums)\n{\n  # Plot local decodings for a list of HMM regimes, optionally over a set\n  # date range.\n  #\n  # Args:\n  #     regimes: list of regimes, as returned by estimateMarkovRegimes()\n  #     symbols: list of human-readable symbols for regimes\n  #     plotDateRange: option date over which to plot regime local decodings\n  #     regimeNums: index of HMM regime, into regimes, to plot\n\n  oldpar <- par(mfrow=c(1,1))\n  on.exit(par(oldpar))\n\n  layout(c(1,2,3,4))\n\n  # generate merge of local decodings\n  localList <- lapply(c(1:length(regimes)), function(i) {\n\n    regime <- regimes[[i]]\n    fb <- forwardBackward(regime$hmmFit, regime$val)\n    eu <- exp(fb$Alpha + fb$Beta - fb$LL)\n    local <- xts(eu[,regimeNums[i]], index(regime$val))[plotDateRange]\n\n    plota(local, type='l', plotX=T, col=drawColors[i], main=symbols[i])\n  })\n}\n\nplotMarkovRegimes <- function(regime, symbol, plotDateRange=\"1900::2012\",\n                              plotDensity=T, plotTimeSeries=T)\n{\n  # Plot markov regimes from HMM: kernel densities and per-regime local decodings.\n  #\n  # Args:\n  #     hmmFit: fit for HMM, as generated by estimateMarkovRegimes()\n  #     symbol: human-readable description of series with markov regimes\n  #     plotDateRange: contiguous range of time which to plot\n\n  val <- regime$val\n  hmmFit <- regime$hmmFit\n\n  # calculate local decoding\n  fb <- forwardBackward(hmmFit, val)\n  eu <- exp(fb$Alpha + fb$Beta - fb$LL)\n  hmmMeans <- hmmFit$HMM$distribution$mean\n  hmmSD <- sqrt(hmmFit$HMM$distribution$var)\n\n  # plot kernel density with regime means\n  oldpar <- par(mfrow=c(1,1))\n  on.exit(par(oldpar))\n\n  if (plotDensity)\n  {\n    plot(density(val), main=paste(\"Density with Regime Means:\", symbol))\n    abline(v=mean(val), lty=2)\n\n    sapply(c(1:length(hmmMeans)), function(i) {\n      abline(v=hmmMeans[i], lty=2, col=drawColors[(i+1)])\n      curve(dnorm(x, hmmMeans[i], hmmSD[i]), add=T, lty=3,\n            col=drawColors[(i+1)])\n    })\n  }\n\n  # Plot time series of percent change and local decoding for each regime\n  if (plotTimeSeries)\n  {\n    merged <- merge(val, eu)\n    layout(c(1:(1+ncol(eu))))\n\n    plota(merged[,1][plotDateRange], type='l', paste(\"Regime:\", symbol), plotX=F)\n    sapply(c(1:length(hmmMeans)), function(i) {\n      abline(h=hmmMeans[i], lty=2, col=drawColors[(i+1)])\n    })\n    plota.legend(\"Percent Change:\", drawColors[1], last(merged[,1]))\n\n    sapply(c(1:ncol(eu)), function(i) {\n\n      plota(xts(merged[,(i+1)], index(val))[plotDateRange], type='l', \n            plotX=(i==(ncol(eu))),\n            col=drawColors[(i+1)])\n      plota.legend(paste0(\"Event Regime \", i, \":\"), drawColors[(i+1)], \n                   last(merged[,(i+1)]))\n    })\n  }\n}\n\ndROC <- function(x, n=1)\n{\n  # Return discrete rate-of-change (ROC) for a series, without padding\n  ROC(x, n, type=\"discrete\", na.pad=F)\n}\n\n```"]