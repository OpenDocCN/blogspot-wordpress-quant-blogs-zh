["```\nlibrary(gbm)\nlibrary(doParallel)\nlibrary(reshape2)\n\n#trn <- read.csv(\"E:/Kaggle/Winton/train.csv\") # 40k X 211\n#tst <- read.csv(\"E:/Kaggle/Winton/test_2.csv\") #120k X 147\n\ntrn <- readRDS(\"E:/Kaggle/Winton/trn.rds\"); tst <- readRDS(\"E:/Kaggle/Winton/tst.rds\")\n\ninterp <- function(x){\nx <- as.numeric(x)\nif(is.na(x[1])) x[1] <- x[!is.na(x)][1]\n#if(is.na(x[length(x)])) x[length(x)] <- x[length(x)-1]\nxsub <- x[2:length(x)]\n#gap.na <- which(is.na(xsub))\n\nfor(k in 2:length(xsub)){\nif(is.na(xsub[k])) xsub[k] <- xsub[k-1] \n}\nx <- c(x[1],xsub)\nreturn(x)\n\n}\ndisc.impute <- function(x){\n\nxfactor <- levels(factor(x))\nx[is.na(x)] <- sample(xfactor,length(which(is.na(x))),replace=TRUE)\n\nreturn(as.numeric(x))\n}\ncont.impute <- function(x){\n\nx[is.na(x)] <-\nrunif(length(which(is.na(x))),\nmin(range(na.omit(x))),max(range(na.omit(x))))\n\nreturn(x)\n}\ngenerate.folds <- function(idx, k){\n\nfold.idx <- holdout <- kfold <- list()\nfold.len <- floor(length(idx)/k) # if idx does not divide evenly ignore last few observations\n\nfor(i in 1:(k-1)){\nholdout[[i]] <- sample(idx[!(idx%in%unlist(holdout))],fold.len)\nkfold[[i]] <- idx[!(idx%in%holdout[[i]])]\n}\nholdout[[k]] <- idx[!(idx%in%unlist(holdout))]\nkfold[[k]] <- idx[!(idx%in%holdout[[k]])]\n\nfolds <- list(kfold,holdout)\nnames(folds) <- c('trn','val')\n\nreturn(folds)\n}\nqlimiter <- function(x,qlim) {\nifelse(x < quantile(x,(1-qlim),na.rm=TRUE),quantile(x,(1-qlim),na.rm=TRUE),ifelse(\nx > quantile(x,qlim,na.rm=TRUE),quantile(x,qlim,na.rm=TRUE),x))\n}\nfeat.dist.sel <- function(mx,my,pth){\nout <- 0\nfor(i in 1:dim(mx)[2]){\nout[i] <- t.test(mx[,i],my[i])$p.value\n}\nsel <- which(out > pth)\nreturn(sel)\n}\ninterp.med <- function(x) {\nx[is.na(x)] <- median(na.omit(x)); x\n}\n\n# column breakpoints\nf1 <- 2; f25 <- 26; tsiis1 <- 27; tsiis2 <- 147; tsoos1 <- 148; tsoos2 <- 207;\ntsD1 <- 208; tsD2 <- 209;\nwtint <- 210; wtdly <- 211; trn.obs <- dim(trn)[1]; tst.obs <- dim(tst)[1];\nclip.th <- 0.9999\ndiscrete.features <- c(1,5,8,9,10,13,16,20)\ncontinuous.features <- c(2,3,4,6,7,11,12,14,15,17,18,19,21,22,23,24,25)\n\n# preprocess and clean data \nall.iis <- rbind(trn[,1:tsiis2], tst[,1:tsiis2])\n\nall.trn.iis.ts <- trn[,tsiis1:tsiis2]\nall.trn.oos.ts <- trn[,tsoos1:tsoos2]\nall.trn.oos.ts.cln <- apply(all.trn.oos.ts,2,interp.med)\n\nall.trn.oos.D1 <- trn[,tsD1]\nall.trn.oos.D2 <- trn[,tsD2]\nall.trn.oos.D1.clip <- qlimiter(all.trn.oos.D1,qlim=clip.th)\nall.trn.oos.D2.clip <- qlimiter(all.trn.oos.D2,qlim=clip.th)\n\nall.iis.ts <- all.iis[,tsiis1:tsiis2]\nall.tst.iis.ts <- all.iis.ts[(trn.obs+1):(trn.obs+tst.obs),]\n\nts.sel <- feat.dist.sel(all.trn.iis.ts,all.tst.iis.ts,pth=.05)\nall.iis.ts.sel <- all.iis.ts[,ts.sel]\n\nall.iis.ts.cln <- apply(all.iis.ts.sel,2,interp.med)\nall.trn.iis.ts.cln <- all.iis.ts.cln[1:trn.obs,]\nall.tst.iis.ts.cln <- all.iis.ts.cln[(trn.obs+1):(trn.obs+tst.obs),]\n\n# K FOLD CV\nfolds <- list(); n.fold <- 5\nfolds <- generate.folds(seq(dim(trn)[1]), n.fold)\n\n#gbmGrid <- expand.grid(interaction.depth = c(5,9,15), n.trees = seq(400,1000,by=200),\n#shrinkage = 0.1, n.minobsinnode = 50)\nout <- res  <- list()\ntune.par <- seq(10,200,10)\n\nfor(z in 1:length(tune.par)){\ncl <- makeCluster(n.fold)\nregisterDoParallel(cl)\n\nres <- list()\nrmcol = 0\n\nn.trees <- tune.par[z]\ninteraction.depth <- 1\nn.minobsinnode  <- 50\nshrinkage <- 0.1\n\nres <- foreach(k=1:n.fold, .combine=rbind) %dopar% \n{\n\nlibrary(gbm)\n\ntrn.fld <- folds$trn[[k]]\nval.fld <- folds$val[[k]]\n\n# Naive estimates use zero baseline as predictions\n\ntrn.iis <- all.trn.iis.ts.cln[trn.fld,] ; val.iis <- all.trn.iis.ts.cln[val.fld,] \ntrn.int.oos <- all.trn.oos.ts.cln[trn.fld,] ; val.int.oos <- all.trn.oos.ts.cln[val.fld,] \ntrn.day.D1 <- all.trn.oos.D1.clip[trn.fld] ; val.day.D1 <- all.trn.oos.D1.clip[val.fld]\ntrn.day.D2 <- all.trn.oos.D2.clip[trn.fld] ; val.day.D2 <- all.trn.oos.D2.clip[val.fld]\n\nwt.int.trn <- trn[trn.fld,wtint]; wt.int.val <- trn[val.fld,wtint]\nwt.day.trn <- trn[trn.fld,wtdly]; wt.day.val <- trn[val.fld,wtdly]\n\ntrn.zro <- rep(0,dim(trn.iis)[1]); #zero pred for intraday\nval.zro <- rep(0,dim(val.iis)[1]); #zero pred for intraday\ntrn.err.int <- wt.int.trn*abs(trn.int.oos-trn.zro) \nval.err.int <- wt.int.val*abs(val.int.oos-val.zro)\ntrn.err.D1 <- wt.day.trn*abs(trn.day.D1-trn.zro)\nval.err.D1 <- wt.day.val*abs(val.day.D1-val.zro)\ntrn.err.D2 <- wt.day.trn*abs(trn.day.D2-trn.zro)\nval.err.D2 <- wt.day.val*abs(val.day.D2-val.zro)\n\nWMAE.trn <- mean(c(as.matrix(trn.err.D1),as.matrix(trn.err.D2),as.matrix(trn.err.int))) #oos trn wmae\nWMAE.val <- mean(c(as.matrix(val.err.D1),as.matrix(val.err.D2),as.matrix(val.err.int))) #oos tst wmae\nWMAE.zro.all <- mean(c(WMAE.trn,WMAE.val))\n\n# feature selection and cleaning outliers\nall.feat  <- all.iis[,f1:f25]\nall.feat[,3] <- qlimiter(all.feat[,3],.9999)\nall.feat[,11] <- qlimiter(all.feat[,11],.9999)\ntrn.feat <- all.feat[trn.fld,]\nval.feat <- all.feat[val.fld,]\n\ntrn.day.1 <- data.frame(trn.feat,all.trn.iis.ts.cln[trn.fld,],all.trn.oos.D1.clip[trn.fld])\nnames(trn.day.1)[dim(trn.day.1)[2]]<-'D1'\ntrn.day.2 <- data.frame(trn.feat,all.trn.iis.ts.cln[trn.fld,],all.trn.oos.D2.clip[trn.fld])\nnames(trn.day.2)[dim(trn.day.2)[2]]<-'D2'\n\nval.day.1 <- data.frame(val.feat,all.trn.iis.ts.cln[val.fld,],all.trn.oos.D1.clip[val.fld])\nnames(val.day.1)[dim(val.day.1)[2]]<-'D1'\nval.day.2 <- data.frame(val.feat,all.trn.iis.ts.cln[val.fld,],all.trn.oos.D2.clip[val.fld])\nnames(val.day.2)[dim(val.day.2)[2]]<-'D2'\n\n# Build gbm models, here: use same ntrees for both D1,D2\ngbm.trn.mod.D1 <- gbm(D1 ~ .,data=trn.day.1,distribution=\"laplace\",  weights = wt.day.trn, \nn.trees=n.trees, interaction.depth=interaction.depth, shrinkage = shrinkage, n.minobsinnode =n.minobsinnode)\n\ngbm.trn.mod.D2 <- gbm(D2 ~ .,data=trn.day.2,distribution=\"laplace\", weights = wt.day.trn, \nn.trees=n.trees, interaction.depth=interaction.depth, shrinkage = shrinkage, n.minobsinnode =n.minobsinnode)\n\n# TRN fold predictions\n\ngbm.trn.pred.1 <- predict(gbm.trn.mod.D1, newdata=trn.day.1[,-dim(trn.day.1)[2]], \nn.trees=n.trees)\ngbm.trn.pred.2 <- predict(gbm.trn.mod.D2, newdata=trn.day.2[,-dim(trn.day.2)[2]], \nn.trees=n.trees)\ngbm.trn.act.1 <- all.trn.oos.D1[trn.fld] \ngbm.trn.act.2 <- all.trn.oos.D2[trn.fld] \n#par(mfrow=c(2,1))\n#plot(gbm.trn.pred.1~gbm.trn.act.1)\n#plot(gbm.trn.pred.2~gbm.trn.act.2)\n\ntrn.err.day.1 <- wt.day.trn*abs(gbm.trn.act.1 -gbm.trn.pred.1)\ntrn.err.day.2 <- wt.day.trn*abs(gbm.trn.act.2 -gbm.trn.pred.2)\ntrn.err.dly <- data.frame(trn.err.day.1,trn.err.day.2)\ntrn.err.int <- trn.err.int # from previous median estimates, wt.int.trn*abs(trn.int.oos-trn.med) \nWMAE.trn <- mean(c(as.matrix(trn.err.dly),as.matrix(trn.err.int)))\n\n# VAL fold predictions\n\ngbm.val.pred.1 <- predict(gbm.trn.mod.D1, newdata=val.day.1[,-dim(val.day.1)[2]], \nn.trees=n.trees, interaction.depth=interaction.depth, shrinkage = shrinkage, n.minobsinnode =n.minobsinnode)\ngbm.val.pred.2 <- predict(gbm.trn.mod.D2, newdata=val.day.2[,-dim(val.day.2)[2]], \nn.trees=n.trees, interaction.depth=interaction.depth, shrinkage = shrinkage, n.minobsinnode =n.minobsinnode)\ngbm.val.act.1 <- all.trn.oos.D1[val.fld] \ngbm.val.act.2 <- all.trn.oos.D2[val.fld] \n\n#par(mfrow=c(2,1))\n#plot(gbm.val.pred.1~gbm.val.act.1)\n#plot(gbm.val.pred.2~gbm.val.act.2)\n\nval.err.day.1 <- wt.day.val*abs(gbm.val.act.1-gbm.val.pred.1)\nval.err.day.2 <- wt.day.val*abs(gbm.val.act.2-gbm.val.pred.2)\nval.err.dly <- data.frame(val.err.day.1,val.err.day.2)\nval.err.int <- val.err.int # from previous median estimates, wt.int.trn*abs(trn.int.oos-trn.med) \nWMAE.val <- mean(c(as.matrix(val.err.dly),as.matrix(val.err.int)))\n\nres[[k]] <- data.frame(k,interaction.depth,n.trees,shrinkage,n.minobsinnode,WMAE.zro.all,WMAE.trn,WMAE.val)\n\n}\n\nout[[z]] <- t(do.call(rbind,res))\nstopCluster(cl)\ngc()\n}\n\n# aggregate and plot data\n{\nout.folds <- do.call(rbind,out)\nmean.res <- aggregate(cbind(WMAE.zro.all,WMAE.trn,WMAE.val)~n.trees,data=out.folds,mean)\n\nplot(mean.res$WMAE.trn~mean.res$n.trees,type='o',pch=19,col='red')\nlines(mean.res$WMAE.val~mean.res$n.trees,type='o',pch=19,col='blue')\n\nyr <- range(mean.res$WMAE.zro.all,mean.res$WMAE.trn,mean.res$WMAE.val)\nplot(mean.res$WMAE.zro.all~mean.res$n.trees,type='o',col='blue',pch=19,ylim=yr,main=\n'8 flds sweep',ylab='8 FOLD CV WMAE')\ntext(mean.res$WMAE.zro.all~mean.res$n.trees,cex=.8,col='black',pos=3,label = round(mean.res$WMAE.zro.all,2))\nlines(mean.res$WMAE.trn~mean.res$n.trees,type='o',pch=19,col='green',ylim=yr)\ntext(mean.res$WMAE.trn~mean.res$n.trees,cex=.8,col='black',pos=3,label = round(mean.res$WMAE.trn,2))\nlines(mean.res$WMAE.val~mean.res$n.trees,type='o',pch=19,col='red',ylim=yr)\ntext(mean.res$WMAE.val~mean.res$n.trees,cex=.8,col='black',pos=3,label = round(mean.res$WMAE.val,2))\nlegend(800,1*yr[2],c(\"mean.res$WMAE.zro\",\"mean.res$WMAE.trn\",\"mean.res$WMAE.val\"),\ncol=c('blue','green','red'),pch=19)\n\ndev.new()\n\nCV.df <- out.folds[,c(3,c(6:8))]\nCV.df <- transform(CV.df,ID=seq(dim(CV.df)[1]))\n\ndf.m <- melt(CV.df, id.var=c('ID','n.trees'))\nboxplot(value~variable+n.trees,df.m)\n}\n\n############################################################\n##########    FINAL all TRN model generate/WMAE\n############################################################\n\nn.trees <- 900\ninteraction.depth <- 1\nn.minobsinnode  <- 50\nshrinkage <- 0.1\n\nall.feat  <- all.iis[,f1:f25] #limit useless or sparse feature outliers\n\nall.feat[,3] <- qlimiter(all.feat[,3],.9999)\nall.feat[,11] <- qlimiter(all.feat[,11],.9999)\ntrn.feat <- all.feat[1:trn.obs,]\n\ntrn.day.1 <- data.frame(trn.feat,all.trn.iis.ts.cln,all.trn.oos.D1.clip)\nnames(trn.day.1)[dim(trn.day.1)[2]]<-'D1'\ntrn.day.2 <- data.frame(trn.feat,all.trn.iis.ts.cln,all.trn.oos.D2.clip)\nnames(trn.day.2)[dim(trn.day.2)[2]]<-'D2'\n\ntrn.day.1 <- data.frame(trn.feat,all.trn.oos.D1.clip)\nnames(trn.day.1)[dim(trn.day.1)[2]]<-'D1'\ntrn.day.2 <- data.frame(trn.feat,all.trn.oos.D2.clip)\nnames(trn.day.2)[dim(trn.day.2)[2]]<-'D2'\n\nwt.day.trn <- trn[,wtdly]\n\ngbm.trn.mod.D1 = gbm(D1 ~ .,data=trn.day.1, distribution=\"laplace\",weights = wt.day.trn,n.trees=n.trees,shrinkage=0.1 ,cv.folds=5)\ngbm.trn.mod.D2 = gbm(D2 ~ .,data=trn.day.2, distribution=\"laplace\",weights = wt.day.trn,n.trees=n.trees,shrinkage=0.1 ,cv.folds=5)\n\n############################################################\n##########   OOS TST GENERATE\n############################################################\n\ntst.feat <- all.feat[(1+trn.obs):dim(all.feat)[1],]\n\ntst.day.1 <- data.frame(tst.feat,all.tst.iis.ts.cln)\ntst.day.2 <- data.frame(tst.feat,all.tst.iis.ts.cln)\n\nall.oos.int.pred <- sapply(all.trn.oos.ts,median,na.rm=TRUE)\ntst.pred.mtx <- t(matrix(rep(all.oos.int.pred,dim(tst)[1]),\nlength(all.oos.int.pred),dim(tst)[1]))\n\ngbm.tst.pred.1 <- predict(gbm.trn.mod.D1, newdata=tst.day.1, \nn.trees = n.trees)\ngbm.tst.pred.2 <- predict(gbm.trn.mod.D2, newdata=tst.day.2, \nn.trees = n.trees)\n\ntst.submission.mtx <- cbind(tst.pred.mtx,gbm.tst.pred.1,gbm.tst.pred.2)\ntstpred <- as.vector(t(tst.submission.mtx))\n\nsubmission <- read.csv(\"E:/Kaggle/Winton/sample_submission_2.csv\")\nsubmission$Predicted <- tstpred\nwrite.csv(submission,\"E:/Kaggle/Winton/submission1.csv\",row.names=FALSE)\nsubtst <- read.csv(\"E:/Kaggle/Winton/submission1.csv\")\n```"]