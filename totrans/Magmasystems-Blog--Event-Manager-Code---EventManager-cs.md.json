["````\n // for MethodImplAttrbute\nusing System;\nusing System.Collections;\nusing System.ComponentModel;\nusing System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Text.RegularExpressions;\n// for ISynchronizer\n\n// --------------------------------------------------------------------\n//\n// This code is (C) Copyright 2005 Marc Adler\n//\n// --------------------------------------------------------------------\n\nnamespace Magmasystems.EventManager\n{\n  public delegate bool EventManagerEventHandler(object sender, string topicName, EventArgs e);\n\n  public class EventManager\n  {\n    #region Delegates\n\n    // Internal delegate used to help us fire async events\n    private delegate void AsyncFire(Delegate del, object[] args);\n\n    #endregion\n\n    #region Variables\n\n    // The singleton EventManager\n    private static EventBroker _theEventManager = null;\n\n    // A Dictionary of EventManagerEventInfo classes, indexed by the topic name\n    private Hashtable _theEventDictionary = null;\n\n    private Hashtable _theWildcardSubscribers = null;\n\n    // Used to disabled and re-enable the firing of events\n    private bool _isEnabled = true;\n\n    #endregion\n\n    #region Constructors and Static Instance\n\n    protected EventBroker()\n    {\n    }\n\n    // This is the way that the EventManager singleton is accessed\n    static public EventManager Instance\n    {\n      get\n      {\n        if(_theEventManager == null)\n        {\n          _theEventManager = new EventBroker();\n          _theEventManager._theEventDictionary = new Hashtable();\n          _theEventManager._theWildcardSubscribers = new Hashtable();\n          _theEventManager._isEnabled = true;\n        }\n        return _theEventManager;\n      }\n    }\n\n    #endregion\n\n    #region Properties\n\n    private Hashtable Dictionary\n    {\n      get\n      {\n        // make sure that the dictionary and event manager are instantiated\n        return _theEventDictionary;\n      }\n    }\n\n    private Hashtable WildcardDictionary\n    {\n      get\n      {\n        // make sure that the dictionary and event manager are instantiated\n        return _theWildcardSubscribers;\n      }\n    }\n\n    public bool Enabled\n    {\n      get { return this._isEnabled; }\n      set { this._isEnabled = value; }\n    }\n\n    #endregion\n\n    #region General Methods\n\n    static public void Register(object o)\n    {\n      Type type = o.GetType();\n\n      MethodInfo[] methods = type.GetMethods();\n      foreach (MethodInfo mi in methods)\n      {\n//        if(mi.DeclaringType != type)\n//          continue;\n        object[] oAttrs = mi.GetCustomAttributes(true);\n        foreach (object oAttr in oAttrs)\n        {\n          EventManagerEventInfo evInfo;\n          if(oAttr is EventSubscriberAttribute)\n          {\n            EventSubscriberAttribute evSubAttr = oAttr as EventSubscriberAttribute;\n            evInfo = FindTopicEntry(evSubAttr.Topic, true);\n            if(evInfo != null)\n            {\n              EventSubscriberInfo subInfo = evInfo.AddSubscriber(evSubAttr.Topic, o, evSubAttr.IsBackground, mi);\n              if(subInfo.HasWildcards)\n              {\n                EventBroker.Instance._theWildcardSubscribers[evSubAttr.Topic] = evInfo;\n              }\n            }\n          }\n\n          else if(oAttr is EventPublisherAttribute)\n          {\n            EventPublisherAttribute evPubAttr = oAttr as EventPublisherAttribute;\n            evInfo = FindTopicEntry(evPubAttr.Topic, true);\n            if(evInfo != null)\n            {\n              evInfo.AddPublisher(evPubAttr.Topic, o);\n            }\n          }\n        }\n      }\n    }\n\n    static private EventManagerEventInfo FindTopicEntry(string topicName, bool createIfEmpty)\n    {\n      EventManagerEventInfo evInfo  ;\n\n      topicName = topicName.ToUpper();\n      object oEventInfo = EventBroker.Instance._theEventDictionary[topicName];\n\n      if(oEventInfo == null)\n      {\n        if(createIfEmpty)\n        {\n          // Allocate a new entry\n          evInfo = new EventManagerEventInfo();\n          EventBroker.Instance.Dictionary[topicName] = evInfo;\n        }\n        else\n        {\n          evInfo = null;\n        }\n      }\n      else\n      {\n        // Use the existing entry\n        evInfo = oEventInfo as EventManagerEventInfo;\n      }\n\n      return evInfo;\n    }\n\n    #endregion\n\n    #region Ways to Fire and Event\n\n    [MethodImpl(MethodImplOptions.NoInlining)]\n    static public void Fire(object sender, string topicName, EventArgs args)\n    {\n      if (EventBroker.Instance.Enabled == false)\n        return;\n\n      EventManagerEventInfo evInfo = FindTopicEntry(topicName, false);\n      if(evInfo != null)\n      {\n        evInfo.Fire(sender, topicName, args);\n      }\n\n      foreach (object oKey in EventBroker.Instance._theWildcardSubscribers.Keys)\n      {\n        string keyName = oKey as String;\n        Regex regExp = new Regex(keyName, RegexOptions.IgnoreCase);\n        if(regExp.IsMatch(topicName))\n        {\n          evInfo = EventBroker.Instance._theWildcardSubscribers[oKey] as EventManagerEventInfo;\n          evInfo.Fire(sender, topicName, args);\n        }\n      }\n    }\n\n    #endregion\n\n    #region Inner Class for EventManagerEventInfo\n\n    /// <summary>/// EventManagerEventInfo\n    /// This class represents information about a single event\n    ///</summary> \n    public class EventManagerEventInfo\n    {\n      #region Variables\n\n      // Multicast delegate of all subcribers to this event\n      private event EventManagerEventHandler _eventHandler;\n\n      // The list of classes that publish this event\n      private ArrayList _publishers;\n      // The list of classes that subscribe to this event\n      private ArrayList _subscribers;\n\n      #endregion\n\n      #region Constructors\n\n      public EventManagerEventInfo()\n      {\n        this._publishers = new ArrayList();\n        this._subscribers = new ArrayList();\n        this._eventHandler = null;\n      }\n\n      #endregion\n\n      #region Events\n\n      public event EventManagerEventHandler EventManagerEvent\n      {\n        add { this._eventHandler += value; }\n        remove { this._eventHandler -= value; }\n      }\n\n      #endregion\n\n      #region Properties\n\n      public EventManagerEventHandler EventHandler\n      {\n        get { return this._eventHandler; }\n      }\n\n      public ArrayList Publishers\n      {\n        get { return this._publishers; }\n      }\n\n      public ArrayList Subscribers\n      {\n        get { return this._subscribers; }\n      }\n\n      #endregion\n\n      #region Methods\n\n      public EventSubscriberInfo AddSubscriber(string topicName, object objectRef, bool isBackground, MethodInfo mi)\n      {\n        EventSubscriberInfo subInfo = new EventSubscriberInfo(this, topicName, objectRef, isBackground, mi);\n        this._eventHandler += new EventManagerEventHandler(subInfo.OnPublisherFired);\n        this.Subscribers.Add(subInfo);\n        return subInfo;\n      }\n\n      public EventPublisherInfo AddPublisher(string topicName, object objectRef)\n      {\n        EventPublisherInfo pubInfo = new EventPublisherInfo(this, topicName, objectRef);\n        this.Publishers.Add(pubInfo);\n        return pubInfo;\n      }\n\n      public void RemoveSubscriber(EventSubscriberInfo sub)\n      {\n        this.Subscribers.Remove(sub);\n      }\n\n      public void RemovePublisher(EventPublisherInfo pub)\n      {\n        this.Publishers.Remove(pub);\n      }\n\n      #endregion\n\n      #region Event Firing\n\n      public void Fire(object sender, string topicName, EventArgs args)\n      {\n        // This handles the event firing to the SubscriberInfo class. In turn, the\n        // SubscriberInfo object will invoke the actual delegate. The SubscriberInfo\n        // object will determine whether the delegate shoul dbe called synchronously\n        // or asynchronously.\n        if(this.EventHandler != null)\n        {\n          this.EventHandler(sender, topicName, args);\n        }\n      }\n\n      #endregion\n    }\n\n    #endregion\n\n    #region Inner class for EventPublisherInfo\n\n    public class EventPublisherInfo\n    {\n      #region Variables\n\n      private EventManagerEventInfo _evInfo;\n      private WeakReference _objectRef;\n      private string _topicName; // the upper-cased name\n      private string _displayName; // used to generate context menus at runtime\n\n      #endregion\n\n      #region Constructors\n\n      private EventPublisherInfo()\n      {\n        this._objectRef = null;\n      }\n\n      public EventPublisherInfo(EventManagerEventInfo evInfo, string topicName) : this()\n      {\n        this._evInfo = evInfo;\n        this.DisplayName = topicName;\n        this._topicName = topicName.ToUpper();\n      }\n\n      public EventPublisherInfo(EventManagerEventInfo evInfo, string topicName, object objectRef) : this(evInfo, topicName)\n      {\n        this._objectRef = new WeakReference(objectRef);\n      }\n\n      #endregion\n\n      #region Properties\n\n      public WeakReference Publisher\n      {\n        get { return (this._objectRef.IsAlive == true) ? this._objectRef : null; }\n        set { this._objectRef = value; }\n      }\n\n      public string DisplayName\n      {\n        get { return this._displayName; }\n        set { this._displayName = value; }\n      }\n\n      #endregion\n    }\n\n    #endregion\n\n    #region Inner class for EventSubscriberInfo\n\n    public class EventSubscriberInfo\n    {\n      #region Variables\n\n      private EventManagerEventInfo _eventInfo; // ref back to the holding container\n      private WeakReference _objectRef;\n      private MethodInfo _methodInfo; // The method that the event firer should Invoke\n      private bool _isBackground;\n      private EventManagerEventHandler _delegateForAsync;\n\n      private string _topicName; // we may have wildcards\n      private bool _hasWildcards; // to help determine whether to use RegEx or not\n\n      #endregion\n\n      #region Constructors\n\n      private EventSubscriberInfo()\n      {\n        this._objectRef = null;\n        this._isBackground = false;\n        this._hasWildcards = false;\n      }\n\n      public EventSubscriberInfo(EventManagerEventInfo evInfo, string topicName) : this()\n      {\n        this._eventInfo = evInfo;\n        this.TopicName = topicName; // use the property so that formatting is done\n      }\n\n      public EventSubscriberInfo(EventManagerEventInfo evInfo, string topicName, object objectRef) : this(evInfo, topicName)\n      {\n        this._objectRef = new WeakReference(objectRef);\n      }\n\n      public EventSubscriberInfo(EventManagerEventInfo evInfo, string topicName, object objectRef, bool isBackground, MethodInfo mi) : this(evInfo, topicName, objectRef)\n      {\n        this._isBackground = isBackground;\n        this._methodInfo = mi;\n\n        if(isBackground)\n        {\n          this._delegateForAsync = (EventManagerEventHandler) Delegate.CreateDelegate(typeof (EventManagerEventHandler), objectRef, mi.Name);\n        }\n\n      }\n\n      #endregion\n\n      #region Properties\n\n      public object Subscriber\n      {\n        get { return (this._objectRef.IsAlive) ? this._objectRef.Target : null; }\n      }\n\n      public bool IsBackground\n      {\n        get { return this._isBackground; }\n        set { this._isBackground = value; }\n      }\n\n      public string TopicName\n      {\n        get { return this._topicName; }\n        set { this._topicName = FormatTopicName(value); }\n      }\n\n      public bool HasWildcards\n      {\n        get { return this._hasWildcards; }\n      }\n\n      #endregion\n\n      #region Methods\n\n      private string FormatTopicName(string topic)\n      {\n        // We want to make things easy for matching publishers and sunscribers.\n        // 1) We always use upper-case topic names.\n        // 2) Replace the dots with slashes so that the dot is not taken as a regexp\n        //    character by the pattern matcher.\n        // 3) Let us know whether this topic has a wildcard in it so we know whether\n        //    to use the slow regexp matcher or the faster Equals operator.\n        if(topic.IndexOfAny(new char[] {'*'}) >= 0)\n          this._hasWildcards = true;\n\n        return topic.Replace('.', '/').ToUpper();\n      }\n\n      #endregion\n\n      #region Event Firing\n\n      /// <summary>/// This gets called whenever the event manager fires an event.\n      /// This does the hard work in event firing. It eventually calls\n      /// the subscriber's delegate in order to process the event. it also determines\n      /// whether the delegate should be called synchronously or asynchronously.\n      ///</summary> \n      /// <param name=\"sender\">\n      /// <param name=\"topicName\">\n      /// <param name=\"args\">\n      /// <returns>// \n      public bool OnPublisherFired(object sender, string topicName, EventArgs args)\n      {\n        // If the object that this subscriber is bound to has been garbage-collected, then\n        // remove the subscriber from the EventInfo's subscriber list and return.\n        if(this.Subscriber == null)\n        {\n          this._eventInfo.RemoveSubscriber(this);\n          return true;\n        }\n\n        if(this.IsBackground)\n        {\n          AsyncFire asyncFire = new AsyncFire(InvokeDelegate);\n          asyncFire.BeginInvoke(this._delegateForAsync, new object[] {sender, topicName, args}, new AsyncCallback(Cleanup), null);\n        }\n        else\n        {\n          object oRet = this._methodInfo.Invoke(this.Subscriber, new object[] {sender, topicName, args});\n          if(oRet is Boolean)\n            return (bool) oRet;\n        }\n\n        return true;\n      }\n\n      private void InvokeDelegate(Delegate del, object[] args)\n      {\n        ISynchronizeInvoke synchronizer = del.Target as ISynchronizeInvoke;\n        if(synchronizer != null) // Requires thread affinity\n        {\n          if(synchronizer.InvokeRequired)\n          {\n            synchronizer.Invoke(del, args);\n            return;\n          }\n        }\n\n        // Not requiring thread afinity or invoke is not required\n        del.DynamicInvoke(args);\n      }\n\n      private void Cleanup(IAsyncResult asyncResult)\n      {\n        asyncResult.AsyncWaitHandle.Close();\n      }\n\n      #endregion\n    }\n\n    #endregion\n  }\n}</returns> \n````"]