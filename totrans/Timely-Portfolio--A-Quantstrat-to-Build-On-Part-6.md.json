["```\n#thanks so much to the developers of quantstrat\n#99% of this code comes from the demos in the quantstrat package   #in this I use osFun to size orders to ending equity\n#for a more appropriate comparison to buy hold   #takes longer than I would like but is acceptable\n#another way to accomplish testing and reporting\n#is use 1 for orderqty and then generate return series\n#with this as signal   #however despite extra time I like to see growth in order size\n#with performance\n#makes a very valid point for drawdown reduction     require(quantstrat)\nrequire(PerformanceAnalytics)   #now let's define our silly countupdown function\nCUD <- function(price,n) {\n\t#CUD takes the n-period sum of 1 (up days) and -1 (down days)\n\ttemp <- runSum(ifelse(ROC(price,1,type=\"discrete\") > 0,1,-1),n)\n\tcolnames(temp) <- \"CUD\"\n\ttemp\n}   BuyHold <- function(price,periodtobuy) {\n\t#just enter true (1) the period specified as buy and hold\n\t#for the remainder\n\ttemp <- as.xts(rep(0,NROW(price)),order.by=index(price))\n\tcolnames(temp) <- \"BuyHold\"\n\ttemp[periodtobuy,1]<-1\n\ttemp\n}   osFillErUp <- function (data, timestamp, orderqty, ordertype, orderside, portfolio, symbol, ruletype, ..., orderprice) \n{   #get date in usable xts format\n\tdatePos <- format(timestamp,\"%Y-%m-%d\")\n\t#update the portfolio to date of trade rule\n\tupdatePortf(Portfolio=portfolio,Symbol=symbol,Dates=paste('::',datePos,sep=''))\n\tportf <- getPortfolio(portfolio)\n\t#get price of symbol for the date of trade rule\n\tprice <- getPrice(get(symbol))[datePos]\n\t#get amount generated from the last trade\n\t#best way for me to overcome lack of cumulative p/l for portfolio by symbol\n\t#all this logic is at the account level\n\ttrades <- getOrderBook(portfolio)[[portfolio]][[symbol]]\n\t#if first trade, just use order quantity specified\n\t#if not get order quantity equal to\n\t#last trade proceeds divided by price of symbol at trade date\n\tif(NROW(trades)>1) {\n\t\ttrades <- trades[NROW(trades)]\n\t\tendEq <- as.numeric(trades$Order.Qty) * as.numeric(trades$Order.Price)\n#\t\torderqty <- abs(endEq/price)\n\t\torderqty <- abs(floor(endEq/price))\n\t}\n\t#return the new orderqty\n\tosFillErUp <- orderqty\n}     try(rm(\"order_book.CUD\",pos=.strategy),silent=TRUE)\ntry(rm(\"order_book.BuyHold\",pos=.strategy),silent=TRUE)\ntry(rm(\"account.CUD\",\"portfolio.CUD\",pos=.blotter),silent=TRUE)\ntry(rm(\"account.BuyHold\",\"portfolio.BuyHold\",pos=.blotter),silent=TRUE)\ntry(rm(\"port.st\",\"symbols\",\"symbol\",\"stratCUD\",\"initDate\",\"initEq\",\n\t'start_t','end_t','num_periods'),silent=TRUE)   #specify this for the rolling periods to use for our signal\nnum_periods=50   # Initialize a strategy object\nstratCUD <- strategy(\"CUD\")   # Add an indicator\nstratCUD <- add.indicator(strategy = stratCUD, name = \"CUD\", \n\targuments = list(price = quote(Cl(mktdata)),n=num_periods),\n\tlabel=\"CUD\")   # enter when CUD > 0\nstratCUD <- add.signal(strategy = stratCUD, name=\"sigThreshold\",\n\targuments = list(threshold=0, column=\"CUD\",relationship=\"gte\", cross=TRUE),\n\tlabel=\"CUD.gte.0\")\n# exit when CUD < 0\nstratCUD <- add.signal(strategy = stratCUD, name=\"sigThreshold\",\n\targuments = list(threshold=0, column=\"CUD\",relationship=\"lt\",cross=TRUE),\n\tlabel=\"CUD.lt.0\")   stratCUD <- add.rule(strategy = stratCUD, name='ruleSignal', \n\targuments = list(sigcol=\"CUD.gte.0\", sigval=TRUE, orderqty=100, ordertype='market',\n\t orderside='long', pricemethod='market', replace=FALSE, osFUN='osFillErUp'), type='enter', path.dep=TRUE)\nstratCUD <- add.rule(strategy = stratCUD, name='ruleSignal', \n\targuments = list(sigcol=\"CUD.lt.0\", sigval=TRUE, orderqty='all',\n\t ordertype='market', orderside='long', pricemethod='market', replace=FALSE),\n\t type='exit', path.dep=TRUE)   #Initialize a buy/hold strategy object\nstratBuyHold <- strategy(\"BuyHold\")\nstratBuyHold <- add.indicator(strategy = stratBuyHold, name = \"BuyHold\",\n\targuments = list(price = quote(Cl(mktdata)),periodtobuy=num_periods),\n\tlabel = \"BuyHold\")\nstratBuyHold <- add.rule(strategy=stratBuyHold, name='ruleSignal',\n\targuments = list(sigcol=\"BuyHold\",sigval=TRUE,orderqty=100,ordertype='market',\n\t orderside='long', pricemethod='market', replace=FALSE), type='enter', path.dep=TRUE)     currency(\"USD\")\nsymbols = c(\"GSPC\",\"GDAXI\")\nfor (symbol in symbols) {\n\tstock(symbol, currency=\"USD\",multiplier=1)\n\t#use paste with ^ to get index data\n\tgetSymbols(paste(\"^\",symbol,sep=\"\"),adjust=T,from=\"1900-12-31\")\n\tassign(symbol,to.weekly(get(symbol)))\n}   initDate='1949-12-31'\ninitEq=1000000\nport.st<-'CUD' #use a string here for easier changing of parameters and re-trying\nport.buyhold <- 'BuyHold'   initPortf(port.st, symbols=symbols, initDate=initDate)\ninitAcct(port.st, portfolios=port.st, initDate=initDate, initEq=initEq)\ninitOrders(portfolio=port.st, initDate=initDate)   initPortf(port.buyhold, symbols=symbols, initDate=initDate)\ninitAcct(port.buyhold, portfolios=port.buyhold, initDate=initDate,, initEq=initEq)\ninitOrders(portfolio=port.buyhold, initDate=initDate)   print(\"setup completed\")   # Process the indicators and generate trades\nstart_t<-Sys.time()\nout<-try(applyStrategy(strategy=stratCUD , portfolios=port.st ) )\nend_t<-Sys.time()\nprint(\"Strategy Loop:\")\nprint(end_t-start_t)   # Process buy and hold strategy\nstart_t<-Sys.time()\nout<-try(applyStrategy(strategy=stratBuyHold , portfolios=port.buyhold ) )\nend_t<-Sys.time()\nprint(\"Strategy Loop:\")\nprint(end_t-start_t)   start_t<-Sys.time()\nupdatePortf(Portfolio=port.st,Dates=paste('::',as.Date(Sys.time()),sep=''))\nupdatePortf(Portfolio=port.buyhold,Dates=paste('::',as.Date(Sys.time()),sep=''))\nend_t<-Sys.time()\nprint(\"trade blotter portfolio update:\")\nprint(end_t-start_t)   # hack for new quantmod graphics, remove later\nthemelist<-chart_theme()\nthemelist$col$up.col<-'lightgreen'\nthemelist$col$dn.col<-'pink'   for(symbol in symbols){\n\t#dev.new()\n\t#chart.Posn(Portfolio=port.st,Symbol=symbol,theme=themelist)\n\t#add the CUD indicator to the bottom of the chart\n\t#jpeg(filename=paste(symbol,\" Reconcile.jpg\",sep=\"\"),quality=100,\n\t#\twidth=6.5, height = 6.5,  units=\"in\",res=96)\n\tchart.Reconcile(port.buyhold,port.st,symbol)\n\tplot(add_TA(CUD(get(symbol)[,4],n=num_periods)))\n\t#dev.off()\n}   #tradeStats(port.st)   #backwards way to get returns\n#again to bypass account p/l logic\nport <- getPortfolio(port.st)\nfor(symbol in symbols) {\n\t#get posPL for the symbol in the portfolio\n\tposPLTable <- port$symbols[[symbol]][[\"posPL\"]]\n\t#easier this way to get ROC for each day when position is held (Pos.Qty > 0)\n\t#rets <- lag(ifelse(posPLTable$Pos.Qty>0,1,0),k=1)*ROC(get(symbol)[,4],type=\"discrete\",n=1)\n\t#the previous commented method is not exactly correct\n\t#since we can only hold integer positions\n\t#to account for this difference we can get\n\trets <- posPLTable$Gross.Trading.PL/lag(posPLTable$Pos.Value,k=1)\n\trets[is.na(rets)] <- 0\n\trets[which(rets[,1]==Inf)] <- 0\n\trets[which(rets[,1]==-Inf)] <- 0\n\tretCompare <- merge(rets,ROC(get(symbol)[,4],type=\"discrete\",n=1))\n\tcolnames(retCompare) <- c(paste(symbol,\" CUD System\",sep=\"\"),symbol)\n\t#jpeg(filename=paste(symbol,\" Performance.jpeg\",sep=\"\"),quality=100,width=6.5, height = 6.5,\n\t#\tunits=\"in\",res=96)\n\tcharts.PerformanceSummary(retCompare,ylog=TRUE,\n\t\tcolorset=c(\"black\",\"gray70\"),\n\t\tmain = paste(symbol,\" CUD System and Index \n\t\tPerformance Summary\",sep=\"\"))\n\t#dev.off()\n\t#jpeg(filename=paste(symbol,\" Capture.jpeg\",sep=\"\"),quality=100,width=6.5, height = 6.5,\n\t#\tunits=\"in\",res=96)\n\tchart.CaptureRatios(retCompare[,1],retCompare[,2],\n\t\tmain = paste(symbol,\" CUD System and Index \n\t\tCapture Ratios\",sep=\"\"))\n\t#dev.off() \n}\n```"]