["```\n\nmin.mad.downside.portfolio <- function\n(\n\tia,\t\t# input assumptions\n\tconstraints\t# constraints\n)\n{\n\tn = ia$n\n\tnt = nrow(ia$hist.returns)\n\n\tmar = ia$parameters.mar\n\n\t# objective : Mean-Lower-Semi-Absolute Deviation (M-LSAD)\n\t#  1/T * [ SUM <over j> z.j ]\n\tf.obj = c( rep(0, n), (1/nt) * rep(1, nt) )\n\n\t# adjust constraints, add z.j\n\tconstraints = add.variables(nt, constraints, lb = 0)\n\n\t#  MAR - [ SUM <over i> r.ij * x.i ] <= z.j , for each j = 1,...,T \n\ta = rbind( matrix(0, n, nt), diag(nt))\t\n\t\ta[1 : n, ] = t(ia$hist.returns)\n\tconstraints = add.constraints(a, rep(mar, nt), '>=', constraints)\t\t\t\t\t\n\n\t# setup linear programming\t\n\tf.con = constraints$A\n\tf.dir = c(rep('=', constraints$meq), rep('>=', len(constraints$b) - constraints$meq))\n\tf.rhs = constraints$b\n\n\t# find optimal solution\n\tx = NA\n\tsol = try(solve.LP.bounds('min', f.obj, t(f.con), f.dir, f.rhs, \n\t\t\t\t\tlb = constraints$lb, ub = constraints$ub), TRUE)\n\n\tif(!inherits(sol, 'try-error')) {\n\t\tx = sol$solution[1:n]\n\t}\n\n\treturn( x )\n}\n\n```", "```\n\nmin.risk.downside.portfolio <- function\n(\n\tia,\t\t# input assumptions\n\tconstraints\t# constraints\n)\n{\n\tn = ia$n\n\tnt = nrow(ia$hist.returns)\n\n\tmar = ia$parameters.mar\n\n\t# objective : Mean-Lower Semi-Variance (MV)\n\t#  1/T * [ SUM <over j> z.j^2 ]\n\tf.obj = c( rep(0, n), (1/nt) * rep(1, nt) )\n\n\t# adjust constraints, add z.j\n\tconstraints = add.variables(nt, constraints, lb = 0)\n\n\t#  MAR - [ SUM <over i> r.ij * x.i ] <= z.j , for each j = 1,...,T \n\ta = rbind( matrix(0, n, nt), diag(nt))\t\n\t\ta[1 : n, ] = t(ia$hist.returns)\n\tconstraints = add.constraints(a, rep(mar, nt), '>=', constraints)\t\t\t\t\t\n\n\t# setup quadratic minimization\n\tDmat = diag( len(f.obj) )\n\tdiag(Dmat) = f.obj\n\tif(!is.positive.definite(Dmat)) {\n\t\tDmat <- make.positive.definite(Dmat)\n\t}\t\n\n\t# find optimal solution\t\n\tx = NA\n\tsol = try(solve.QP.bounds(Dmat = Dmat, dvec = rep(0, nrow(Dmat)) , \n\t\tAmat=constraints$A, bvec=constraints$b, constraints$meq,\n\t\tlb = constraints$lb, ub = constraints$ub),TRUE) \n\n\tif(!inherits(sol, 'try-error')) {\n\t\tx = sol$solution[1:n]\n\t}\n\n\treturn( x )\n}\n\n```", "```\n\n# load Systematic Investor Toolbox\nsetInternet2(TRUE)\nsource(gzcon(url('https://github.com/systematicinvestor/SIT/raw/master/sit.gz', 'rb')))\n\n#--------------------------------------------------------------------------\n# Create Efficient Frontier\n#--------------------------------------------------------------------------\n\tia = aa.test.create.ia()\n\tn = ia$n\t\t\n\n\t# 0 <= x.i <= 0.8\n\tconstraints = new.constraints(n, lb = 0, ub = 0.8)\n\n\t# SUM x.i = 1\n\tconstraints = add.constraints(rep(1, n), 1, type = '=', constraints)\t\t\n\n\t# Set target return (or Minimum Acceptable Returns (MAR))\n\t# and consider only returns that are less than the target \n\tia$parameters.mar = 0/100 \n\t\t# convert annual to monthly\n\t\tia$parameters.mar = ia$parameters.mar / 12\n\n\t# create efficient frontier(s)\n\tef.mad = portopt(ia, constraints, 50, 'MAD', min.mad.portfolio)\n\tef.mad.downside = portopt(ia, constraints, 50, 'S-MAD', min.mad.downside.portfolio)\n\n\tef.risk = portopt(ia, constraints, 50, 'Risk')\n\tef.risk.downside = portopt(ia, constraints, 50, 'S-Risk', min.risk.downside.portfolio)\n\n\t# Plot multiple Efficient Frontiers and Transition Maps\n\tlayout( matrix(1:4, nrow = 2) )\n\tplot.ef(ia, list(ef.mad.downside, ef.mad), portfolio.mad, F)\t\t\t\n\tplot.ef(ia, list(ef.mad.downside, ef.mad), portfolio.mad.downside, F)\t\t\t\n\n\tplot.transition.map(ef.mad)\n\tplot.transition.map(ef.mad.downside)\n\n\t# Plot multiple Efficient Frontiers and Transition Maps\n\tlayout( matrix(1:4, nrow = 2) )\n\tplot.ef(ia, list(ef.risk.downside, ef.risk), portfolio.risk, F)\t\t\t\n\tplot.ef(ia, list(ef.risk.downside, ef.risk), portfolio.risk.downside, F)\t\t\t\n\n\tplot.transition.map(ef.risk)\n\tplot.transition.map(ef.risk.downside)\n\n```"]