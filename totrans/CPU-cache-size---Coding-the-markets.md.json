["```\n#include <iostream>\n#include <cmath>\n#include <windows.h>\n\ntypedef unsigned __int64 ui64;\ntypedef int* iptr;\n\nconst int _1K = 1 << 10;\nconst int _16M = 1 << 24;\n\niptr aray[_16M/sizeof(iptr)];\n\ninline ui64 RDTSC( ) {\n   __asm {\n      XOR eax, eax        ; Input 0 for CPUID, faster than mv\n      CPUID            ; CPUID flushes pipelined instructions\n      RDTSC            ; Get RDTSC counter in edx:eax matching VC calling conventions\n   }\n}\n\nint main( int argc, char** argv)\n{\n    // Ensure we're running on only one core\n    DWORD proc_affinity_mask = 0;\n    DWORD sys_affinity_mask = 0;\n    HANDLE proc = GetCurrentProcess( );\n    GetProcessAffinityMask( proc, &proc_affinity_mask, &sys_affinity_mask);\n    std::cout << \"proc_affinity_mask=\" << proc_affinity_mask << \", sys_affinity_mask=\" << sys_affinity_mask << std::endl;\n    if ( proc_affinity_mask > 1) {\n        if ( proc_affinity_mask & 2)\n            proc_affinity_mask = 2;\n        else\n            proc_affinity_mask = 1;\n        SetProcessAffinityMask( proc, proc_affinity_mask);\n    }\n\n    // avoid interrupts \n    SetPriorityClass( proc, REALTIME_PRIORITY_CLASS);\n\n    // stepping up thru the candidate cache sizes\n    for ( int bytes = _1K; bytes <= _16M; bytes *= 2) {\n\n        // populate the array with ptrs back into the array\n        int    slots = bytes/sizeof(iptr);\n        int    slot = 0;\n        iptr    start_addr = reinterpret_cast<iptr>( &aray[0]);\n        iptr    end_addr = start_addr + slots;\n        iptr    rand_addr = 0;\n        iptr    addr = 0;\n\n        std::cout << \"slots=\" << std::dec << slots << \", start_addr=\" \n            << std::hex << start_addr << \", end_addr=\" << end_addr << std::endl;\n\n        // clear memory first so we can spot unpopulated slots below\n        for ( addr = start_addr; addr < end_addr; addr++)\n            *addr = 0;\n\n        for ( addr = start_addr; addr < end_addr; addr++) {\n            // pick a random slot in the array\n            slot = int( float( slots) * float( rand( ))/ float( RAND_MAX));\n            rand_addr = start_addr + ( slot == slots ? 0 : slot);\n\n            // look for the next empty slot - nb we may need to wrap around\n            while ( *rand_addr) {\n                rand_addr++;\n                if ( rand_addr >= end_addr)\n                    rand_addr = start_addr;\n            }\n            *rand_addr = reinterpret_cast<int>( addr);\n        }\n\n        // sanity check\n        for ( addr = start_addr; addr < end_addr; addr++) {\n            if ( !*addr)\n                std::cout << \"empty slot at \" << std::hex << addr << std::endl;\n        }\n\n        // now we're ready to ptr chase thru the array\n        int accesses = int( 1e6);\n        addr = aray[0];\n        ui64 start_time = RDTSC( );\n        for ( int i = 0; i < accesses; i++)\n            addr = reinterpret_cast<iptr>( *addr);\n        ui64 end_time = RDTSC( );\n\n        ui64 cycles = end_time - start_time;\n        float rw_cost = float( cycles)/float( accesses);\n        std::cout << \"size=\" << std::dec << bytes << \", cycles=\" \n                    << cycles << \", cost=\" << rw_cost << std::endl;\n    }\n\n    return 0;\n}\n\n```"]