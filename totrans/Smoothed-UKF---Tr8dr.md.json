["```\n\n## modified number of columns\nncols <- function (x) ifselse(is.matrix(x), ncol(x), length(x))\n\n## modified number of rows\nnrows <- function (x) ifelse(is.matrix(x), nrow(x), length(x))\n\n#\n#\tDetermine transformed distribution across non-linear function f(x)\n#\n#\nunscented.transform.aug <- function (\n\tMUx,\t\t\t\t# mean of state\n\tP, \t\t\t\t\t# covariance of state\n\tNyy,\t\t\t\t# noise covariance matrix of f(x)\n\tf,\t\t\t\t\t# non-linear function f(X, E)\n\tdt,\t\t\t\t\t# time increment\n\talpha = 1e-3,\t\t# scaling of points from mean\n\tbeta = 2,\t\t\t# distribution parameter\n\tkappa = 1)\n{\n\tNyy <- as.matrix(Nyy)\n\n\t## constants\n\tLx <- nrows(MUx)\n\tLy <- nrows(Nyy)\n\tn <- Lx + Ly\n\n\t## create augmented mean and covariance\n\tMUx.aug <- c (MUx, rep(0, Ly))\n\tP.aug <- matrix(0, Lx+Ly, Lx+Ly)\n\tP.aug[1:Lx,1:Lx] <- P\n\tP.aug[(Lx+1):(Lx+Ly),(Lx+1):(Ly+Ly)] <- Nyy\n\n\t## generating sigma points\n\tlambda <- alpha^2 * (n + kappa) - n\n\tA <- t (chol (P.aug))\n\tX <- MUx.aug + sqrt(n + lambda) * cbind (rep(0,n), A, -A)\n\n\t## generate weights\n\tWc <- c (\n\t\tlambda / (n + lambda) + (1 - alpha^2 + beta),\n\t\trep (1 / (2 * (n + lambda)), 2*n))\n\tWm <- c (\n\t\tlambda / (n + lambda),\n\t\trep (1 / (2 * (n + lambda)), 2*n))\n\n\t## propagate through function\n\tY <- apply(X, 2, function (v)\n\t\t{\n\t\t\tf (dt, v[1:Lx], v[(Lx+1):(Lx+Ly)])\n\t\t})\n\n\tif (is.vector(Y))\n\t\tY <- t(as.matrix(Y))\n\n\t## now calculate moments\n\tMUy <- Y %*% Wm\n\n\tPyy <- matrix(0, nrows(Nyy), nrows(Nyy))\n\tPxy <- matrix(0, nrows(MUx), nrows(Nyy))\n\n\tfor (i in 1:ncols(Y))\n\t{\n\t\tdy <- (Y[,i] - MUy)\n\t\tdx <- (X[1:Lx,i] - MUx)\n\n\t\tPyy <- Pyy + Wc[i] * dy %*% t(dy)\n\t\tPxy <- Pxy + Wc[i] * dx %*% t(dy)\n\t}\n\n\tlist (mu = MUy, Pyy = Pyy, Pxy = Pxy)\n}\n\n```", "```\n\n#\n#\tAugmented UKF filtered series\n#\t\t- note that f and g are functions of state X and error vector N  f(dt, Xt, E)\n#\t\t- Nx and Ny state and observation innovation covariance\n#\t\t- Xo is the initial state\n#\t\t- dt is the time step\n#\nukf.aug <- function (\n\tseries,\n\tf,\n\tg,\n\tNx,\n\tNy,\n\tXo = rep(0, nrow(Nx)),\n\tdt = 1,\n\talpha = 1e-3,\n\tkappa = 1,\n\tbeta = 2)\n{\n\tdata <- as.matrix(coredata(series))\n\n\t## description of initial distribution of X\n\toMUx <- Xo\n\toPx <- diag(rep(1e-4, nrows(Xo)))\n\n\tYhat <- NULL\n\tXhat <- NULL\n\n\tfor (i in 1:nrow(data))\n\t{\n\t\tYt <- t(data[i,])\n\n\t\t## predict\n\t\tr <- unscented.transform.aug (oMUx, oPx, Nx, f, dt, alpha=alpha, beta=beta, kappa=kappa)\n\t\tpMUx <- r$mu\n\t\tpPx <- r$Pyy\n\n\t\t## update\n\t\tr <- unscented.transform.aug (pMUx, pPx, Ny, g, dt, alpha=alpha, beta=beta, kappa=kappa)\n\t\tMUy <- r$mu\n\t\tPyy <- r$Pyy\n\t\tPxy <- r$Pxy\n\n\t\tK <- Pxy %*% inv(Pyy)\n\t\tMUx = pMUx + K %*% (Yt - MUy)\n\t\tPx <- pPx - K %*% Pyy %*% t(K)\n\n\t\t## set for next cycle\n\t\toMUx <- MUx\n\t\toPx <- Px\n\n\t\t## append results\n\t\tYhat <- rbind(Yhat, t(MUy))\n\t\tXhat <- rbind(Xhat, t(MUx))\n\t}\n\n\tlist (Yhat = Yhat, Xhat = Xhat)\n}\n\n```", "```\n\nukf.smooth <- function (\n\tseries, \t\t\t\t\t# series to be filtered\n\tf, \t\t\t\t\t\t\t# state mapping X[t] = f(X[t-1])\n\tg, \t\t\t\t\t\t\t# state to measure mapping Y[t] = g(X[t])\n\tNx, \t\t\t\t\t\t# state innovation error covar\n\tNy, \t\t\t\t\t\t# measure innovation covar\n\tXo = rep(0, nrow(Nx)), \t\t# initial state vector\n\tdt = 1, \t\t\t\t\t# time increment\n\talpha = 1e-3,\n\tkappa = 1,\n\tbeta = 2)\n{\n\tdata <- as.matrix(coredata(series))\n\n\tLx <- nrow(as.matrix(Nx))\n\tLy <- nrow(as.matrix(Ny))\n\n\t## description of initial distribution of X\n\toMUx <- Xo\n\toPx <- diag(rep(1e-4, nrows(Xo)))\n\n\tEy <- rep(0, nrows(Ny))\n\tEx <- rep(0, nrows(Nx))\n\n\tMs <- list()\n\tPs <- list()\n\n\t## forward filtering\n\tfor (i in 1:nrow(data))\n\t{\n\t\tYt <- t(data[i,])\n\n\t\t## predict\n\t\tr <- unscented.transform.aug (oMUx, oPx, Nx, f, dt, alpha=alpha, beta=beta, kappa=kappa)\n\t\tpMUx <- r$mu\n\t\tpPx <- r$Pyy\n\n\t\t## update\n\t\tr <- unscented.transform.aug (pMUx, pPx, Ny, g, dt, alpha=alpha, beta=beta, kappa=kappa)\n\t\tMUy <- r$mu\n\t\tPyy <- r$Pyy\n\t\tPxy <- r$Pxy\n\n\t\tK <- Pxy %*% inv(Pyy)\n\t\tMUx = pMUx + K %*% (Yt - MUy)\n\t\tPx <- pPx - K %*% Pyy %*% t(K)\n\n\t\t## set for next cycle\n\t\toMUx <- MUx\n\t\toPx <- Px\n\n\t\t## append results\n\t\tMs[[i]] <- MUx\n\t\tPs[[i]] <- Px\n\t}\n\n\t## backward filtering, recursively determine N(Ms[t-1],Ps[t-1]) from N(Ms[t],Ps[t])\n\tfor (i in rev(1:(nrow(data)-1)))\n\t{\n\t\t## transform\n\t\tr <- unscented.transform.aug (Ms[[i]], Ps[[i]], Nx, f, dt, alpha=alpha, beta=beta, kappa=kappa)\n\t\tMUx <- r$mu\n\t\tPxx <- r$Pyy\n\t\tPxy <- r$Pxy[1:Lx,]\n\n\t\tK <- Pxy %*% inv(Pxx)\n\t\tMs[[i]] <-  Ms[[i]] + K %*% (Ms[[i+1]] - MUx)\n\t\tPs[[i]] <- Ps[[i]] + K %*% (Ps[[i+1]] - Pxx) * t(K)\n\t}\n\n\tYhat <- NULL\n\tXhat <- NULL\n\n\tfor (i in 1:nrow(data))\n\t{\n\t\tMUy <- g(dt, Ms[[i]], Ey)\n\t\tMUx <- Ms[[i]]\n\n\t\t## append results\n\t\tYhat <- rbind(Yhat, t(MUy))\n\t\tXhat <- rbind(Xhat, t(MUx))\n\t}\n\n\tlist (Y = data, Yhat = Yhat, Xhat = Xhat)\n}\n\n```", "```\n\n#\n#\tAmplitude varying sine function state function:\n#\n#\t\tYt = Amp[t] Sin(theta[t]) + Ey\n#\n#\t\tTheta[t] = Theta[t-1] + Omega[t-1] dt + Ex,1\n#\t\tOmega[t] = Omega[t-1] + Ex,2\n#\t\tAmp[t] = Amp[t-1] + Accel[t-1] dt + Ex,3\n#\t\tAccel[t] = Accel[t] + Ex,4\n#\nsine.f.xx <- function (dt, Xt, Ex)\n{\n\tnXt <- c (\n\t\tXt[1] + dt*Xt[2] + Ex[1],\n\t\tXt[2] + Ex[2],\n\t\tXt[3] + Ex[3],\n\t\tXt[4] + Ex[4])\n\n\tnXt\n}\n\n#\n#\tAmplitude varying sine function observation function:\n#\n#\t\tYt = Amp[t] Sin(theta[t]) + Ey\n#\n#\t\tTheta[t] = Theta[t-1] + Omega[t-1] dt + Ex,1\n#\t\tOmega[t] = Omega[t-1] + Ex,2\n#\t\tAmp[t] = Amp[t-1] + Accel[t-1] dt + Ex,3\n#\t\tAccel[t] = Accel[t] + Ex,4\n#\nsine.f.xy <- function (dt, Xt, Ey)\n{\n\ty <- Xt[3] * sin(Xt[1] / pi) + Ey[1]\n\tas.matrix(y)\n}\n\n#debug(unscented.transform.aug)\n#debug(ukf.aug)\n\nseries.r <- sapply (1:500, function(x) (1+x/500) * sin(16 * x/500 * pi)) + rnorm(500, sd=0.25)\n\n## unsmoothed test\nu <- ukf.aug (\n\tseries.r, sine.f.xx, sine.f.xy,\n\tNx = 1e-3 * diag(c(1/3, 1, 1/10, 1/10)),\n\tNy = 1,\n\tXo = c(0.10, 0.10, 1, 1e-3), alpha=1e-2)\n\ndata <- rbind (\n\tdata.frame(t = 1:500, y=series.r, type='raw', window='Price'),\n\tdata.frame(t = 1:500, y=u$Yhat, type='filtered', window='Price'),\n\tdata.frame(t = 1:500, y=u$Xhat[,3], type='amp', window='Params'))\n\nggplot() + geom_line(aes(x=t,y=y, colour=type), data) + facet_new(window ~ ., scales=\"free_y\", heights=c(3,1))\n\n## smoothed test\nu <- ukf.smooth (\n\tseries.r, sine.f.xx, sine.f.xy,\n\tNx = 1e-3 * diag(c(1/3, 1, 1/10, 1/10)),\n\tNy = 1,\n\tXo = c(0.10, 0.10, 1, 1e-3), alpha=1e-2)\n\ndata <- rbind (\n\tdata.frame(t = 1:500, y=series.r, type='raw', window='Price'),\n\tdata.frame(t = 1:500, y=u$Yhat, type='filtered', window='Price'),\n\tdata.frame(t = 1:500, y=u$Xhat[,3], type='amp', window='Params'))\n\nggplot() + geom_line(aes(x=t,y=y, colour=type), data) + facet_new(window ~ ., scales=\"free_y\", heights=c(3,2))\n\n```"]