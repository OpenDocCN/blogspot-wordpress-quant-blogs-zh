["```\n#thanks so much to the developers of quantstrat\n#99% of this code comes from the demos in the quantstrat package   \n```", "```\n#in this I make changes to the signal and rule\n#to illustrate how sigCrossover and sigComparison\n#work   \n```", "```\nrequire(quantstrat)   \n```", "```\n#now let's define our silly countupdown function\nCUD <- function(price,n) {\n\t#CUD takes the n-period sum of 1 (up days) and -1 (down days)\n\ttemp<-runSum(ifelse(ROC(price,1,type=\"discrete\") > 0,1,-1),n)\n\tcolnames(temp) <- \"CUD\"\n\ttemp\n}   \n```", "```\nReturnNumbers <- function(price,n) {\n\t#just return an xts with 0 for every period\n\tas.xts(rep(0,NROW(price)),order.by=index(price))\n}   \n```", "```\ntry(rm(\"order_book.CUD\",pos=.strategy),silent=TRUE)\ntry(rm(\"account.CUD\",\"portfolio.CUD\",pos=.blotter),silent=TRUE)\ntry(rm(\"port.st\",\"symbols\",\"symbol\",\"stratCUD\",\"initDate\",\"initEq\",\n\t'start_t','end_t','num_periods'),silent=TRUE)   \n```", "```\n#specify this for the rolling periods to use for our signal\nnum_periods=50   # Initialize a strategy object\nstratCUD <- strategy(\"CUD\")   # Add an indicator\nstratCUD <- add.indicator(strategy = stratCUD, name = \"CUD\",\n\targuments = list(price = quote(Cl(mktdata)),n=num_periods),\n\tlabel=\"CUD\")\nstratCUD <- add.indicator(strategy = stratCUD, name = \"ReturnNumbers\",\n\targuments = list(price = quote(Cl(mktdata)),n=0),\n\tlabel=\"ReturnNumbers\")   \n```", "```\n# these are the same rules from the original sigThreshold\n# I provide these as an illustration of sigCrossover and sigComparison\n# sigComparison gives 1 (TRUE) or 0 (FALSE)\n# sigCrossover gives 1(TRUE) or NA\n# enter when CUD > 0\nstratCUD <- add.signal(strategy = stratCUD, name=\"sigComparison\",\n\targuments = list(columns=c(\"CUD\",\"ReturnNumbers\"),relationship=\"gte\"),\n\tlabel=\"CUD.gte.0\")\n# exit when CUD < 0\nstratCUD <- add.signal(strategy = stratCUD, name=\"sigComparison\",\n\targuments = list(columns=c(\"CUD\",\"ReturnNumbers\"),relationship=\"lt\"),\n\tlabel=\"CUD.lt.0\")   stratCUD <- add.rule(strategy = stratCUD, name='ruleSignal', \n\targuments = list(sigcol=\"CUD.gte.0\", sigval=TRUE, orderqty=1000,\n\tordertype='market', orderside='long', pricemethod='market', replace=FALSE),\n\ttype='enter', path.dep=TRUE)\nstratCUD <- add.rule(strategy = stratCUD, name='ruleSignal',\n\targuments = list(sigcol=\"CUD.lt.0\", sigval=TRUE, orderqty='all',\n\tordertype='market', orderside='long', pricemethod='market', replace=FALSE),\n\ttype='exit', path.dep=TRUE)       currency(\"USD\")\nsymbols = c(\"GSPC\",\"GDAXI\")\nfor (symbol in symbols) {\n\tstock(symbol, currency=\"USD\",multiplier=1)\n\t#use paste with ^ to get index data\n\tgetSymbols(paste(\"^\",symbol,sep=\"\"),adjust=T,from=\"1900-12-31\")\n\tassign(symbol,to.weekly(get(symbol)))\n}       initDate='1950-12-31'\ninitEq=100000\nport.st<-'CUD' #use a string here for easier changing of parameters and re-trying   \n```", "```\ninitPortf(port.st, symbols=symbols, initDate=initDate)\ninitAcct(port.st, portfolios=port.st, initDate=initDate)\ninitOrders(portfolio=port.st, initDate=initDate)   print(\"setup completed\")   \n```", "```\n# Process the indicators and generate trades\nstart_t<-Sys.time()\nout<-try(applyStrategy(strategy=stratCUD , portfolios=port.st ) )\nend_t<-Sys.time()\nprint(\"Strategy Loop:\")\nprint(end_t-start_t)     start_t<-Sys.time()\nupdatePortf(Portfolio=port.st,Dates=paste('::',as.Date(Sys.time()),sep=''))\nend_t<-Sys.time()\nprint(\"trade blotter portfolio update:\")\nprint(end_t-start_t)   \n```", "```\n# hack for new quantmod graphics, remove later\nthemelist<-chart_theme()\nthemelist$col$up.col<-'lightgreen'\nthemelist$col$dn.col<-'pink'   for(symbol in symbols){\n\tdev.new()\n\tchart.Posn(Portfolio=port.st,Symbol=symbol,theme=themelist)\n\t#add the CUD indicator to the bottom of the chart\n\tplot(add_TA(CUD(get(symbol)[,4],n=num_periods)))\n}\n```", "```\nmktdata[1:200] #will show how mktdata is used in quantstrat\n```"]