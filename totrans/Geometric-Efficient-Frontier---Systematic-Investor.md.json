["```\n\n# load Systematic Investor Toolbox\nsetInternet2(TRUE)\nsource(gzcon(url('https://github.com/systematicinvestor/SIT/raw/master/sit.gz', 'rb')))\n\n#--------------------------------------------------------------------------\n# Create Efficient Frontier\n#--------------------------------------------------------------------------\n\tia = aa.test.create.ia.rebal()\n\tn = ia$n\n\n\t# -1 <= x.i <= 1\n\tconstraints = new.constraints(n, lb = 0, ub = 1)\n\n\t# SUM x.i = 1\n\tconstraints = add.constraints(rep(1, n), 1, type = '=', constraints)\n\n\t# create efficient frontier(s)\n\tef.risk = portopt(ia, constraints, 50, 'Arithmetic', equally.spaced.risk = T)\n\n\t# compute historical geometrical returns\n\tef.risk.geometric = ef.risk\n\t\tef.risk.geometric$name = 'Geometric'\n\t\tef.risk.geometric$return = portfolio.geometric.return(ef.risk$weight, ia)\n\n\t# Plot multiple Efficient Frontiers and Transition Maps\n\tplot.ef(ia, list(ef.risk, ef.risk.geometric), portfolio.risk, T)\n\n```", "```\n\n###############################################################################\n# Functions to convert between Arithmetic and Geometric means\n###############################################################################\n# page 8, DIVERSIFICATION, REBALANCING, AND THE GEOMETRIC MEAN FRONTIER by W. Bernstein and D. Wilkinson (1997)\n###############################################################################\ngeom2aritm <- function(G, V, a, b) \n{ \n\t(2*G + a*V^2) / (1 - b*G + sqrt((1+b*G)^2 + 2*a*b*V^2)) \n}\n\naritm2geom <- function(R, V, a, b) \n{ \n\tR - a*V^2 / (2*(1 + b*R)) \n}\n\n\t#--------------------------------------------------------------------------\n\t# Following paper's notation : A(1,0) and A(1,1) page 8, 14\n\t#--------------------------------------------------------------------------\n\t# A(1,0)\n\tef.risk.A10 = ef.risk\n\t\tef.risk.A10$name = 'A(1;0)'\n\t\tef.risk.A10$return = apply( cbind(ef.risk$return, ef.risk$risk), 1,\n\t\t\t\t\tfunction(x) aritm2geom(x[1], x[2], 1, 0) )\n\t# A(1,1)\n\tef.risk.A11 = ef.risk\n\t\tef.risk.A11$name = 'A(1;1)'\n\t\tef.risk.A11$return = apply( cbind(ef.risk$return, ef.risk$risk), 1,\n\t\t\t\t\tfunction(x) aritm2geom(x[1], x[2], 1, 1) )\n\t# G(1,0)\n\tia.G = ia\n\tia.G$expected.return = apply( cbind(ia$geometric.return, ia$risk), 1,\n\t\t\t\t\tfunction(x) geom2aritm(x[1], x[2], 1, 0) )\n\tef.risk.G10 = portopt(ia.G, constraints, 50, 'G(1;0)',equally.spaced.risk = T)\n\t\tef.risk.G10$return = apply( cbind(ef.risk.G10$return, ef.risk.G10$risk), 1,\n\t\t\t\t\tfunction(x) aritm2geom(x[1], x[2], 1, 0) )\n\t# G(1,1)\n\tia.G$expected.return = apply( cbind(ia$geometric.return, ia$risk), 1,\n\t\t\t\t\tfunction(x) geom2aritm(x[1], x[2], 1, 1) )\n\tef.risk.G11 = portopt(ia.G, constraints, 50, 'G(1;1)',equally.spaced.risk = T)\n\t\tef.risk.G11$return = apply( cbind(ef.risk.G11$return, ef.risk.G11$risk), 1,\n\t\t\t\t\tfunction(x) aritm2geom(x[1], x[2], 1, 1) )\n\n\t# Plot multiple Efficient Frontiers\n\tlayout( matrix(1:4, nrow = 2) )\n\tplot.ef(ia, list(ef.risk, ef.risk.geometric, ef.risk.A10), portfolio.risk, F)\n\tplot.ef(ia, list(ef.risk, ef.risk.geometric, ef.risk.A11), portfolio.risk, F)\n\tplot.ef(ia, list(ef.risk, ef.risk.geometric, ef.risk.G10), portfolio.risk, F)\n\tplot.ef(ia, list(ef.risk, ef.risk.geometric, ef.risk.G11), portfolio.risk, F)\n\n```", "```\n\n###############################################################################\n# Functions to convert between Arithmetic and Geometric means\n###############################################################################\n# page 14, A4, On the Relationship between Arithmetic and Geometric Returns by D. Mindlin\n###############################################################################\ngeom2aritm4 <- function(G, V) \n{ \n\t(1+G)*sqrt(1/2 + 1/2*sqrt(1 + 4*V^2/(1+G)^2)) - 1 \n}\n\naritm2geom4 <- function(R, V) \n{ \n\t(1+R)/(sqrt(1 + V^2/(1+R)^2)) - 1 \n}\n\n\t#--------------------------------------------------------------------------\n\t# Use A4 method to convert between Arithmetic and Geometric means\n\t#--------------------------------------------------------------------------\n\t# A\n\tef.risk.A4 = ef.risk\n\t\tef.risk.A4$name = 'Risk A4'\n\t\tef.risk.A4$return = apply( cbind(ef.risk$return, ef.risk$risk), 1,\n\t\t\t\t\t\t\t\tfunction(x) aritm2geom4(x[1], x[2]) )\n\n\t# G\n\tia.G = ia\n\tia.G$expected.return = apply( cbind(ia$geometric.return, ia$risk), 1,\n\t\t\t\t\t\t\t\tfunction(x) geom2aritm4(x[1], x[2]) )\n\tef.risk.G4 = portopt(ia.G, constraints, 50, 'Risk G4',equally.spaced.risk = T)\n\t\tef.risk.G4$return = apply( cbind(ef.risk.G4$return, ef.risk.G4$risk), 1,\n\t\t\t\t\t\t\t\tfunction(x) aritm2geom4(x[1], x[2]) )\n\n\t# Plot multiple Efficient Frontiers\n\tlayout( matrix(1:2, nrow = 2) )\n\tplot.ef(ia, list(ef.risk, ef.risk.geometric, ef.risk.A4), portfolio.risk, F)\n\tplot.ef(ia, list(ef.risk, ef.risk.geometric, ef.risk.G4), portfolio.risk, F)\n\n```", "```\n\n\t#--------------------------------------------------------------------------\n\t# Create True Geometric Efficient Frontier\n\t#--------------------------------------------------------------------------\n\tef.true.geometric = ef.risk\n\t\tef.true.geometric$name = 'True Geometric'\n\t\tconstraints$x0 = ef.risk$weight[1,]\n\n\tfor(i in 1:len(ef.risk$risk)) {\n\t\tcat('i =', i, '\\n')\n\t\tef.true.geometric$weight[i,] = max.geometric.return.portfolio(ia, constraints, ef.risk$risk[i], ef.risk$risk[i])\n\t\t\tconstraints$x0 = ef.true.geometric$weight[i,]\n\t}\n\n\tef.true.geometric$return = portfolio.geometric.return(ef.true.geometric$weight, ia)\n\n\t# Plot multiple Efficient Frontiers\n\tlayout( matrix(1:4, nrow = 2) )\n\tplot.ef(ia, list(ef.risk.geometric, ef.risk, ef.true.geometric), portfolio.risk, T, T)\n\tplot.ef(ia, list(ef.true.geometric, ef.risk, ef.risk.geometric), portfolio.risk, T, T)\n\n```", "```\n\n\t#--------------------------------------------------------------------------\n\t# Double check that NonLinear Optimization finds global maximums by\n\t# creating random portfolios that satisfy constraints. \n\t# Plot True Geometric Efficient Frontier and random portfolios, check\n\t# that all portfolios lie below the efficient frontier.\n\t#--------------------------------------------------------------------------\t\n\t# Generate random portfolios\n\tef.random = list()\n\t\tef.random$name = 'Random'\n\t\tef.random$weight = randfixedsum(1000000, n, 1, 0, 1)\n\n\t\tef.random$risk = portfolio.risk(ef.random$weight, ia)\t\t\n\t\tef.random$return = portfolio.geometric.return(ef.random$weight, ia)\t\t\n\n\t# Plot True Geometric Efficient Frontier and random portfolios\n\tlayout(1)\n\tplot(100*ef.random$risk, 100*ef.random$return, type='p', pch=20,\n\t\t\txlim = 100*range(ef.random$risk, ef.true.geometric$risk),\n\t\t\tylim = 100*range(ef.random$return, ef.true.geometric$return),\n\t\t\tmain = 'True Geometric Efficient Frontier vs Random Portfolios',\n\t\t\txlab = 'portfolio.risk',\n\t\t\tylab = 'Return'\t\t\t\n\t\t)\n\tlines(100*ef.true.geometric$risk, 100*ef.true.geometric$return, type='l', lwd=2,col = 'red')\n\n```", "```\n\nmax.geometric.return.portfolio <- function \n(\n\tia,\t\t# input assumptions\n\tconstraints,\t# constraints\n\tmin.risk,\n\tmax.risk\n)\n{\n\tn = ia$n\n\tnt = nrow(ia$hist.returns)\n\n\trequire(Rdonlp2)\n\n\t# Geometric return\n\tfn <- function(x){\n\t\tportfolio.returns = x %*% t(ia$hist.returns)\t\n\t\tprod(1 + portfolio.returns)\n\t}\n\n\t# control structure, fnscale - set -1 for maximization\n\tcntl <- donlp2.control(silent = T, fnscale = -1, iterma =10000, nstep = 100, epsx = 1e-10)\t\n\t# lower/upper bounds\n\tpar.l = constraints$lb\n\tpar.u = constraints$ub\n\n\t# intial guess\n\tp = rep(1, nrow(constraints$A))\n\tif(!is.null(constraints$x0)) p = constraints$x0\n\n\t# linear constraints\n\tA = t(constraints$A)\n\tlin.l = constraints$b\n\tlin.u = constraints$b\n\tlin.u[ -c(1:constraints$meq) ] = +Inf\n\n\t# Nonlinear constraints\n\tnlcon1 <- function(x){\n\t\tsqrt(t(x) %*% ia$cov %*% x)\n\t}\n\n\t# find solution\n\tsol = donlp2(p, fn, par.lower=par.l, par.upper=par.u,\n\t\t\tA=A, lin.u=lin.u, lin.l=lin.l, control=cntl,\n\t\t\tnlin=list(nlcon1),\n\t\t\tnlin.upper=c(max.risk),\n\t\t\tnlin.lower=c(min.risk)\n\t\t\t)\n\n\tx = sol$par\n\n\treturn( x )\n}\n\n```"]