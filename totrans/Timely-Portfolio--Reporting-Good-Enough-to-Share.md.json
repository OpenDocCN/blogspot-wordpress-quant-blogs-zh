["```\n#this report uses the PerformanceAnalytics charts.PerformanceSummary\n#as the base for a new one-pager\n#99% of the code is from the PerformanceAnalytics package\n#all credit should be given to the PerformanceAnalytics team\n#all errors should be assigned to me\n\n#this is almost entirely from the PerformanceAnalytics\n#chart.CumReturns function\n#I only change to label the endpoints\nna.skip <- function (x, FUN=NULL, ...) # maybe add a trim capability?\n{ # @author Brian Peterson\n\n    # DESCRIPTION:\n\n    # Time series data often contains NA's, either due to missing days, \n    # noncontiguous series, or merging multiple series,\n    # \n    # Some Calulcations, such as return calculations, require data that \n    # looks like a vector, and needs the output of na.omit\n    # \n    # It is often convenient to apply these vector-like functions, but \n    # you still need to keep track of the structure of the oridginal data.\n\n    # Inputs\n    # x\t\tthe time series to apply FUN too\n    # FUN\tfunction to apply\n    # ...\tany additonal parameters to FUN\n\n    # Outputs:\n    # An xts time series that has the same index and NA's as the data \n    # passed in, after applying FUN\n\n    nx <- na.omit(x)\n    fx <- FUN(nx, ... = ...)\n    if (is.vector(fx)) {\n        result <- .xts(fx, .index(x), .indexCLASS = indexClass(x))\n    }\n    else {\n        result <- merge(fx, .xts(, .index(x)))\n    }\n    return(result)\n}\n\nchart.CumReturnsX <-\nfunction (R, wealth.index = FALSE, geometric = TRUE, legend.loc = NULL, colorset = (1:12), begin = c(\"first\",\"axis\"), ...)\n{ # @author Peter Carl\n\n    # DESCRIPTION:\n    # Cumulates the returns given and draws a line graph of the results as\n    # a cumulative return or a \"wealth index\".\n\n    # Inputs:\n    # R: a matrix, data frame, or timeSeries of returns\n    # wealth.index:  if true, shows the \"value of $1\", starting the cumulation\n    #    of returns at 1 rather than zero\n    # legend.loc: use this to locate the legend, e.g., \"topright\"\n    # colorset: use the name of any of the palattes above\n    # method: \"none\"\n\n    # Outputs:\n    # A timeseries line chart of the cumulative return series\n\n    # FUNCTION:\n\n    # Transform input data to a matrix\n    begin = begin[1]\n    x = checkData(R)\n\n    # Get dimensions and labels\n    columns = ncol(x)\n    columnnames = colnames(x)\n\n    # Calculate the cumulative return\n    one = 0\n    if(!wealth.index)\n        one = 1\n\n    ##find the longest column, calc cum returns and use it for starting values\n\n    if(begin == \"first\") {\n        length.column.one = length(x[,1])\n        # find the row number of the last NA in the first column\n        start.row = 1\n        start.index = 0\n        while(is.na(x[start.row,1])){\n            start.row = start.row + 1\n        }\n        x = x[start.row:length.column.one,]\n        if(geometric)\n            reference.index = na.skip(x[,1],FUN=function(x) {cumprod(1+x)})\n        else\n            reference.index = na.skip(x[,1],FUN=function(x) {cumsum(x)})\n    }\n    for(column in 1:columns) {\n        if(begin == \"axis\") {\n            start.index = FALSE\n\t\t} else {\n    \t\t# find the row number of the last NA in the target column\n            start.row = 1\n            while(is.na(x[start.row,column])){\n                start.row = start.row + 1\n            }\n            start.index=ifelse(start.row > 1,TRUE,FALSE)\n        }\n        if(start.index){\n\t        # we need to \"pin\" the beginning of the shorter series to the (start date - 1 period) \n\t        # value of the reference index while preserving NA's in the shorter series\n            if(geometric)\n                z = na.skip(x[,column],FUN = function(x,index=reference.index[(start.row - 1)]) {rbind(index,1+x)})\n            else\n                z = na.skip(x[,column],FUN = function(x,index=reference.index[(start.row - 1)]) {rbind(1+index,1+x)})\n        } else {\n            z = 1+x[,column] \n        }\n        column.Return.cumulative = na.skip(z,FUN = function(x, one, geometric) {if(geometric) cumprod(x)-one else (1-one) + cumsum(x-1)},one=one, geometric=geometric)\n        if(column == 1)\n            Return.cumulative = column.Return.cumulative\n        else\n            Return.cumulative = merge(Return.cumulative,column.Return.cumulative)\n    }\n    if(columns == 1)\n        Return.cumulative = as.xts(Return.cumulative)\n    colnames(Return.cumulative) = columnnames\n\n    # Chart the cumulative returns series\n    chart.TimeSeries(Return.cumulative, col = colorset, legend.loc = legend.loc, ...)\n\tfor (i in 1:NCOL(Return.cumulative)) {\n\t\ttext(x=NROW(Return.cumulative),\n\t\ty=coredata(Return.cumulative)[NROW(Return.cumulative),i],\n\t\tsprintf(\"%1.0f%%\",round(coredata(Return.cumulative)[NROW(Return.cumulative),i],2)*100),\n\t\tadj = c(0, 0.5),lwd=0.5,col=colorset[i])\n\t}\n}\n\n#this function shows bar plot side-by-side comparisons for rolling annualized\n#returns\n#please proceed with caution as function is not robust\n#and does not perform adequate error checking\nchart.SideBar <- function (w,  auto.grid = TRUE, xaxis = TRUE, yaxis = TRUE, yaxis.right = FALSE, \n    type = \"l\", lty = 1, lwd = 2, main = NULL, ylab = \"Annualized Returns\", xlab = NULL, \n    xlim = NULL, ylim = NULL, element.color = \"darkgray\", event.lines = NULL, \n    event.labels = NULL, period.areas = NULL, event.color = \"darkgray\", \n    period.color = \"aliceblue\", colorset = (1:12), pch = (1:12), \n    legend.loc = NULL, cex.axis = 0.8, cex.legend = 0.8, \n    cex.lab = 1, cex.labels = 0.8, cex.main = 1, major.ticks = \"auto\", \n    minor.ticks = TRUE, grid.color = \"lightgray\", grid.lty = \"dotted\", \n    xaxis.labels = NULL, ...) \n{\n        barplot(w, beside=TRUE, col = colorset[1:NROW(w)], \n            xlab = xlab, ylab = ylab, axes = FALSE,\n            ylim = c(min(0,min(w)),max(w)+0.05),...)\n\n    if (auto.grid) {\n        abline(v=0, col = element.color, lty = grid.lty)\n        grid(NA, NULL, col = grid.color)\n    }\n    abline(h = 0, col = grid.color)\n\n\taxis(2, cex.axis = cex.axis, col = element.color)\n\ttitle(ylab = ylab, cex = cex.lab)\n\n    if (!is.null(legend.loc)) {\n        legend(legend.loc, inset = 0.02, text.col = colorset, \n            col = colorset, cex = cex.legend, border.col = grid.color, \n            lty = lty, lwd = 2, bg = \"white\", legend = rownames(w))\n    }\n\n\tbox(col = element.color)\n}\n\ncharts.PerformanceSummaryX <-\nfunction (R, Rf = 0, main = NULL, submain=NULL, geometric=TRUE, methods = \"none\", width = 0, event.labels = NULL, ylog = FALSE, wealth.index = FALSE, gap = 12, begin=c(\"first\",\"axis\"), legend.loc=\"bottomright\", p=0.95, maxdraw = TRUE,...)\n{ # @author Peter Carl\n\n    # DESCRIPTION:\n    # A wrapper to create a wealth index chart, bars for monthly peRformance,\n    # and underwater chart for drawdown.\n\n    # Inputs:\n    # R: a matrix, data frame, or timeSeries, usually a set of monthly returns.\n    #   The first column is assumed to be the returns of interest, the next\n    #   columns are assumed to be relevant benchmarks for comparison.\n    # Rf: this is the risk free rate.  Remember to set this to the same\n    #   periodicity as the data being passed in.\n    # method: Used to select the risk parameter to use in the chart.BarVaR.  May\n    #   be any of:\n    #     modVaR - uses CF modified VaR\n    #     VaR - uses traditional Value at Risk\n    #     StdDev - monthly standard deviation of trailing 12 month returns\n    #\n\n    # Outputs:\n    # A stack of three related timeseries line charts\n\n    # FUNCTION:\n    begin = begin[1]\n    x = checkData(R)\n    colnames = colnames(x)\n    ncols = ncol(x)\n\n# This repeats a bit of code from chart.CumReturns, but it's intended\n# to align the start dates of all three charts.  Basically, it assumes\n# that the first column in the list is the column of interest, and \n# starts everything from that start date\n\n    length.column.one = length(x[,1])\n# find the row number of the last NA in the first column\n    start.row = 1\n    start.index = 0\n    while(is.na(x[start.row,1])){\n        start.row = start.row + 1\n    }\n    x = x[start.row:length.column.one,]\n\n    if(ncols > 1)\n        legend.loc = legend.loc\n    else\n        legend.loc = NULL\n\n    if(is.null(main))\n        main = paste(colnames[1],\"Performance\", sep=\" \")\n\n    if(ylog)\n        wealth.index = TRUE\n\n    op <- par(no.readonly=TRUE)\n\n    # First, we lay out the graphic as a three row, one column format\n#    plot.new()\n    layout(matrix(c(1,2,3)),height=c(2,1,1.3),width=1)\n    # to see the resulting layout, use layout.show(3)\n\n    # mar: a numerical vector of the form c(bottom, left, top, right) which\n    # gives the number of lines of margin to be specified on the four sides\n    # of the plot. The default is c(5, 4, 4, 2) + 0.1\n\n    # The first row is the cumulative returns line plot\n\tpar(oma=c(2,2,4,2))\t\n    par(mar=c(1,6,8,4))\n    chart.CumReturnsX(x, main = \"\", xaxis = FALSE, legend.loc = legend.loc, cex.legend = 1, event.labels = event.labels, ylog = ylog, wealth.index = wealth.index, begin = begin, geometric = geometric, ylab=\"Cumulative Return\",...)\n\n#\ttitle(main=main, sub=submain, cex.main=2, cex.sub=1.5, adj=0, outer =FALSE)\nmtext(text=main, line = -2, outer = TRUE, adj = 0.1, cex=2)\nmtext(text=submain, line = -4, outer = TRUE, adj = 0.075, cex=1.5)\n\n    # The second row is the monthly returns bar plot\n#    par(mar=c(1,4,0,2))\n\n    freq = periodicity(x)\n\n    switch(freq$scale,\n\tseconds = { date.label = \"Second\"},\n\tminute = { date.label = \"Minute\"},\n\thourly = {date.label = \"Hourly\"},\n\tdaily = {date.label = \"Daily\"},\n\tweekly = {date.label = \"Weekly\"},\n\tmonthly = {date.label = \"Monthly\"},\n\tquarterly = {date.label = \"Quarterly\"},\n\tyearly = {date.label = \"Annual\"}\n    )\n\n#    chart.BarVaR(x, main = \"\", xaxis = FALSE, width = width, ylab = paste(date.label,\"Return\"), methods = methods, event.labels = NULL, ylog=FALSE, gap = gap, p=p, ...)\n\n    # The third row is the underwater plot\n    par(mar=c(3,6,0,4))\n    chart.Drawdown(x, geometric = geometric, main = \"\", xlab=NA, ylab = \"Drawdown\", event.labels = NULL, ylog=FALSE, ...)\n\tif (maxdraw) {\n\t\tabline(h=-0.1,col=\"tomato3\",lwd=3,lty=\"dashed\")\n\t\ttext(x=2,y=-0.1,\"maximum acceptable drawdown\",adj = c(0, 0.5))\n\t}\n\n#     If we wanted to add a fourth row with the table of monthly returns\n#    par(mar=c(0,0,0,0))\n#    textplot(table.Returns(as.matrix(R)),cex=.7,cmar=1.5,rmar=0.5,halign=\"center\", valign=\"center\")\n\npar(mar=c(6,6,0,4))\n\nreturnTable <- returnTable <- table.TrailingPeriods(x,\n\tperiods=c(12,24,36,NROW(x)),\n\tFUNCS=\"Return.annualized\")\nrownames(returnTable) <- c(paste(c(1:3),\" Year\",sep=\"\"),\"Since Inception\")[1:NROW(returnTable)]\n\nchart.SideBar(t(as.matrix(returnTable)),...)\n\npar(op)\n\n}\n\n#now let's use the amended report to look at performance\nrequire(quantmod)\nrequire(PerformanceAnalytics)\n\nclientPerf <- read.csv(\"clientperf.csv\",stringsAsFactors=FALSE)\nclientPerf[,2:NCOL(clientPerf)] <- lapply(clientPerf[,2:NCOL(clientPerf)],as.numeric)\nclientPerf <- as.xts(clientPerf[,2:NCOL(clientPerf)]/100,\n\torder.by = as.Date(clientPerf[,1],format=\"%m-%d-%y\"))\ncolnames(clientPerf) <- c(\"Client\",\"BarclaysAgg\",\"SP500\")\n\njpeg(filename=\"performance summary.jpg\",quality=100,width=6, height = 7,  units=\"in\",res=96)\ncharts.PerformanceSummary(clientPerf)\ndev.off()\n\njpeg(filename=\"performance one-pager.jpg\",quality=100,width=6, height = 7,  units=\"in\",res=96)\ncharts.PerformanceSummaryX(clientPerf,main=\"Client Performance\",\n\tsubmain=paste(\"Since Inception - \",format(seq(index(clientPerf)[1], length=2, by=\"-1 months\")[2],\"%B %Y\"),sep=\"\"),legend.loc=\"bottomright\",maxdraw=FALSE,\n\tcolorset=c(\"cadetblue4\",\"darkgray\",\"bisque3\"),lwd=c(3,2,2))\ndev.off()\n```"]