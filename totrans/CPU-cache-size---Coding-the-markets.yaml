- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-12 19:33:41'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: CPU cache size | Coding the markets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://etrading.wordpress.com/2012/09/21/cpu-cache-size/#0001-01-01](https://etrading.wordpress.com/2012/09/21/cpu-cache-size/#0001-01-01)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: CPU cache size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: September 21, 2012
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s some code I wrote back in 2009 to figure out the L1 and L2 cache sizes
    on a Windows host. It works by populating an area of memory with randomized pointers
    that point back into that same area. The randomization defeats stride based attempts
    by CPUs to predict the next cache access. The size of the memory region is stepped
    up in powers of two, and timings taken. The timings should show when the region
    size exhausts the L1 and L2 caches. This code illustrates why control of memory
    locality is so important in writing cache friendly code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
