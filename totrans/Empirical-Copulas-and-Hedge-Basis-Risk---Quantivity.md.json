["```\n\nrequire(\"copula\")\nrequire(\"fSeries\")\n\nexploreProxyDist <- function(p, doExcess=TRUE, partitions=1)\n{\n  # Analyze distribution and copula of proxy daily returns.\n  #\n  # Args:\n  #   p: matrix of instrument price data, including valid colnames\n  #   doExcess: flag indicating whether to perform analysis on excess returns, \n  #             in addition to raw returns\n  #   partitions: if not 1, partition the returns and perform subanalysis\n  #\n  # Returns: None\n\n  oldpar <- par(mfrow=c(2,2))\n  n <- nrow(p)\n\n  # first differences (not logged)\n  pROC <- ROC(p, type=\"discrete\", na.pad=FALSE)\n  exploreProxyDistROC(pROC)\n\n  if (partitions > 1)\n  {\n    frac <- floor(n / partitions)\n    sapply(c(0:(partitions-1)), function(p) { cat(\"\\n\",\n                                                (p+1),\"-th partition:\",((p*frac)+1), \n                                                ((p+1)*frac),\"\\n\"); \n                                                partition <- pROC[((p*frac)+1):((p+1)*frac),]\n                                                exploreProxyDistROC(partition) } )\n  }\n\n  if (doExcess)\n  {\n    cat(\"\\nExcess Copula\\n\")\n\n    # calculate excess returns, subtracting off market\n    excess <- pROC[,1] - pROC[,2]\n    excessROC <- cbind(excess, pROC[,2])\n\n    par(oldpar)\n    plot(cumprod(1+excess), main=\"Excess Cumulative Returns\", ylab=\"Return\")\n    oldpar <- par(mfrow=c(2,2))\n\n    exploreProxyDistROC(excessROC)\n\n    if (partitions > 1)\n    {\n      frac <- floor(n / partitions)\n      sapply(c(0:(partitions-1)), function(p) { cat(\"\\n\",\n                                                  (p+1),\"-th Excess Partition:\",((p*frac)+1), \n                                                  ((p+1)*frac),\"\\n\"); \n                                                  partition  <- excessROC[((p*frac)+1):((p+1)*frac),]\n                                                  exploreProxyDistROC(partition) } )\n    }\n  }\n\n  par(oldpar)\n}\n\nexploreProxyDistROC <- function(pROC)\n{\n  # Analyze distribution and copula of proxy daily returns.\n  #\n  # Args:\n  #   p: matrix of instrument price data, including valid colnames\n  #\n  # Returns: list of copula fit and empirical copula\n\n  n <- nrow(pROC)\n  cnames <- colnames(pROC)\n\n  # t-distribution fits\n  p1Fit <- fitdistr(pROC[,1], \"t\")$estimate\n  p2Fit <- fitdistr(pROC[,2], \"t\")$estimate\n\n  cat(cnames[1], \"location\", p1Fit[1], \"scale\", p1Fit[2], \"df\", p1Fit[3], \"\\n\")\n  cat(cnames[2], \"location\", p2Fit[1], \"scale\", p2Fit[2], \"df\", p2Fit[3], \"\\n\")\n\n  # empirical copula\n  tau <- cor(pROC, method=\"kendall\")[2]\n  t.cop <- tCopula(tau, dim=2, dispstr=\"un\", df=3)\n  psuedo <- apply(pROC, 2, rank) / (n + 1)\n  plot(psuedo, main=\"Empirical Scatterplot\", xlab=cnames[1], ylab=cnames[2])\n\n  fit.mpl <- fitCopula(t.cop, psuedo, method=\"mpl\", estimate.variance=FALSE)\n  print(fit.mpl)\n\n  # build empirical copula and plot\n  empiricalCopula <- tCopula(fit.mpl@estimate[1], dim=2, dispstr=\"un\", df=fit.mpl@estimate[2])\n  plot(rcopula(empiricalCopula, 1000), main=\"Sampled Scatterplot\", xlab=cnames[1], ylab=cnames[2])\n  contour(empiricalCopula, pcopula, main=\"Empirical Contour\", xlab=cnames[1], ylab=cnames[2])\n  persp(empiricalCopula, dcopula, main=\"Empirical Perspective\",\n    xlab=cnames[1], ylab=cnames[2], zlab=\"Density\")\n\n  cat(\"Empirical tau:\", kendallsTau(empiricalCopula), \"\\n\")\n  cat(\"Empirical rho:\", spearmansRho(empiricalCopula), \"\\n\")\n  cat(\"Empirical tail index:\", tailIndex(empiricalCopula), \"\\n\")\n\n  return (list(fit=fit.mpl, copula=empiricalCopula))\n}\n\n```"]