["```\n\nfit.NIGuv(returns, opt.pars=c(alpha.bar=FALSE),\n          alpha.bar=1, control=list(abstol=1e-8), silent=TRUE)\n\n```", "```\n\nreplicate(periods, rghyp(n,fit))\n\n```", "```\n\nlower <- rep(0, periods)\nupper <- rep(qHat, periods)\ncont <- DEoptim.control(trace=FALSE, itermax=500, initialpop=randomPartitions,\n                        NP=as.numeric(nrow(randomPartitions)))\nDEoptim(profit, lower, upper, control=cont, prices, qHat, vest, cost)\n\n```", "```\n\n### Optimal monetization for concentrated equity.\n\nlibrary(\"tseries\")\nlibrary(\"DEoptim\")\nlibrary(\"HyperbolicDist\")\nlibrary(\"ghyp\")\nlibrary(\"partitions\")\n\nfitDistribution <- function(returns)\n{\n  # Fit generalized hyperbolic distribution to univariate series of returns.\n  #\n  # Args:\n  #   returns: series of returns\n  #\n  # Returns: fit model corresponding\n\n  fit.NIGuv(returns, opt.pars=c(alpha.bar=FALSE),\n            alpha.bar=1, control=list(abstol=1e-8), silent=TRUE)\n}\n\nsampleDistribution <- function(fit, periods, n=1)\n{\n  # Sample values from a generialized hyperbolic distribution, previously fit by fitDistribution().\n  #\n  # Args:\n  #   fit: fit previously returned by fitDistribution\n  #   periods: number of samples to generate\n  #\n  # Returns: vector (n=1) or matrix (n > 1) of samples from fit\n\n  replicate(periods, rghyp(n,fit))\n}\n\n# optimization function for calculating profit\nprofit <- function(quantity, prices, qHat, vest, cost)\n{\n  # Optimization function to calculate profit for a series of quantity and prices, subject \n  # to quantity constraints. This functions negative values, suitable for minimization.\n  #\n  # Args:\n  #   quantity: vector of quantities, aligned with quantity\n  #   prices: vector of prices, aligned with quantity\n  #   qHat: maximum quantity, which should satisfy invariant sum(quantity) = qHat\n  #   vest: vector of number of shares vested per period, aligned with quantity\n  #   cost: average cost per share, aligned with quantity\n  #\n  # Returns: vector of profit per period\n\n  # enforce qHat equality constraint\n  if (round(sum(quantity) - qHat) > 0)\n  {\n    # illegal value, optimizer treat as worse value\n    return (Inf)\n  }\n\n  p <- quantity %*% (prices - cost)\n  return (-p)\n}\n\nrandomPartitions <- function(qHat, periods, count, warmup=500, skip=100)\n{  \n  # Generate random partition matrix for quantities with length periods. Using a simple \n  # genetic algo, as integral partitions (via partitions::compositions) generates a \n  # matrix which is way too big for reasonable-sized periods (size is choose(n+k-1,k)).\n  # This function also enforces constraints.\n  #\n  # Args:\n  #   qHat: total quantity, which to all rows should sum\n  #   periods: number of partitions (equal to number of periods to spread quantity over)\n  #   count: number of quantity rows to generate\n  #   warmup: number of generic iterations to warmup randomization\n  #   skip: number of genetic iterations to skip between samples\n  #\n  # Returns: random partition\n\n  # start with equal-fraction integer partition\n  partition <- round(qHat / periods)\n  equal <- rep.int(partition, periods)\n  elen <- length(equal)\n\n  # mutation randomizer: choose two entries, increment one and decrement the other\n  randomizer <- function(dup)\n  {\n    sample <- sample.int(elen, 2)\n    up <- sample[1]\n    down <- sample[2]\n    olddup <- dup\n\n    diff <- sample.int(partition,1)\n    dup[up] <- dup[up] + diff\n    dup[down] <- dup[down] - diff\n\n    # TODO: add vesting constraint\n\n    # try again if constraints are violated\n    if (length(which(dup<0)) > 0)\n    {\n      dup <- (Recall(olddup))\n    }\n\n    dup\n  }\n\n  # warmup randomization\n  for (i in c(1:warmup))\n  {\n    equal <- randomizer(equal)\n  }\n\n  # generate random partitions, skipping skip between samples\n  randomPartitions <- matrix(data=NA, nrow=count, ncol=periods)\n  skipper <- skip\n  i <- 1\n  while (i <= count)\n  {\n    equal <- randomizer(equal)\n\n    if (skipper == 0)\n    {\n      randomPartitions[i,] <- equal\n      skipper <- skip\n      i <- i + 1\n    }\n    else\n    {\n      skipper <- skipper - 1\n    }\n  }\n\n  rownames(randomPartitions) <- c(1:nrow(randomPartitions))\n\n  return (randomPartitions)\n}\n\noptimizeQuantity <- function(randomPartitions, prices, qHat, periods, vest, cost)\n{\n  # Generate quantities which maximize profit for monetization given prices, via global \n  # optimization using DEoptim().\n  #\n  # Args:\n  #   randomPartitions: random partition of quantities, previously generated by randomPartitions()\n  #   prices: vector of prices, aligned with quantity\n  #   qHat: maximum quantity, which should satisfy invariant sum(quantity) = qHat\n  #   periods: number of periods to optimize quantities\n  #   vest: vector of number of shares vested per period, aligned with quantity\n  #   cost: average cost per share, aligned with quantity\n  #\n  # Returns: vector of quantities optimized to maximize monetization\n\n    lower <- rep(0, periods)\n    upper <- rep(qHat, periods)\n    cont <- DEoptim.control(trace=FALSE, itermax=500, initialpop=randomPartitions,\n                            NP=as.numeric(nrow(randomPartitions)))\n    DEoptim(profit, lower, upper, control=cont, prices, qHat, vest, cost)\n}\n\n# Monte-Carlo sampling for optimal partition equity monetization (perfect foresight)\noptimalEquityMonetization <- function(prices, periods, qHat, vest, cost, mcCount, doPlot=FALSE)\n{\n  # Calculate profit of optimal equity monetization using monte carlo sampling assuming perfect \n  # foresight from random quantity partitions.\n  #\n  # Args:\n  #   prices: daily prices from equity\n  #   periods: number of periods to calculate optimal\n  #   qHat: maximum quantity, which should satisfy invariant sum(quantity) = qHat\n  #   vest: vector of number of shares vested per period, aligned with quantity\n  #   cost: average cost per share, aligned with quantity\n  #   mcCount: number of monte carlo iterations\n  #   doPlot: flag indicating to plot the monte carlo return series\n  #\n  # Returns: vector of profits from monte carlo, length equal to mcCount\n\n  message(\"Fitting and sampling returns distribution\\n\")\n  samples <- sampleDistribution(fitDistribution(returns), periods, mcCount)\n\n  optimalEquityMonetizationWithSamples(prices, periods, qHat, vest, cost, samples, doPlot)\n}\n\noptimalEquityMonetizationWithSamples <- function(prices, periods, qHat, vest, cost, samples, doPlot=FALSE)\n{\n  # Calculate profit of optimal equity monetization using monte carlo sampling assuming perfect \n  # foresight from random quantity partitions.\n  #\n  # Args:\n  #   prices: daily prices from equity\n  #   periods: number of periods to calculate optimal\n  #   qHat: maximum quantity, which should satisfy invariant sum(quantity) = qHat\n  #   vest: vector of number of shares vested per period, aligned with quantity\n  #   cost: average cost per share, aligned with quantity\n  #   samples: future return samples, over which monte carlo is evaluated\n  #   doPlot: flag indicating to plot the monte carlo return series\n  #\n  # Returns: vector of profits from monte carlo, length equal to mcCount\n\n  returns <- ROC(prices,type=\"discrete\",na.pad=FALSE)\n  priceNow <- last(prices)\n\n  message(\"Building random partitions\\n\")\n  randomPartitions <- randomPartitions(qHat, periods,1000)\n\n  message(\"Optimizing optimal\\n\")\n  mcCount <- nrow(samples)\n  profits <- sapply(c(1:mcCount), function(i) {\n\n    returns <- samples[i,]\n\n    if (doPlot) { plot(cumprod(1+returns),type='l') }\n\n    prices <- as.matrix(coredata(priceNow) * cumprod(1+returns))\n\n    # find quantities which maximize profit\n    optim <- optimizeQuantity(randomPartitions, prices, qHat, periods, vest, cost)\n    best <- -optim$optim$bestval\n\n    best\n  })\n\n  return (as.matrix(profits))\n}\n\nequalEquityMonetization <- function(prices, periods, qHat, vest, cost, mcCount, doPlot=FALSE)\n{\n  # Calculate profit of optimal equity monetization using from monte carlo sampling \n  # assuming equal-size quantity partitions.\n  #\n  # Args:\n  #   prices: daily prices from equity\n  #   periods: number of periods to calculate optimal\n  #   qHat: maximum quantity, which should satisfy invariant sum(quantity) = qHat\n  #   vest: vector of number of shares vested per period, aligned with quantity\n  #   cost: average cost per share, aligned with quantity\n  #   mcCount: number of monte carlo iterations\n  #   doPlot: flag indicating to plot the monte carlo return series\n  #\n  # Returns: vector of profits from equal monetization, length equal to mcCount\n\n  message(\"Fitting and sampling returns distribution\\n\")\n  samples <- sampleDistribution(fitDistribution(returns), periods, mcCount)\n\n  equalEquityMonetizationWithSamples(prices, periods, qHat, vest, cost, samples, doPlot)\n}\n\nequalEquityMonetizationWithSamples <- function(prices, periods, qHat, vest, cost, samples, doPlot=FALSE)\n{\n  # Calculate profit of optimal equity monetization using from monte carlo sampling \n  # assuming equal-size quantity partitions.\n  #\n  # Args:\n  #   prices: daily prices from equity\n  #   periods: number of periods to calculate optimal\n  #   qHat: maximum quantity, which should satisfy invariant sum(quantity) = qHat\n  #   vest: vector of number of shares vested per period, aligned with quantity\n  #   cost: average cost per share, aligned with quantity\n  #   doPlot: flag indicating to plot the monte carlo return series\n  #\n  # Returns: vector of profits from equal monetization, length equal to mcCount\n\n  returns <- ROC(prices,type=\"discrete\",na.pad=FALSE)\n  priceNow <- last(prices)\n\n  message(\"Optimizing equal\\n\")\n  mcCount <- nrow(samples)\n  profits <- sapply(c(1:mcCount), function(i) {\n\n    returns <- samples[i,]\n\n    if (doPlot) { plot(cumprod(1+returns),type='l') }\n\n    prices <- as.matrix(coredata(priceNow) * cumprod(1+returns))\n\n    # calculate profit for equal quantities\n    quantity <- rep.int(qHat / periods, periods)\n    best <- -profit(quantity, prices, qHat, vest, cost)\n\n    best\n  })\n\n  return (as.matrix(profits))\n}\n\nanalyzeMonetizationFromSymbol <- function(symbol, quoteType, qHat, periods, perShareCost, mcCount=500)\n{\n  # Plot optimal vs equal equity monetization profits.\n  #\n  # Args:\n  #   symbol: equity symbol which to monetize\n  #   quoteType: quote type for equity, such as \"AdjClose\"\n  #   qHat: total quantity of shares to monetize\n  #   periods: number of distinct periods over which to monetize\n  #   perShareCost: cost to exercise share; zero for RSUs; strike price for ISO/NQs\n  #   mcCount: number of monte carlo iterations\n\n  prices <- get.hist.quote(instrument=symbol,quote=quoteType)\n  analyzeMonetization(prices, qHat, periods, perShareCost, mcCount)\n}\n\nanalyzeMonetization <- function(prices, qHat, periods, perShareCost, mcCount=500)\n{\n  # Generate monte carlo densities of optimal and equal equity monetization profits.\n  #\n  # Args:\n  #   prices: vector of prices to monetize\n  #   qHat: total quantity of shares to monetize\n  #   periods: number of distinct periods over which to monetize\n  #   perShareCost: cost to exercise share; zero for RSUs; strike price for ISO/NQs\n  #   mcCount: number of monte carlo iterations\n  #\n  # Returns: percentage difference in profit between optimal and equal \n\n  message(\"Fitting and sampling returns distribution\\n\")\n  samples <- sampleDistribution(fitDistribution(returns), periods, mcCount)\n\n  optimal <- optimalEquityMonetizationWithSamples(prices, \n                                       periods, qHat,rep(qHat/periods,periods), \n                                       rep(perShareCost,periods), samples)\n\n  equal <- equalEquityMonetizationWithSamples(prices, \n                                   periods, qHat, rep(qHat/periods,periods), \n                                   rep(perShareCost,periods), samples)\n\n  plot(density(optimal), main=\"Optimal Monetization Density (with Median)\", xlab=\"Profit\",\n       ylim=c(min(density(optimal)$y,density(equal)$y),\n              max(density(optimal)$y,density(equal)$y)))\n  lines(density(equal), col='red')\n  abline(v=median(optimal),lty=2)\n  abline(v=median(equal),col='red',lty=2)\n  legend(\"topleft\",legend=c(\"Optimal\",\"Equal\"), fill=c('black', 'red'), cex=0.5)\n\n  # calculate difference in first moments of optimal and equal\n  medOptimal <- median(optimal)\n  medianDiff <- ((medOptimal - median(equal)) / medOptimal)\n\n  meanOptimal <- mean(optimal)\n  meanDiff <- ((meanOptimal - mean(equal)) / meanOptimal)\n\n  return (list(medianDiff=medianDiff, meanDiff=meanDiff, optimal=optimal, equal=equal))\n}\n\n```"]