- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-18 15:32:14'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating High Dimensional Expectation | Tr8dr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://tr8dr.wordpress.com/2010/08/31/evaluating-high-dimensional-expectation/#0001-01-01](https://tr8dr.wordpress.com/2010/08/31/evaluating-high-dimensional-expectation/#0001-01-01)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here I am going to outline a simple approach to evaluating a high dimensional
    discrete expectation on empirical data.   For example, if one considers the evaluating
    an expectation like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/516614852be6411feac4909467513704.png "Screen shot 2010-08-31 at 5.33.37
    PM")](https://tr8dr.wordpress.com/wp-content/uploads/2010/08/screen-shot-2010-08-31-at-5-33-37-pm.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say X is of dimension 10 and we have a 10000 x 10 matrix of observations.
      Furthermore each of the 10 variables can take 5 possible states:'
  prefs: []
  type: TYPE_NORMAL
- en: X0 = { 1,4,4,1,1,1,1,3,3,2 }
  prefs: []
  type: TYPE_NORMAL
- en: X1 = { 1,2,2,2,1,1,1,5,5,2 }
  prefs: []
  type: TYPE_NORMAL
- en: ….
  prefs: []
  type: TYPE_NORMAL
- en: The total number of possible distinct state vectors is 5^10 or over 9 million.
      A naive approach to the above integral is to consider all possible sequences
    of X, but this would be enormously expensive and will not scale as the dimension
    or number of individual states grows.
  prefs: []
  type: TYPE_NORMAL
- en: The distribution is going to be sparse.  We know this because 5^10 >> 10,000
    observations.   The worst case algorithm would involve a scan for a given pattern,
    calculating the frequency.   This poor approach would have complexity  **O(N S^d)**,
    where **N** is the number of samples, **S** is the number of distinct symbols,
    and **d** is the dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some simple observations:'
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense to restrict the domain of the integral to existant sequences
    (get rid of complexity S^d)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It makes sense to avoid multiple passes, where naively there would be a pass
    for each frequency calculation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we are dealing with a finite sample and known symbols there is an approach
    that is **O (N log N)**.   We create a binary or n-nary tree ordered lexically
    by symbol sequence.   Iterating through the samples, for each sample locate or
    insert a node in the tree, tracking its frequency.   Increment frequency.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/950898a02e7c392e23642af4a9664465.png "Screen shot 2010-08-31 at 7.41.11
    PM")](https://tr8dr.wordpress.com/wp-content/uploads/2010/08/screen-shot-2010-08-31-at-7-41-11-pm.png)'
  prefs: []
  type: TYPE_NORMAL
- en: The tree is rearranged as necessary to create balance and reduce the average
    path length to log N.  In one pass we now know both the domain of the distribution
    and the frequencies.   The expectation is now straight-forward to evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: Note that instead of using a tree, one can use a hash-table keyed off of sequences.
      This will result in an O(N) algorithm.   For some applications, though, it is
    useful to have a tree that places neighbors close to each other (for instance
    if we want to run a near neighbor analysis).
  prefs: []
  type: TYPE_NORMAL
