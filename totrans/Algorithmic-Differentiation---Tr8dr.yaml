- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-18 15:34:58'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Algorithmic Differentiation | Tr8dr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://tr8dr.wordpress.com/2010/01/11/algorithmic-differentiation/#0001-01-01](https://tr8dr.wordpress.com/2010/01/11/algorithmic-differentiation/#0001-01-01)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the previous post I outlined a portfolio utility function with a penalty
    for risk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/cc02ddc60239e26051e63c2063851ef7.png "utility")](https://tr8dr.wordpress.com/wp-content/uploads/2010/01/utility.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the components of this function, E[r], is specified as a weighted geometric
    average.   By itself I could transform to use a log sum but does not simplify
    with the added risk term:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/3bcf1775358ae0a8a2dc64b5958ca50b.png "geometric")](https://tr8dr.wordpress.com/wp-content/uploads/2010/01/geometric.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'I need to construct a gradient and hessian for the above function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/65807d837fec379b33630765c84c2395.png "derivs")](https://tr8dr.wordpress.com/wp-content/uploads/2010/01/derivs.png)'
  prefs: []
  type: TYPE_NORMAL
- en: It is not that the 2nd partial derivative is intractable, indeed it just requires
    the application of the chain rule.  Unfortunately it expands to an enormously
    complicated expression that grows quadratically with the number of variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computing the derivative via finite differencing works for some applications,
    but presents problems where the “perturbations” need to be small.   The 2nd derivative
    using a central weighing scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/8a9ad78a205e3af105796e7309889e6e.png "central")](https://tr8dr.wordpress.com/wp-content/uploads/2010/01/central.png)'
  prefs: []
  type: TYPE_NORMAL
- en: One can see that the differenced approach is susceptible underflow.   Choosing
    a value of **h** **< 1e-7** will produce a value which exceeds the precision of
    a double (consider the denominator).   Once the precision of double is exceeded,
    results will be meaningless.
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithmic Approach**'
  prefs: []
  type: TYPE_NORMAL
- en: I began to think of a recursive approach to evaluating the nth partial derivative,
    as I had trouble coming up with a pattern that fit into a single expression for
    generalized number of periods and dimension.   It turns out that many others have
    thought along these lines.   This approach is called “Algorithmic Differentiation”.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above equation can be simplified with respect to just 2 of its N variables
    for the purposes of calculating 1 coordinate in the hessian as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/c8a150282c1b3c0d8aebbf3da2330806.png "reexpression")](https://tr8dr.wordpress.com/wp-content/uploads/2010/01/reexpression.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We understand how to differentiate the above by means of the chain rule, which
    states that compositional functions, such as f(g(x)) can be differentiated as
    f''(g(x)) g''(x).   This implies a series of basic rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/bf6fafb264b2f454c2f8368f8b6e5d82.png "rules")](https://tr8dr.wordpress.com/wp-content/uploads/2010/01/rules.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can decompose an expression into an (implicit or explicit) expression tree
    and use the rules for derivatives to recombine to an ultimate result.   For instance,
    here is a tree for f(x,y) = x y sin(x^2).   (the graph for my function would be
    much too large to render here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/1e0e82d1a9748c965d5ae837a52c7dc9.png "tree")](https://tr8dr.wordpress.com/wp-content/uploads/2010/01/tree.png)'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of libraries (for C++ and Java) which allow one to express
    a function in normal-looking code, but implicitly calculate the first or second
    derivatives at the same time.   A “dual” representing f(x) and f'(x) is tracked
    through the evaluation of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the size of the expression (tree) for my utility function is
    enormous, particularly for the 2nd derivative.   I will avoid computing the hessian
    and use the BFGS minimizer for part of my optimization, as will end up being cheaper
    than evaluating the hessian.
  prefs: []
  type: TYPE_NORMAL
