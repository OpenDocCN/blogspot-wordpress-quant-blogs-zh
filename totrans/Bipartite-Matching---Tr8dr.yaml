- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-18 15:30:19'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Bipartite Matching | Tr8dr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://tr8dr.wordpress.com/2011/02/17/bipartite-matching/#0001-01-01](https://tr8dr.wordpress.com/2011/02/17/bipartite-matching/#0001-01-01)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: February 17, 2011 · 6:02 pm
  prefs: []
  type: TYPE_NORMAL
- en: For very low-level order analysis we try to determine continuity from one order
    to the next as a stream of orders across a period.   This is applicable for orders
    generated by a given trader (algo) that are more-or-less continually in the market.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases an order near the top of book has a short lifetime, but an algo
    will maintain continuity through resubmission into the order book at a different
    price level.   This stream of orders is often masked in various ways, but often
    has discernable patterns, depending on the sophistication or consideration towards
    masking this in the algo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going from order deletions to new order insertions we want to attempt to match
    up the old and new orders (where applicable), to determine the continuity of an
    order stream.   We therefore want to map from an old-set to a new-set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/67eebe4ddeff54636a975fa199e0a88c.png "Screen shot 2011-02-17 at 5.10.30
    PM")](https://tr8dr.wordpress.com/wp-content/uploads/2011/02/screen-shot-2011-02-17-at-5-10-30-pm.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in order to determine, we have to explore all possible mappings with
    weights between these edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/5ad0216c28da2d83af8ddaaf07d5ae8f.png "Screen shot 2011-02-17 at 5.15.26
    PM")](https://tr8dr.wordpress.com/wp-content/uploads/2011/02/screen-shot-2011-02-17-at-5-15-26-pm.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The optimal mapping will be one that finds the set of one-to-one edges that
    has maximal weight.   This is a problem in graph theory and optimisation theory.
      This can be expressed rather neatly as a linear constraints problem where we
    have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/7772ea8f7e627072781b0992483a0bfe.png "Screen shot 2011-02-17 at 5.42.30
    PM")](https://tr8dr.wordpress.com/wp-content/uploads/2011/02/screen-shot-2011-02-17-at-5-42-30-pm.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where Xij is a matrix of 0 or 1, 1 indicating an edge and 0 no edge.  Wij is
    a corresponding matrix of weights for each edge.   Integer (or integral) linear
    programming solutions are classified as NP-hard and do not have an efficient algorithm.
       We will be evaluating these on a relatively small # of orders each time, so
    the cost of a brute force solution is not bad.'
  prefs: []
  type: TYPE_NORMAL
- en: The real trick is in determining the weights, representing the degree of similarity.
     Going further, one may generate a tree of these (that spans out exponentially,
    but is trimmed regularly).   Some decisions on prior matches will be wrong and
    should be reevaluated holistically.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/2d12a624f07102272f6025bba4e524ff.png "Screen shot 2011-02-17 at 5.59.50
    PM")](https://tr8dr.wordpress.com/wp-content/uploads/2011/02/screen-shot-2011-02-17-at-5-59-50-pm.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Is it worth the effort?   Depends on what information you are interested in
    and what your game is.   We do a mixture range ultra-high frequency to medium
    frequency.   This is one sub-problem of a bigger picture.
  prefs: []
  type: TYPE_NORMAL
- en: Addendum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I should mention that the worst case brute-force approach involves examining
    combined weights for each permutation of edges.  This is a O(n!) algorithm that
    quickly becomes uncomputable.   For the specific bipartite matching problem, rather
    than the general Integral Linear Programming problem there are much more efficient
    solutions.   One of the simplest (though not the most efficient) is the “[Hungarian
    algorithm](http://en.wikipedia.org/wiki/Hungarian_algorithm)“.   A reader pointed
    out a paper for an “[online” approach](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.64.1078&rep=rep1&type=pdf)
    to matching as well.
  prefs: []
  type: TYPE_NORMAL
