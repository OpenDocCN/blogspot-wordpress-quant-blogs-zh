- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分类：未分类
- en: 'date: 2024-05-18 06:00:26'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024年05月18日 06:00:26
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'Glitch: Live Programming | Tales from a Trading Desk'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Glitch：即时编程 | 来自交易台的故事
- en: 来源：[https://mdavey.wordpress.com/2013/10/01/glitch-live-programming/#0001-01-01](https://mdavey.wordpress.com/2013/10/01/glitch-live-programming/#0001-01-01)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://mdavey.wordpress.com/2013/10/01/glitch-live-programming/#0001-01-01](https://mdavey.wordpress.com/2013/10/01/glitch-live-programming/#0001-01-01)
- en: 'Glitch: Live Programming'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Glitch：即时编程
- en: Interesting read from Microsoft Research on Live [Programming](http://research.microsoft.com/pubs/201333/rem13.pdf), 
    As referenced by the paper, [Bret](http://worrydream.com/) Victor’s work has thankfully
    been considered.  Now all we have to do is wait n years, and maybe Glitch will
    see the light of day in Visual Studio.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 微软研究中对[编程](http://research.microsoft.com/pubs/201333/rem13.pdf)进行了有趣的阅读，正如该论文引用的，[Bret](http://worrydream.com/)
    Victor的作品已经被考虑进来了。现在我们需要做的就是等待n年，也许Glitch将在Visual Studio中见到天日。
- en: 'Input changes are often handled by reactive and incremental constructs that
    are tedious to use or inexpressive, while changes to program code are typically
    not handled at all during execution, complicating support for “live programming.”
    We propose that change in code and input should be managed automatically, similar
    to how garbage collection eliminates memory management as an explicit programmer
    concern. Our programming model, Glitch, realizes such managed time by progressively
    re-executing nodes of program execution when they become inconsistent due input/code
    state changes. Unlike many reactive models, Glitch supports expressive shared-state
    procedural programming, but with one caveat: operations on shared state must be
    undoable and commutative to ensure re-execution efﬁciency and eventual consistency.
    Still, complex programs like compilers can be written in Glitch using mundane
    programming styles.'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对输入更改通常由响应式和增量构造处理，这些构造使用起来很麻烦，表达能力有限，而程序代码的更改在执行期间通常根本不处理，使得对“实时编程”的支持变得更加复杂。我们提出，代码和输入的更改应该得到自动管理，类似于垃圾回收消除了内存管理作为程序员的显式关注点。我们的编程模型Glitch通过逐渐重新执行程序执行的节点，在输入/代码状态更改时变得不一致时，实现了这种管理时间。与许多响应式模型不同，Glitch支持有表达力的共享状态过程化编程，但有一个附加条件：对共享状态的操作必须是可撤销的和可交换的，以确保重新执行的效率和最终一致性。尽管如此，像编译器这样的复杂程序也可以用平庸的编程样式写成。
- en: ~ by mdavey on October 1, 2013.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ~ 作者mdavey于2013年10月1日。
- en: Posted in [Languages](https://mdavey.wordpress.com/category/languages/)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 发布在[编程语言](https://mdavey.wordpress.com/category/languages/)分类中
