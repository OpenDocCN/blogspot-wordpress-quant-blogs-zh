- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-18 06:47:03'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Introducing QuantLib: The Term Structure of Interest Rates | All things finance
    and technology…'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://mhittesdorf.wordpress.com/2013/02/25/introducing-quantlib-the-term-structure-of-interest-rates/#0001-01-01](https://mhittesdorf.wordpress.com/2013/02/25/introducing-quantlib-the-term-structure-of-interest-rates/#0001-01-01)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the last post of this series, I began talking about QuantLib’s support for
    representing the term structure of interest rates, which is typically referred
    to by finance practitioners as the ‘yield curve’.  Under normal economic conditions,
    the yield curve slopes upward – long term interest rates are higher than short-term
    interest rates.  The following chart graphically depicts the relationship between
    interest rates and time to maturity.
  prefs: []
  type: TYPE_NORMAL
- en: '[![yield_curve](img/b5092c34549fd4e858b517f0b2fdf6fd.png)](https://mhittesdorf.wordpress.com/wp-content/uploads/2013/02/yield_curve.jpeg)'
  prefs: []
  type: TYPE_NORMAL
- en: The level, slope and shape of the yield curve are intrinsic to the pricing and
    risk management of bonds and bond portfolios.  To price a bond accurately, or,
    more generally, to compute the present value of future cash flows accurately,
    the interest rate at the time the cash flow occurs must be inferred from the yield
    curve.
  prefs: []
  type: TYPE_NORMAL
- en: So let’s revisit our earlier bond pricing example to see how one would go about
    building a yield curve and pricing a bond with it using QuantLib’s [YieldTermStructure](http://quantlib.org/reference/class_quant_lib_1_1_yield_term_structure.html)
    class.  Consider a 3 year fixed rate bond with a face value of 100 and an interest
    rate of 3% with annual coupons that pay 5% compounded annually.  We’ve already
    seen that the bond’s price is 105.66.  The code below shows how to reproduce this
    price using an explicit yield curve rather than a single, constant rate.  One
    thing to note is that a constant interest rate is the same as a flat yield curve,
    one where the rate is the same at all maturities.  So that we calculate the same
    price as before, 105.66, the example uses QuantLib’s [FlatForward](http://quantlib.org/reference/class_quant_lib_1_1_flat_forward.html)
    class to represent the yield ‘curve’.
  prefs: []
  type: TYPE_NORMAL
- en: '`#include <cstdlib>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: '#define BOOST_AUTO_TEST_MAIN'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <boost/test/unit_test.hpp>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <boost/detail/lightweight_test.hpp>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <ql/quantlib.hpp>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <vector>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <ql/instruments/bonds/fixedratebond.hpp>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`BOOST_AUTO_TEST_CASE(testPriceBondWithFlatTermStructure) {'
  prefs: []
  type: TYPE_NORMAL
- en: Calendar calendar = UnitedStates(UnitedStates::GovernmentBond);
  prefs: []
  type: TYPE_NORMAL
- en: const Natural settlementDays = 3;
  prefs: []
  type: TYPE_NORMAL
- en: Date today = Date::todaysDate();
  prefs: []
  type: TYPE_NORMAL
- en: Date issueDate = today;
  prefs: []
  type: TYPE_NORMAL
- en: Date terminationDate = issueDate + Period(3, Years);
  prefs: []
  type: TYPE_NORMAL
- en: Rate rate = .03;
  prefs: []
  type: TYPE_NORMAL
- en: InterestRate couponRate(.05, ActualActual(ActualActual::Bond), Compounded, Annual);
  prefs: []
  type: TYPE_NORMAL
- en: Real faceValue = 100.0;
  prefs: []
  type: TYPE_NORMAL
- en: std::vector<InterestRate> coupons(3, couponRate);
  prefs: []
  type: TYPE_NORMAL
- en: Schedule schedule(issueDate, terminationDate, Period(Annual), calendar,
  prefs: []
  type: TYPE_NORMAL
- en: Unadjusted, Unadjusted, DateGeneration::Backward, false);
  prefs: []
  type: TYPE_NORMAL
- en: FixedRateBond fixedRateBond(settlementDays, faceValue, schedule, coupons);
  prefs: []
  type: TYPE_NORMAL
- en: boost::shared_ptr<YieldTermStructure> flatForward(new FlatForward(issueDate,
    rate, ActualActual(ActualActual::Bond), Compounded, Annual));
  prefs: []
  type: TYPE_NORMAL
- en: Handle<YieldTermStructure> flatTermStructure(flatForward);
  prefs: []
  type: TYPE_NORMAL
- en: boost::shared_ptr<PricingEngine> bondEngine(new DiscountingBondEngine(flatTermStructure));
  prefs: []
  type: TYPE_NORMAL
- en: fixedRateBond.setPricingEngine(bondEngine);
  prefs: []
  type: TYPE_NORMAL
- en: Real npv = fixedRateBond.NPV();
  prefs: []
  type: TYPE_NORMAL
- en: 'std::cout << "NPV of bond is: " << npv << std::endl;'
  prefs: []
  type: TYPE_NORMAL
- en: '}`'
  prefs: []
  type: TYPE_NORMAL
- en: A key feature of this code is the use of a pricing engine, DiscountingBondEngine.
    A pricing engine is a common QuantLib abstraction which effectively encapsulates
    instrument-specific valuation logic.  The constructor of the DiscountingBondEngine
    takes the yield curve as an argument, from which the engine extracts the interest
    rates required to discount the bond’s coupons.  Of note also is that the coupon
    payment dates are generated by QuantLib’s [Schedule](http://quantlib.org/reference/class_quant_lib_1_1_schedule.html)
    class, which takes into account a supplied calendar for determining business days
    and holidays.  Overall, this code illustrates what is required to price a bond
    in the real world, with the obvious caveat that the term structure is flat.  To
    redress this last remaining deficiency, the [FittedBondDiscountCurve](http://quantlib.org/reference/class_quant_lib_1_1_fitted_bond_discount_curve.html)
    class can be substituted for the FlatForward class.  On the QuantLib Web site
    you can find a complete example, [FittedBondCurve.cpp](http://quantlib.org/reference/_fitted_bond_curve_8cpp-example.html),
    that shows how to use the FittedBondDiscountCurve to ‘bootstrap’ a yield curve
    given market rate quotes.  I encourage you to check it out.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for now.  In my next post, I’ll back out the interest rate for a sequence
    of cash flows using a QuantLib solver. See you then!
  prefs: []
  type: TYPE_NORMAL
- en: About Mick Hittesdorf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I'm a versatile technical leader with a passion for data analytics, data science
    and Big Data technology. I have experience working for both large and small organizations,
    in a variety of roles. I've been responsible for the management and operations
    of a global data science and analytics platform, developed low latency, proprietary
    trading systems, managed software development teams, defined enterprise architecture
    strategies, written white papers and blogs, published articles in industry journals
    and delivered innovative solutions to clients, both in a consulting and technical
    sales capacity. My current areas of focus include Big Data, data engineering,
    data science, R, and Cloud computing
  prefs: []
  type: TYPE_NORMAL
