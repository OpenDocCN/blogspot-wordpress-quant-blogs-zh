- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-17 23:41:36'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Parallel Model Calibration using MPI and Boost.MPI – HPC-QuantLib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://hpcquantlib.wordpress.com/2012/04/09/parallel-model-calibration-using-mpi-and-boost-mpi/#0001-01-01](https://hpcquantlib.wordpress.com/2012/04/09/parallel-model-calibration-using-mpi-and-boost-mpi/#0001-01-01)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The message passing standard [MPI](http://www.mpi-forum.org/) is a language-independent
    communication protocol. MPI supports the parallelization of numerical algorithms
    on both massive parallel computers and on symmetric multi processor systems. MPI
    is standardized, highly portable and the de facto standard on massive parallel
    supercomputers. Even though MPI can be used in a multi-threading environment it
    is normally used in a multi-process environment. Therefore MPI is tailor-made
    to parallelize algorithms based on the non thread-safe QuantLib.
  prefs: []
  type: TYPE_NORMAL
- en: The roots of the MPI specification are going back to the early 90’s and you
    will feel the age if you use the C-API, which is designed to achieve maximum performance.
    The [Boost.MPI](http://www.boost.org/doc/libs/1_49_0/doc/html/mpi.html) library
    – quoting from the web page – “is a C++ friendly interface to the standard Message
    Passing Interface… Boost.MPI can build MPI data types for user-defined types using
    the [Boost.Serialization](http://www.boost.org/libs/serialization/doc) library”.
  prefs: []
  type: TYPE_NORMAL
- en: Model calibration can be a very time-consuming task, e.g. the calibration of
    a Heston or a Heston-Hull-White model using American puts with discrete dividends.
    The class MPICalibrationHelper acts as a MPI wrapper for a given CalibrationHelper
    and allows to parallelize an existing model calibration routine (hopefully with
    minimal impact/effort). The source code is available [here](http://hpc-quantlib.de/src/mpicalibrationhelper.zip).
    It contains the MPICalibrationHelper class and as an example the parallel version
    of the DAXCalibration test case (part of test-suite/hestonmodel.cpp). The code
    depends on [QuantLib 1.0](http://quantlib.org) or higher, [Boost.Thread](http://www.boost.org/doc/libs/1_49_0/doc/html/thread.html)
    and [Boost.MPI](http://www.boost.org/doc/libs/1_49_0/doc/html/mpi.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/da07e3f94a5b8d4ddd21875b42052c0c.png "plot")](https://hpcquantlib.wordpress.com/wp-content/uploads/2012/04/plot.png)The
    diagram above shows the speed-up of a Heston-Hull-White calibration with discrete
    dividends on an eight core machine using a finite difference pricing engine. The
    main reason for the sub-linear scaling is the limited memory bandwidth between
    the CPUs and the main memory and not the MPI communication overhead.'
  prefs: []
  type: TYPE_NORMAL
