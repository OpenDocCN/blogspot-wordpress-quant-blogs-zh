<!--yml
category: 未分类
date: 2024-05-12 19:32:32
-->

# YieldCurveBootstrapping _BLOCK_TYPE_IS_VALID in SpreadServe | Coding the markets

> 来源：[https://etrading.wordpress.com/2014/12/18/yieldcurvebootstrapping-_block_type_is_valid-in-spreadserve/#0001-01-01](https://etrading.wordpress.com/2014/12/18/yieldcurvebootstrapping-_block_type_is_valid-in-spreadserve/#0001-01-01)

## YieldCurveBootstrapping _BLOCK_TYPE_IS_VALID in SpreadServe

### December 18, 2014

The old ones are the best ones, and I spent too many hours yesterday butting my head against a classic Windows bug. I was testing an optimisation in the [SpreadServeEngine](http://spreadserve.com/product/user-guide/)‘s handling of nested invocations of XLL supplied functions. I was using [QuantLib](http://quantlib.org/index.shtml)‘s YieldCurveBootstrapping spreadsheet, and the QuantLib 1.4.0 XLL addin. The sheet invokes the [qlPiecewiseYieldCurve](http://www.bnikolic.co.uk/ql/addindoc/f/qlPiecewiseYieldCurve.html) function, and the fourth parameter, RateHelpers, is supplied by an invocation of ohPack. Normally in this scenario, the XLOPER returned by ohPack would be marshalled to the engine’s internal representation, before being marshalled back to an XLOPER for handing into qlPiecewiseYieldCurve. I added a shortcut that made the XLOPER available as well as the internal representation, so the marshalling process could proceed by shortcut if possible. Unwittingly I ended up newing an object in one DLL which was released by another DLL when qlPiecewiseYieldCurve returned and released it’s stack frame. My debug build threw a run time assert on _BLOCK_TYPE_IS_VALID. Cue a bug hunt with me toothcombing through the codebase for a double delete or a buffer overrun. Spreadsheet engines are complex beasts since they’re basically a runtime for a functional programming language, so must maintain an object graph and dispatch imperatively at the nodes to tokenised code and XLL supplied C/C++ functions. There’s a lot of memory pool and stack management to do in all that! So I was sure there was a subtle memory management bug somewhere that had been exposed by my optimisation for the nested XLL functions corner case. While I was looking for the bug I did get some good reading on Windows heap debugging done: [this](http://msdn.microsoft.com/en-us/library/bebs9zyz%28v=vs.90%29.aspx) and [this](http://msdn.microsoft.com/en-us/library/ms235460.aspx) are recommended. When debugging it’s easy to keep going deeper and deeper in pursuit of a supposedly subtle bug. Better to take a breath and try and widen one’s focus. It was this article that made me think again about the fact that each DLL has it’s own C run time linked in, and if their memory management implementations differ, there will be problems. So it was in this case. Adding a static allocator function to the DLL responsible for freeing the object ensured that the new & delete were done by the same DLL, and the bootstrapping model started running through smoothly. Of course what I need to do now is revisit my build system’s link model and ensure all DLLs and EXEs are linking the same CRT implementation…