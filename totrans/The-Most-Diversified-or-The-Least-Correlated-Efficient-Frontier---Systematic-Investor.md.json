["```\n\nportfolio.sigma = sqrt( t(weight) %*% assets.cov %*% weight )\nmean( ( weight %*% assets.cov ) / ( assets.sigma * portfolio.sigma ) )\n\n# Alternatively\nportfolio.returns = weight %*% t(assets.hist.returns)\t\nmean(cor(assets.hist.returns, portfolio.returns)) \n\n```", "```\n\n\t#--------------------------------------------------------------------------\n\t# Create Efficient Frontier\n\t#--------------------------------------------------------------------------\n\tia = aa.test.create.ia()\n\tn = ia$n\t\t\n\n\t# 0 <= x.i <= 0.8 \n\tconstraints = new.constraints(n, lb = 0, ub = 0.8)\n\n\t# SUM x.i = 1\n\tconstraints = add.constraints(rep(1, n), 1, type = '=', constraints)\t\t\n\n\t# create efficient frontier(s)\n\tef.risk = portopt(ia, constraints, 50, 'Risk')\n\tef.cor.insteadof.cov = portopt(ia, constraints, 50, 'Cor instead of Cov', min.cor.insteadof.cov.portfolio)\n\tef.avgcor = portopt(ia, constraints, 50, 'AvgCor', min.avgcor.portfolio)\n\n\t# Plot multiple Efficient Frontiers\t\n\tlayout(1:2)\n\tplot.ef(ia, list(ef.risk, ef.avgcor, ef.cor.insteadof.cov), portfolio.risk, F)\t\n\tplot.ef(ia, list(ef.risk, ef.avgcor, ef.cor.insteadof.cov), portfolio.avgcor, F)\t\n\n\t# Plot multiple Transition Maps\t\n\tlayout( matrix(1:4, nrow = 2) )\n\tplot.transition.map(ef.risk)\n\tplot.transition.map(ef.avgcor)\n\tplot.transition.map(ef.cor.insteadof.cov)\n\n\t# visualize input assumptions\n\tplot.ia(ia)\n\n```", "```\n\nmin.avgcor.portfolio <- function\n(\n\tia,\t\t\t# input assumptions\n\tconstraints\t\t# constraints\n)\n{\n\trequire(Rdonlp2)\n\n\tcov = ia$cov[1:ia$n, 1:ia$n]\n\ts = sqrt(diag(cov))\n\n\t# avgcor\n\tfn <- function(x){\n\t\tsd_x = sqrt( t(x) %*% cov %*% x )\n\t\tmean( ( x %*% cov ) / ( s * sd_x ) )\n\t}\n\n\t# control structure\n\tcntl <- donlp2.control(silent = T, iterma =10000, nstep = 100, epsx = 1e-10)\t\n\n\t# lower/upper bounds\n\tpar.l = constraints$lb\n\tpar.u = constraints$ub\n\n\t# intial guess\n\tp = rep(1,n)\n\tif(!is.null(constraints$x0)) p = constraints$x0\n\n\t# linear constraints\n\tA = t(constraints$A)\n\tlin.l = constraints$b\n\tlin.u = constraints$b\n\tlin.u[ -c(1:constraints$meq) ] = +Inf\n\n\t# find solution\n\tsol = donlp2(p, fn, \n\t\t\tpar.lower=par.l, par.upper=par.u, \n\t\t\tA=A, lin.u=lin.u, lin.l=lin.l, \n\t\t\tcontrol=cntl)\n\tx = sol$par\n\n\treturn( x )\n}\n\n```"]