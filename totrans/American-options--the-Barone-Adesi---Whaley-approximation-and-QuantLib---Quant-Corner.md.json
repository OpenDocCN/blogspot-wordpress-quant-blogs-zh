["```\nDate today = QuantLib::Date::todaysDate();\n\t\tSettings::instance().evaluationDate() = today;\n```", "```\n\t\tcout << \"Call or put option (c/p)?: \\t\\t\";\n\t\tcin >> optionType;\n```", "```\nbool loopEnd = false;\ndo\n{\n} while (loopEnd != true);\n```", "```\n#include <ql\\quantlib.hpp>\n\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::setprecision;\nusing std::string;\n\nusing namespace QuantLib;\n\nint main(int, char*[]){\n\n\tbool loopEnd = false;\n\tdo\n\t{\n\n\ttry{\n\n\t\t// Option Parameters\n\t\tOption::Type type;\n\t\tReal underlying;\n\t\tReal strike;\n\t\tRate riskFreeRate;\n\t\tSpread dividendYield = 0;\n\t\tVolatility volatility;\n\t\tdouble optionValue;\n\n\t\tstd::string optionType;\n\t\tstd::string c;\n\n\t\tint maturityD;\n\t\tint maturityM;\n\t\tint maturityY;\n\n\t\tcout << \"Call or put option (c/p)?: \\t\\t\";\n\t\tcin >> optionType;\n\n\t\tcout << \"Enter expiration date (dd mm yyyy): \\t\";\n\t\tcin >> maturityD >> maturityM >> maturityY;\n\n\t\tcout << \"Enter strike: \\t\\t\\t\\t\";\n\t\tcin >> strike;\n\n\t\tcout << \"Enter underlying price: \\t\\t\";\n\t\tcin >> underlying;\n\n\t\tcout << \"Enter volatility (%): \\t\\t\\t\";\n\t\tcin >> volatility;\n\n\t\tcout << \"Enter risk free rate (%): \\t\\t\";\n\t\tcin >> riskFreeRate;\n\n\t\tif((optionType == (\"c\")) || (optionType == \"C\"))\n\t\t\ttype=Option::Call;\n\t\telse\n\t\t\ttype=Option::Put;\n\n\t\t// Calendar stuff\n\t\tCalendar calendar = TARGET();\n\t\tDate today = QuantLib::Date::todaysDate();\n\t\tSettings::instance().evaluationDate() = today;\n\t\tDayCounter dayCounter = Actual365Fixed();\n\t\tDate maturity(maturityD, Month (maturityM), maturityY);\n\n\t\t// American exercise style option handler\n\t\tboost::shared_ptr<Exercise> americanExercise(\n\t\t\tnew AmericanExercise(\n\t\t\ttoday, maturity));\n\n\t\t// Underlying price handler\n\t\tHandle<Quote> underlyingH(\n\t\t\tboost::shared_ptr<Quote>(\n\t\t\tnew SimpleQuote(underlying)));\n\n\t\t// Yield term structure handler\n\t\tHandle<YieldTermStructure> flatTermStructure(\n\t\t\tboost::shared_ptr<YieldTermStructure>(\n\t\t\tnew FlatForward(\n\t\t\ttoday,\n\t\t\triskFreeRate/100,\n\t\t\tdayCounter)));\n\n\t\t// Dividend handler\n\t\tHandle<YieldTermStructure> flatDividendTermStructure(\n\t\t\tboost::shared_ptr<YieldTermStructure>(\n\t\t\tnew FlatForward(\n\t\t\ttoday,\n\t\t\tdividendYield,\n\t\t\tdayCounter)));\n\n\t\t// Volatility handler\n\t\tHandle<BlackVolTermStructure> flatVolTermStructure(\n\t\t\tboost::shared_ptr<BlackVolTermStructure>(\n\t\t\tnew BlackConstantVol(\n\t\t\ttoday,\n\t\t\tcalendar,\n\t\t\tvolatility/100,\n\t\t\tdayCounter)));\n\n\t\t// Payoff handler\n\t\tboost::shared_ptr<StrikedTypePayoff> payoff(\n\t\t\tnew PlainVanillaPayoff(\n\t\t\ttype,\n\t\t\tstrike));\n\n\t\t// Black Scholes\n\t\tboost::shared_ptr<BlackScholesMertonProcess> BSMProcess(\n\t\t\tnew BlackScholesMertonProcess(\n\t\t\tunderlyingH,\n\t\t\tflatDividendTermStructure,\n\t\t\tflatTermStructure,\n\t\t\tflatVolTermStructure));\n\n\t\t// Option characteristics\n\t\tVanillaOption americanOption(payoff, americanExercise);\n\n\t\t// Pricing Engine : in this case BS for European options\n\t\tamericanOption.setPricingEngine(\n\t\t\tboost::shared_ptr<PricingEngine>(\n\t\t\tnew BaroneAdesiWhaleyApproximationEngine(\n\t\t\tBSMProcess)));\n\n\t\toptionValue = americanOption.NPV();\n\n\t\t// Outputting\n\t\tcout << endl;\n\t\tcout << \"Option price :\\t\" << setprecision(5) << optionValue << endl;\n\t\tcout << endl;\n\n\t\t}\n\t\tcatch (std::exception& e)\n\t\t{\n\t\t\tstd::cerr << e.what() << endl;\n\t\t\treturn 1;\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t\tstd::cerr << \"unknown error\" << endl;\n\t\t\treturn 1;\n\t\t}\t\t\n\n} while (loopEnd != true);\n}\n```"]